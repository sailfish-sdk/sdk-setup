#!/bin/bash
#
# Copyright (C) 2013 - 2020 Jolla Ltd.
# Copyright (C) 2019 - 2020 Open Mobile Platform LLC.
# Contact: http://jolla.com/
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
#
# - Redistributions of source code must retain the above copyright
#   notice, this list of conditions and the following disclaimer.
# - Redistributions in binary form must reproduce the above copyright
#   notice, this list of conditions and the following disclaimer in
#   the documentation and/or other materials provided with the
#   distribution.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.

shopt -s extglob

synopsis() {
    cat <<EOF
usage: $ME [global-opts] <command> [command-opts]
       $ME --version
EOF
}

short_usage() {
    synopsis
    cat <<EOF

Try '$ME --help' for more information.
EOF
    # exit if any argument is given
    [[ -n "$1" ]] && exit 1
}

usage() {
    less --quit-if-one-screen <<EOF
$(synopsis)

Executes a subset of build commands in the context of an rpmbuild.
Typically called from QtCreator to perform qmake/make phases of a project.
Note that any other build steps in the .spec file will also be run.

<specfile> will be looked for in the current rpm/ dir. If there is more than
one it must be provided.  $ME is aware of spectacle and will update the spec
file if there is an obvious yaml file which is newer.


SHADOW BUILDS

CWD is used as a base dir for installroot/ and RPMS/ to allow for shadow
builds. Shadow builds can be done by passing project file or directory path to
the "build" or "qmake" command:

    $ mkdir build && cd build
    $ mb2 build ../path/to/sources

    Or manually invoking each step:

    $ mkdir build && cd build
    $ mb2 qmake ../path/to/sources
    $ mb2 make
    $ mb2 package

Limitations related to shadow builds:

    1. Shadow build is only available for packages that use qmake and
       their build and install procedure is fully realized using qmake
       with no additional steps implemented at .spec level.
    2. The "--doprep" option to the "build" command cannot be used with shadow
       builds.
    3. If "prepare" or "apply" is needed, it must be used directly on the
       source tree prior to starting a shadow build (shadow builds for
       multiple targets are still possible provided that the %prep section is
       target-independent).


SHARED OUTPUT DIRECTORY

With shared output directory, it is possible to deploy all required packages
built from different sources more conveniently. This can be achieved with the
'--output-dir' option or even better with the combination of '--output-prefix'
and '--task' options.  Consider enabling '--output-prefix' and '--task' by
default by creating an alias in your '~/.mersdk.profile' to get build results
grouped by the tasks they are related to.  By default, the task will be
determined based on the current Git branch - check the '--task' option
description for more details:

    alias mb2='mb2 --output-prefix ~/RPMS --task'

    cd packageA
    git checkout -b bugXXXXX
    mb2 -t target build
    cd ../packageB
    git checkout -b bugXXXXX
    mb2 -t target build

    ls -1 ~/RPMS/bugXXXXX-my-target/
    mb2 -t target -d device deploy --manual --all \\
        && ssh device sudo zypper -p RPMS -v dup

With these options the output directory is also searched for build-time
dependencies by default, so if packageB requires packageA at build time, you
do not need to install packageA manually to the build target.

Note that it can be usefull to also pass '--from ~plus-repo-1' to 'zypper dup'.


CLEAN BUILDS

It is possible to avoid polluting build targets with build time dependencies
of a particular package by using the '--snapshot' option. With this option the
build target is not used directly. Instead a snapshot is taken and the build
is done using the snapshot of the build target. See '--snapshot' for details
on how the snapshot is chosen.

The snapshot will be reset automatically whenever the original build target is
updated, so if e.g. a locally built package is needed as a build-time
dependency, instead of installing it manually you should rely on the above
mentioned fact that with custom output directory the '--search-output-dir'
option is implied, and combine the '--snapshot' option with the
'--output-prefix' option.

For similar reasons, when mb2 fails to install build-time dependencies due to
errors like "file not found on the server", .i.e., because the local
repository cache got outdated, it is the original target that should be
updated, not the snapshot.

Consider enabling '--snapshot' by default as well:

    alias mb2='mb2 --output-prefix ~/RPMS --task --snapshot'

In order to ensure targets are not polluted by running mb2 without
'--snapshot' unintentionally, mb2 requires to use '--no-snapshot' explicitly
once at least one snapshot exists for a target.  Existing snapshots can be
listed and removed using 'sdk-assistant'.


QUALITY ASSURANCE

Certain quality checks may be performed with the help of the 'check' command:

    cd package
    mb2 build
    mb2 check

The command enables execution of (pluggable) test suites, each realizing
testing on one or more of the four recognized test levels:

    1. Static testing (verification) performed on the source tree

    2. Static testing (verification) performed on the build results (packages)

    3. Dynamic testing (validation) performed at build host (unit testing)

       Testing at this level is only supported with the built-in suite
       'rpmspec', that executes the steps defined by the '%check' section of
       the RPM .spec file if present.

       Testing at this level is normally performed by the 'build' and
       'package' commands (unless used with the '--nocheck' option) and so it
       is not enabled by default for this command. Performed with this
       command, it involves execution of the 'make-install' command.

    4. Dynamic testing (validation) performed on a target device (system testing)

       The 'check' command does not include the deployment step. Package(s)
       need to be deployed to the device selected with the 'device'
       configuration option beforehand, possibly with the 'deploy' command in
       case of packages associated with the build tree under CWD.

The available test suites may be listed with the '--list-suites' option to the
'check' command.

See the 'check' command to learn how to override the default selection of test
levels, suites and artefacts.


MAINTAINING CHANGELOGS

If a file exists with '.changes' extension, otherwise matching the
spec file name, the effect will be the same as having a %changelog
section in the spec file.  If a file with '.changes.run' extension is
found instead, this file will be executed and its output treated as
the actual changelog.

COMMANDS
    build-requires [--[no-]refresh] {pull|reset}
        When 'pull' is used, install or update the build-time dependencies as
        is done implicitly by the "prepare", "build" and "qmake" commands but
        refresh the package cache first, unless '--no-refresh' is active.

        When the global '--snapshot' option is used, '--no-refresh' is
        implied.  This can be overriden with '--refresh' - do not use unless
        you know what you are doing. If refresh is needed, refresh (and
        update) the original target instead.

        The 'reset' command can only be used together with the '--snapshot'
        global option, with the effect of reseting the target snapshot
        forcefully to the (possibly updated) state of the original target
        first, pulling later.

    prepare
        Run rpmbuild. Execute just the %prep section of the .spec file.

    apply [-R]
        Apply all patches defined in the .spec file to the source tree.
        -R    reverse apply patches (patch -R)

    build [-p|--doprep] [-d|--enable-debug] [-j <n>] [<project-dir-or-file>]
          [[--] <rpmbuild-extra-args>]
        Run rpmbuild. Execute all sections of the .spec file except for %prep
        unless told otherwise. If path to a <project-dir-or-file> is passed,
        shadow build will be done. Otherwise the current working directory is
        treated as the project directory. (The file name part is ignored -
        project file selection is done by qmake call inside the .spec file.)
        -p    run %prep phase as well
        -d    enable debug build
        -j <n> run up to <n> jobs simultaneously

    qmake [<project-dir-or-file>] [[--] <qmake-extra-args>]
        Run rpmbuild. Execute just the %build section of the .spec file,
        suppressing any "make" invocation figuring in that section. If path to
        a <project-dir-or-file> is passed, shadow build will be done. Otherwise
        the current working directory is treated as the project directory. (The
        file name part is ignored - project file selection is done by qmake call
        inside the .spec file.)

    cmake <project-dir> [[--] <cmake-extra-args>]
    cmake --build . [<cmake-extra-args>] [-- <make-extra-args>]
        Run rpmbuild. Execute just the %build section of the .spec file,
        suppressing any "cmake" invocation figuring in that section, that does
        not match the execution form used here, i.e., does not trigger the
        desired action, namely 1) generate a project buildsystem or
        2) build the project.

        Additionally, any plain "make" invocation will be recognized as
        implementing the "build the project" action and will be treated
        accordingly. Any possible <cmake-extra-args> will be silently ignored
        in that case.

    make [<make-extra-args>]
        Run rpmbuild. Execute just the %build section of the .spec file,
        suppressing any command figuring in that section, that is recognized
        as a command to generate project buildsystem.

        In case of CMake based project this is equivalent to the "mb2 cmake
        --build . -- <make-extra-args>" command.

    make-install
        Run rpmbuild. Execute just the %install section of the .spec file.

    package
        Run rpmbuild. Execute just the %install section of the .spec file, then
        build binary packages.

    check --list-suites
    check [-l|--levels [+|-]<level>...] [-s|--suites [+|-]<suite>...] [<artefact>]...
        Perform quality checks.

        By default, test suites operate on the artefacts associated with build
        tree under CWD. Alternatively, single path to a source tree and/or one
        or more package files may be specified as <artefact> on command line
        (build tree is always looked for under CWD).

        Each test suite realizes testing on one or more of the four recognized
        test levels. This is indicated in the output produced with the
        '--list-suites' option, using the keywords found in the first column
        of the following table.

        | Level          | Tested art. | Executed at   | Default |
        |----------------+-------------+---------------+---------|
        |    static      |             |               |         |
        | 1. ├── source  | Sources     | Build host    | +       |
        | 2. └── package | Packages    | Build host    | +       |
        |    dynamic     |             |               |         |
        | 3. ├── unit    | Build tree  | Build host    | -       |
        | 4. └── system  | Packages    | Target device | -       |

        (See also QUALITY ASSURANCE above.)

        -l, --levels [+|-]<level>...
            Select testing levels. Levels are selected using the keywords
            'source', 'package', 'static', 'unit', 'system' and 'dynamic' as
            described before.

        --list-suites
            List available test suites.

        -s, --suites [+|-]<suite>...
            Select test suites to use. By default all and only the essential
            suites are selected. See '--list-suites'.

        The '--levels' and '--suites' options may be passed multiple values,
        separated with comma. If a name is prefixed with '+' or '-', the
        effect is cumulative and persists until overriden with later name
        prefixed with the opposite operator.

    deploy {--pkcon|--rsync|--sdk|--zypper|--manual} [--all] [--debug]
           [--] [[+|-]<pattern>...]
        Deploy build results to a device.

        By default, just the build results of the project under current working
        directory will be deployed. When a shared output directory is used (see
        '--output-dir' and '--output-prefix'), the option '--all' can be used to
        require deployment of all packages found under the output directory, no
        matter of their origin. The '--all' option is not available when the
        '--rsync' method is used.

        Selection of (sub)packages for deployment can be influenced with glob
        <pattern>s, each of which may be preceded with '+' or '-' to opt for
        either inclusion (default) or exclusion respectively as the desired
        effect. Later specified patterns may override earlier ones.  Extended,
        Bash-compatible patterns are allowed.  The '-*-debug@(info|source)'
        pattern is implied unless the '--debug' option is used.  Options must
        precede patterns if any.

        The following deployment methods are available, corresponding to the
        mandatory option:

        --pkcon
            Uses 'pkcon' to install RPM package(s). Requires the "Allow
            untrusted software" option enabled in Settings, does not require
            root access to the device.

        --rsync
            This method is special.  Uses 'rsync' to copy the installed files
            under '/opt/sdk/<name>' without building/installing RPM package(s).
            Does not require root access to the device.  Incompatible with
            '--all'.

        --sdk
            Uses the method native to the SDK to install RPM package(s).
            Requires developer mode enabled on the device, does not require
            root access.

        --zypper
            Uses 'zypper' to install RPM package(s).  Requires 'zypper'
            installed on the device, requires root access to the device.

        --manual
            Only transfers the RPM package(s) to the device for manual
            installation. Uses '~/RPMS' as the target directory on the device.

        When used via Qt Creator, this command implies also the "make-install"
        and "package" commands unless the '--all' option or '--rsync' method is
        used.

    undeploy {--pkcon|--rpm|--rsync|--zypper} [--all] [-n|--dry-run]
             [--] [[+|-]<pattern>...]
        Undeploy build results previously deployed to a device.

        Initially, device packages are collected based on the build host name
        recorded in their metadata.  Just those packages that seem to
        originate from the host where mb2 is running will be considered for
        removal from the device.  For that it is vital that the host name is
        stable and unique among the host names recorded by packages installed
        from other sources.

        Further, unless the '--all' option is used, just the build results of
        the project under current working directory will be considered for
        removal from the device.  When the '--all' option is used, any build
        results originated from this build host will be considered.  (Note how
        the effect of '--all' differs between 'deploy' and 'undeploy'.)

        Package origin is determined based on the build host name recorded in
        its metadata.  For that it is vital that 1) the build host name has
        not changed since the time the packages were built and that 2) the
        build host name is unique among the host names recorded by packages
        installed from other sources.  See the 'engine' command to learn more
        about the build host name.

        With the '--dry-run' option, the list of (sub)packages that would be
        removed may be previewed without applying the changes.

        If needed, the selection can be furthermore adjusted with glob
        <pattern>s, each of which may be preceded with '+' or '-' to opt for
        either inclusion (default) or exclusion respectively as the desired
        effect.  Later specified patterns may override earlier ones.
        Extended, Bash-compatible patterns are allowed.  Options must precede
        patterns if any.

        Except for the '--rsync' method, the selected method is not required to
        match the method previously used with the 'deploy' command.

        The following methods of undeployment are available, corresponding to
        the mandatory option:

        --pkcon
            Uses 'pkcon' to remove RPM package(s).  Requires the "Allow
            untrusted software" option enabled in Settings, does not require
            root access to the device.

        --rpm
            Uses plain 'rpm' to remove RPM package(s).  Requires root access
            to the device.

        --rsync
            This method is special.  It does not work with RPM packages.  It
            is only capable to remove files previously copied under
            '/opt/sdk/' with 'deploy --rsync'.  With this method, the origin
            of the data is not taken into consideration.  Does not require
            root access to the device.

        --zypper
            Uses 'zypper' to remove RPM package(s).  Requires 'zypper'
            installed on the device, requires root access to the device.

    run [<command> [<args>]]
        Run the given command on the device specified with '--device'.  Can be
        used for running gdb and a gdb server.

GLOBAL OPTIONS
    The order of passing options matters. Options that occur later on the
    command line may override earlier options, including those implied by
    the earlier options.

    -i, --increment
        Increment release number in .spec file

    -t, --target <name>
        Specify the sb2 target to use

    -d, --device <name>
        Specify the device

    -o, --output-dir <dir>
        Defaults to './RPMS'. The resulting RPM packages will be placed
        directly under the specified <dir>. With this option existing files in
        the output directory are preserved.  Implies '--search-output-dir'

    -O, --output-prefix <dir>
        Much like '--output-dir' except that a subdirectory of the given <dir>
        will be used, denoted by the build target name (see '--target') and
        optionally prefixed with task name (see '--task') separated with
        single dash ('-') character ('<dir>/[<task>-]<target>').

    --search-output-dir[={verbose|quiet}]
        Consider the RPM packages found in the output directory when installing
        build time dependencies. The optional value controls zypper verbosity.
        The default is 'verbose'.

    --no-search-output-dir
        Override '--search-output-dir' option

    -s, --specfile <file>
        Specify the .spec file

    -S, --snapshot[=<suffix>]
        Avoid installing build-time dependencies to the sb2 target - use a
        snapshot of that target instead.

        The snapshot name will be determined by combining the original target
        name with the given <suffix>. Any occurence of '%{task}' within the
        <suffix> will be substituted with the name specified with the '--task'
        option or with an empty string if the '--task' option is not used.
        When no suffix was specified or when the substitution yields an empty
        string, a temporary snapshot will be used (these have ".mb2." followed
        by random character sequence in their names).

        Snapshot state is preserved across mb2 invocations unless the original
        target was updated meanwhile or it is a temporary snapshot that was
        previously used with different build tree, in which cases the snapshot
        will be reset. Snapshot can be reset forcefully using the
        'build-requires reset' command.

    --no-snapshot
        Force mb2 to directly use a target for which snapshots exist.

    -f, --shared-folder <dir>
        The folder where QtCreator shares devices.xml and ssh keys. This option
        is useful when the deploy command is used outside of virtual machine.

    -T, --task[=<name>|=git:<regex>]
        Modifies behavior of '--output-prefix' and '--snapshot' options.
        The task name can be specified either directly as <name> or it can be
        derived from the current Git branch name, using the POSIX extended
        regular expression <regex> both as a condition to enable this option
        and as a mean to select substring of the branch name to be used as
        the task name.  Defaults to '$DEF_TASK'.
        The default expression is suitable to look for a leading bug reference
        in the branch name.  E.g. 'bug1234' in 'bug1234-quickfix'.

    --no-task
        Override --task option

    --wrap <command>:<wrapper>
        Instruct rpmbuild to use the given <wrapper> as a replacement for the
        <command>. <command> must be a valid file name, without directory part
        while <wrapper> must be specified as an absolute file path.

    -x, --fix-version[=<tag>]
        This option is implied when used inside a Git working tree (use -X to
        override). When used via Qt Creator, it is only implied if the version
        recorded in the .spec file is exactly "0".

        With this option the version recorded in the .spec file will be
        ignored.  Instead, package version will be derived from the name of the
        latest tag in the current git branch or the selected tag <tag>.

        If the current HEAD, index or working tree differs from the tree
        denoted by the (latest or selected) tag, a suffix composed from the
        current branch name, time stamp and a commit SHA1 will be added to the
        package version. If git-state is not clean a git-stash will be created
        and its SHA1 will be used.

        It is recommended to store 'Version: 0' and 'Release: 1' in the .spec
        file when this option is to be used; as a sign that the version
        recorded there is not relevant.

    -X, --no-fix-version
        Override --fix-version option.

    -n, --no-deps
        Do not update target dependencies

    -c, --git-change-log[=<args>]
        Include change log generated from Git history with 'git-change-log'
        command, forwarding any <args>.  This option is not intended for
        regular use - create a script file named after the .spec file but with
        '.changes.run' extension to instruct $ME to generate changelog with
        'git-change-log <args>' instead.


KNOWN ISSUES

Build target snapshot is not reset automatically when the original target is
changed just by removing packages via plain RPM usage. Either use zypper for
all package operations or use 'mb2 build-requires reset' to ensure snapshot is
reset.
EOF
}

notice() {
    echo "NOTICE: $*" >&2
}

fatal() {
    echo "Fatal: $*" >&2
    exit 1
}

# readarray is a bash >= 4.0 feature
if ! type readarray &>/dev/null; then
    readarray() {
        if ! [[ $# -eq 2 && $1 == -t && $(declare -p "$2" 2>/dev/null) == "declare -a "* ]]; then
            fatal "Internal error: readarray: unimplemented case"
        fi

        local line=
        eval $2=\(\)
        while IFS= read -r line; do
            eval $2=\(\${$2[@]:+\"\${$2[@]}\"} \"\$line\"\)
        done
    }
fi

set_insert() {
    eval local set=(\${$1[*]})
    local item=$2

    set=$(IFS=$'\n'; sort -u <<<"${set[*]}$IFS$item")

    eval $1=\(\$set\)
}

set_remove() {
    eval local set=(\${$1[*]})
    local item=$2

    set=$(IFS=$'\n'; grep --line-regexp -v -F "$item" <<<"${set[*]}")

    eval $1=\(\$set\)
}

set_intersect() {
    eval local set1=(\${$2[*]})
    eval local set2=(\${$3[*]})
    local out=()

    set1=$(IFS=$'\n'; sort <<<"${set1[*]}")
    set2=$(IFS=$'\n'; sort <<<"${set2[*]}")

    out=$(join <(cat <<<"$set1") <(cat <<<"$set2"))

    eval $1=\(\$out\)
}

# Usage: set_update <set> [+-]<item>...
#
# Update the set with the given items. If no item is prefixed with '+' or '-' it
# will simply replace the content of the set. The effect of '+' and '-' persists
# until overriden with later item prefixed with the opposite operator.
set_update() {
    eval local set=(\${$1[*]})
    local items=("${@:2}")

    local op= item=
    for item in "${items[@]}"; do
        if [[ $item == [+-]* ]]; then
            op=${item:0:1}
            item=${item:1}
        fi
        case $op in
            # TODO with Bash 4 reimplement set_insert and set_remove so that they can be used here
            +) set=($(IFS=$'\n'; sort -u <<<"${set[*]}$IFS$item"));;
            -) set=($(IFS=$'\n'; grep --line-regexp -v -F "$item" <<<"${set[*]}"));;
            '')
                set=($item)
                op=+
                ;;
        esac
    done

    eval $1=\(\${set[*]}\)
}

set_contains() {
    eval local set=(\${$1[*]})
    local item=$2

    [[ " ${set[*]} " == *" $item "* ]]
}

git_() (
    # Cannot use the '-C' option - it requires newer Git.
    # Cannot use '--git-dir' + '--work-tree' options - they break at least git-stash.
    if [[ $OPT_SRC_DIR ]]; then
        cd "$OPT_SRC_DIR" || return
    fi
    # At least git-stash requires an explicitly set user identity. Setting environment
    # variables compared to passing options with '-c' works also for subprocesses invoked via
    # `git-submodule foreach`
    if inside_build_engine; then
        export GIT_AUTHOR_NAME='mersdk' GIT_AUTHOR_EMAIL='mersdk@mersdk'
        export GIT_COMMITTER_NAME='mersdk' GIT_COMMITTER_EMAIL='mersdk@mersdk'
    fi

    git "$@"
)

get_hostname_from_devices_xml() {
    local TAG_NAME= ATTRIBUTES=
    while read_dom; do
        if [[ $TAG_NAME == host ]]; then
            eval "local $ATTRIBUTES"
            printf '%s\n' "$name"
            break
        fi
    done < $(get_shared_dir)/devices.xml
}

get_hostname() {
    local hostname=
    if inside_build_engine; then
        hostname=$(get_hostname_from_devices_xml)
    else
        hostname=$({ hostname --fqdn; hostname; } \
            |sed '/^localhost\(\.localdomain\)\?$/d; q')
    fi

    printf '%s\n' "${hostname:-localhost.localdomain}"
}

try_to_make_spec() { # Tries to create a missing spec
    [[ -f "$1" ]] && return # It's not missing
    local yaml="${1%.spec}.yaml"
    [[ -f "$yaml" ]] || return # No yaml
    ANSI_COLORS_DISABLED=1 specify -n -N "$yaml" || fatal "Failed to convert .yaml to .spec"
}

try_to_make_spec_from_yaml() {
    # Tries to create a missing spec from a given yaml
    try_to_make_spec "${1%.yaml}.spec"
}

sanitize_changelog() {
    sed 's/%/%%/g'
}

try_to_make_changelog() {
    local changes_file=${OPT_SPEC%.spec}.changes
    local changes_run_file=${OPT_SPEC%.spec}.changes.run

    if [[ $OPT_GIT_CHANGE_LOG ]]; then
        notice "Auto generating changelog from Git history…"
        echo "%changelog"
        git-change-log $OPT_GIT_CHANGE_LOG_ARGS |sanitize_changelog
    elif [[ -f $changes_file ]]; then
        notice "Appending changelog entries to the .spec file…"
        echo "%changelog"
        cat $changes_file |sanitize_changelog
    elif [[ -f $changes_run_file ]]; then
        notice "Generating changelog entries with '$changes_run_file'…"
        local runner=
        # In build VM the shared filesystem is noexec
        if ! [[ -x $changes_run_file ]]; then
            if [[ $(head -c 3 <$changes_run_file |cat -v) == '#!/' ]]; then
                runner=$(sed -n '1s/^#!//p' $changes_run_file)
            else
                fatal "File is not executable: '$changes_run_file'"
            fi
        fi
        echo "%changelog"
        $runner $changes_run_file |sanitize_changelog
        [[ ${PIPESTATUS[0]} -eq 0 ]] || fatal "Failed to generate changelog entries"
    fi
}

ensure_spec_newer_than_yaml() {
    local yaml="${OPT_SPEC%.spec}.yaml"
    if [[ -f "$yaml" ]] && [[ "$yaml" -nt "$OPT_SPEC" ]]; then # -nt is newer than
        ANSI_COLORS_DISABLED=1 specify -n -N "$yaml" || fatal "Failed to convert .yaml to .spec"
    fi

    # it's ok also not to have a yaml
}

match_multi() {
    local name=$1 patterns=("${@:2}")

    if [[ ${#patterns[*]} -eq 0 ]]; then
        return 0
    fi

    local inclusion_limited= included= excluded= pattern=
    for pattern in "${patterns[@]}"; do
        local exclude=
        if [[ $pattern == +* ]]; then
            pattern=${pattern:1}
        elif [[ $pattern == -* ]]; then
            pattern=${pattern:1}
            exclude=1
        fi

        if [[ ! $pattern ]]; then
            notice "Got invalid, empty pattern"
            return 1
        fi

        if [[ $exclude ]]; then
            if [[ $name == $pattern ]]; then
                included=
                excluded=1
            fi
        else
            inclusion_limited=1
            if [[ $name == $pattern ]]; then
                included=1
                excluded=
            fi
        fi
    done

    [[ (! $inclusion_limited || $included) && ! $excluded ]]
}

find_latest_rpms() {
    local dir=$1 patterns=("${@:2}")

    local latest=$(
        sb2 -t "$OPT_TARGET" -m sdk-install \
            zypper --plus-repo "$dir/" search --repo ~plus-repo-1 --details \
            `# drop header` \
            |sed '1,/^--/d' \
            `# zypper sorts by version: revert it and keep first for each name` \
            |tac |sort --stable -t '|' -k 2,2 -u \
            `# $name $dir/$name-$evr.$arch.rpm` \
            |awk -F ' *\\| *' -v dir="$dir" '{print $2, dir "/" $2 "-" $4 "." $5 ".rpm"}'
    )

    [[ $latest ]] || return

    local name= pkg=
    while read name pkg; do
        if [[ ! -f "$pkg" ]]; then
            fatal "Internal error: Package does not exist: '$pkg'"
        fi
        if match_multi "$name" "${patterns[@]}"; then
            printf '%s\n' "$pkg"
        fi
    done <<<"$latest"
}

# Find binary rpms under <dir> built from the given <spec>, filtering according
# to <patterns>. If '--all' is used (must be the very first option), ignore
# <spec> and find latest packages no matter of their origin.
find_rpms()
{
    local all=
    if [[ $1 == --all ]]; then
        all=1
        shift
    fi

    local dir=$1 spec=$2 patterns=("${@:3}")

    if [[ $all ]]; then
        find_latest_rpms "$dir" "${patterns[@]}"
        return
    fi

    local wanted_source_name= wanted_evr=
    read wanted_source_name wanted_evr < <(rpmspec -q --srpm --queryformat '%{NAME} %{EVR}\n' "$spec")

    local pkg=
    while read -r pkg; do
        local name= source_rpm= evr=
        read name source_rpm evr < <(rpm -q --queryformat '%{NAME} %{SOURCERPM} %{EVR}\n' -p "$pkg")
        local source_name=${source_rpm%-$evr.src.rpm}
        if [[ $source_name == $wanted_source_name && $evr == $wanted_evr ]] \
                && match_multi "$name" "${patterns[@]}"; then
            printf '%s\n' "$pkg"
        fi
    done < <(find "$dir" -maxdepth 1 -name '*.rpm')
}

# Copy a repo excluding packages built from the given exclude_source_name package
filter_repo()
{
    local exclude_source_name=$1 repo=$2 output=$3

    rm -rf "$output"
    mkdir -p "$output"

    local pkg=
    while read -r pkg; do
        local source_rpm= evr=
        read source_rpm evr < <(rpm -q --queryformat '%{SOURCERPM} %{EVR}\n' -p "$pkg")
        local source_name=${source_rpm%-$evr.src.rpm}
        [[ $source_name != $exclude_source_name ]] || continue
        ln -s --target-directory="$output" "$pkg"
    done < <(find "$repo" -maxdepth 1 -name '*.rpm')

    createrepo_c "$output"
}

verify_target_dependencies() {
    [[ $OPT_NO_DEPS ]] && return

    local deps=()
    readarray -t deps < <(sb2 -t "$OPT_TARGET" rpmspec --query --buildrequires "$OPT_SPEC" |sed 's/\s*$//')
    if [[ $deps ]]; then
        if inside_build_engine; then
            local oldpkgs=$(sb2 -t "$OPT_TARGET" -m sdk-install rpm -qa)
        fi
        if [[ $OPT_SEARCH_OUTPUTDIR ]]; then
            local filtered_outputdir=$STATEDIR/filtered-output-dir
            local exclude_source_name=$(get_spec_tag "%{name}")
            filter_repo "$exclude_source_name" "$OPT_OUTPUTDIR" "$filtered_outputdir"
            local args=(--"$OPT_SEARCH_OUTPUTDIR_VERBOSITY" --non-interactive \
                --plus-repo "$filtered_outputdir" --no-gpg-checks)
            sb2 -t "$OPT_TARGET" -m sdk-install -R zypper "${args[@]}" dup --from '~plus-repo-1'
            sb2 -t "$OPT_TARGET" -m sdk-install -R zypper "${args[@]}" in "${deps[@]}"
        else
            sb2 -t "$OPT_TARGET" -m sdk-install -R zypper --quiet --non-interactive in "${deps[@]}"
        fi
        if inside_build_engine; then
            local newpkgs=$(sb2 -t "$OPT_TARGET" -m sdk-install rpm -qa)
            if [[ $newpkgs != $oldpkgs ]]; then
                sdk-manage target sync "$OPT_TARGET"
            fi
        fi
    fi
}

get_spec_tag() {
    rpmspec --query --srpm --queryformat="$1" "$OPT_SPEC"
}

fix_package_version() {
    local spec_file=$1

    local version_in_spec=$(sed -n 's/^Version:[[:space:]]*//p' "$spec_file")

    if [[ $OPT_NO_FIX_VERSION ]]; then
        return
    elif [[ ! $OPT_FIX_VERSION ]]; then
        # When used behind Qt Creator, fixing version is enabled implicitly only if the
        # version in spec file is exactly "0" - this is because there is no UI in Qt Creator
        # that would allow to override this.
        if behind_qtcreator && [[ $version_in_spec != 0 ]]; then
            return
        fi
    fi

    if ! inside_git_worktree; then
        if [[ $OPT_FIX_VERSION || $version_in_spec == 0 ]]; then
            notice "Not inside a Git working tree, will not fix package version."
        fi
        return
    fi

    local tag
    if [[ $OPT_FIX_VERSION_HINT ]]; then
        tag=$OPT_FIX_VERSION_HINT
    else
        if ! tag=$(git_ describe --tags --abbrev=0 2>/dev/null); then
            notice "No tags describe the HEAD, will not fix package version."
            return
        fi
    fi

    local version=$tag
    version=${version#*/}   # allow tags to have a prefix to allow vendor marking
    version=${version#v}    # some people like to prefix versions with a v

    local stash=
    if ! stash=$(git_ stash create); then
        fatal "Cannot save state of Git working tree: git-stash failed."
    fi
    local head=${stash:-$(git_ rev-parse HEAD)}

    local modified_submodules=
    modified_submodules=$(
        describe_if_modified()
        {
            local stash=
            stash=$(git stash create) || return
            local head=${stash:-$(git rev-parse HEAD)}
            if [[ $head != $sha1 ]]; then
                local short=$(git rev-list --max-count=1 --abbrev-commit "$head")
                local time=$(git log --max-count=1 --pretty=%ct "$head")
                printf '%s %s %s\n' "$name" "$short" "$time"
            fi
        }
        git_ submodule --quiet foreach --recursive \
            "$(declare -f describe_if_modified); describe_if_modified")
    if [[ $? -ne 0 ]]; then
        fatal "Cannot save state of Git submodules: git-stash failed for some."
    fi

    if [[ $(git_ rev-parse "$tag^{}") != "$head" || $modified_submodules ]]; then
        local branch=$(git_ rev-parse --abbrev-ref HEAD)

        local time=$(git_ log --max-count=1 --pretty=%ct "$head")
        local submodule_info=
        if [[ $modified_submodules ]]; then
            local subname= subsha1= subtime=
            while read subname subsha1 subtime; do
                submodule_info+=+$subname.$subsha1
                if (( subtime > time )); then
                    time=$subtime
                fi
            done <<<"$modified_submodules"
        fi

        local timestamp=$(TZ=UTC date --date=@"$time" +%Y%m%d%H%M%S)
        local sha1sum=$(git_ rev-list --max-count=1 --abbrev-commit "$head")
        version=$version+$branch.$timestamp.$sha1sum$submodule_info
    fi

    version=${version//[^+_[:alnum:]]/.} # replace characters not allowed in the version field

    echo "Setting version: ${version}"
    sed -i "s,^Version:.*,Version: ${version}," "$spec_file"
}

maybe_set_task_name_from_git_branch_name() {
    if [[ $OPT_TASK != git:* ]]; then
        return
    elif ! inside_git_worktree; then
        OPT_TASK=
        return
    fi

    local regex=${OPT_TASK#git:}
    local branch=$(git_ rev-parse --abbrev-ref HEAD)

    if [[ $branch =~ $regex ]]; then
        OPT_TASK=${BASH_REMATCH[0]}
        notice "Task name determined as '$OPT_TASK' (from the current Git branch)"
    else
        OPT_TASK=
    fi
}

# Helper to read XML
read_dom () {
    local IFS=\>
    read -d \< ENTITY CONTENT
    local RET=$?
    TAG_NAME=${ENTITY%% *}
    ATTRIBUTES=${ENTITY#* }
    ATTRIBUTES=${ATTRIBUTES%/}
    return $RET
}

# This slurps the XML and converts tags like <subnet> to $device_subnet
# Also sets device_name and device_type from the attributes
get_device() {
    local FOUND_DEVICE=
    local IN_DEVICE=
    local maintag=
    while read_dom; do
        case $TAG_NAME in
            device )
                maintag=$TAG_NAME
                eval local $ATTRIBUTES
                if [[ "$name" == "$1" ]] ; then
                    FOUND_DEVICE=1
                    IN_DEVICE=1
                    device_name="$name"
                    device_type="$type"
                else
                    IN_DEVICE=
                fi
                ;;
            engine )
                maintag=$TAG_NAME
                eval local $ATTRIBUTES
                ;;
            mac|index|subnet|ip|sshkeypath|sshport )
                # Don't process and store nested tags if we're in
                # device with wrong name
                if [[ "$maintag" == "device" ]] && [[ $IN_DEVICE != 1 ]]; then
                    continue
                fi
                eval ${maintag}_$TAG_NAME=\"$CONTENT\"
                ;;
        esac
    done
    # Set this up as it's useful
    if [[ "$device_subnet" ]]; then
        device_ip="$device_subnet".$device_index
    fi
    if [[ ! "$device_sshport" ]]; then
        device_sshport=22
    fi
    if [[ "$FOUND_DEVICE" == 1 ]]; then return 0; else return 1; fi
}

rsync_as() {
    local user="$1";shift
    local key=$(get_shared_dir)/${device_sshkeypath}/$user
    [[ -f "$key" ]] || fatal "SSH key not configured for user '$user' on '$device_name'"
    RSYNC_RSH="ssh -F /etc/ssh/ssh_config.sdk -l $user -i \"$key\" -p $device_sshport" rsync "$@"
}

ssh_as() {
    local user="$1";shift
    local key=$(get_shared_dir)/${device_sshkeypath}/$user
    [[ -f "$key" ]] || fatal "SSH key not configured for user '$user' on '$device_name'"
    ssh -F /etc/ssh/ssh_config.sdk -i "$key" -l $user $device_ip -p $device_sshport "$(quote "$@")"
}

cd_to_spec_setup_dir() {
    # avoid spawning another process for | cut -s -f2 -d '/'
    local setup_dir=$(grep -Po '%(auto)?setup.*-n[[:space:]]+[^[:space:]]+' "$OPT_SPEC")
    # if setup_dir has '/' return the part after it
    setup_dir=${setup_dir/#*\//}
    # if it did not have a '/' then we got the original match => erase it
    setup_dir=${setup_dir/#%?(auto)setup*/}

    if [[ -n "$setup_dir" ]]; then
        # in case we got a spec %{tag} out of this, try to expand it
        setup_dir=$(get_spec_tag "$setup_dir")
        is_shadow_build && mkdir -p "$setup_dir"
        cd "$setup_dir"
    fi
}

# handle release tags with format "x" or "x.y", where x and y are
# numbers, leave others untouched
#  get tag
#  check if it has x.y
#  if it is x.y get y and check if y is number
#  if y is number => increment
#  if it only is x check if x is number
#  if x is number => increment
#  else leave untouched
increment_build_number() {
    [[ $OPT_INC_BUILD_NUMBER -eq 0 ]] && return

    local release=$(get_spec_tag "%{release}")
    local x=$(echo $release | cut -f 1 -d .)
    local y=$(echo $release | cut -s -f 2 -d .)
    local z=$(echo $release | cut -s -f 3- -d .)

    # more than one dot found => don't touch
    [[ -n "$z" ]] && return

    if [[ -n "$y" ]]; then
        if [[ $y =~ ^-?[0-9]+$ ]]; then
            let new_release=$y+1
            echo "Incrementing release: $x.$y -> $x.$new_release"
            sed -i "s/^Release:.*/Release: $x.$new_release/" "$OPT_SPEC"
            return
        else
            # non-numeric after dot => don't touch
            return
        fi
    fi

    if [[ -n "$x" ]]; then
        if [[ $x =~ ^-?[0-9]+$ ]]; then
            let new_release=$x+1
            echo "Incrementing release: $x -> $new_release"
            sed -i "s/^Release:.*/Release: $new_release/" "$OPT_SPEC"
            return
        fi
    fi
}

quote() {
    [[ $# -gt 0 ]] && printf "%q " "$@" |sed 's/ $//'
}

rpm_quote() {
    quote "$@" |sed 's/\\/&&/g'
}

init_wrappers_dir() {
    [[ -e $WRAPPERSDIR ]] || mkdir -p "$WRAPPERSDIR"
    [[ -e $USERWRAPPERSDIR ]] || mkdir -p "$USERWRAPPERSDIR"
    local user_wrapper= command= wrapper=
    for user_wrapper in "${OPT_WRAP[@]}"; do
        command=${user_wrapper%%:*}
        wrapper=${user_wrapper#*:}
        ln -s "$wrapper" "$USERWRAPPERSDIR/$command"
    done
}

remove_wrappers_dir() {
    # Better be paranoid than sorry. And quieten the unnecessary verbose 'rmdir --parents'
    rm -f "$WRAPPERSDIR"/* && rmdir --parents "$WRAPPERSDIR" &>/dev/null
    rm -f "$USERWRAPPERSDIR"/* && rmdir --parents "$USERWRAPPERSDIR" &>/dev/null
}

# 1. Allows to pass extra arguments to qmake
# 2. Enables shadow build by adding path prefix to the project file, or
# 2.1 passing project directory path if the project file was not passed
# 3. Populates variable cache used by Qt Creator to augment its project model
init_qmake_wrapper() (
    local wrapper=$1
    local extra_args=("${@:2}")

    main() {
        self=${0#$PWD/}
        command=${0##*/}

        path=${0%/*}
        PATH=${PATH/$path:/}

        real=$(which "$command")
        if [[ ! $real || $real == "$0" ]]; then
            echo "$self: Cannot find real $command" >&2
            exit 1
        fi

        if [[ $IS_SHADOW_BUILD ]]; then
            subdir=${PWD#$BUILD_DIR}
            src_dir=$SRC_DIR${subdir:+/$subdir}
            args=()
            pro_passed=
            for arg in "$@"; do
                if [[ $arg == *.pro && -f $src_dir/$arg ]]; then
                    args+=("$src_dir/$arg")
                    pro_passed=1
                else
                    args+=("$arg")
                fi
            done
            if [[ ! $pro_passed ]]; then
                args+=("$src_dir")
            fi
            set -- "${args[@]}"
        fi

        assignments=()
        for arg in "$@"; do
            if [[ $arg =~ ^[a-zA-Z_][a-zA-Z0-9_]*= ]]; then
                assignments+=("$arg")
            fi
        done
        printf '%s\0' "${assignments[@]}" > "$VARIABLES_CACHE"

        echo "$self: Executing real $command:" >&2

        set -x
        "$real" "$@" "${EXTRA_ARGS[@]}"
    }

    init_wrappers_dir
    cat <<END >"$wrapper"
#!/bin/bash

IS_SHADOW_BUILD=$(is_shadow_build && echo 1)
BUILD_DIR=$(quote "$PWD")
SRC_DIR=$(quote "${OPT_SRC_DIR:-$PWD}")
VARIABLES_CACHE=$STATEDIR/qmake_variables.cache
EXTRA_ARGS=($(quote "${extra_args[@]}"))

$(declare -f main)

main "\$@"
END
    chmod +x "$wrapper"
)

# 1. Allows to pass extra arguments to cmake
# 2. Enables shadow build by adding path prefix to the project-dir argument
# 3. Allows to suppress cmake not invoked in the desired mode
init_cmake_wrapper() (
    local wrapper=$1

    do_configure() {
        if [[ $IS_SHADOW_BUILD ]]; then
            subdir=${PWD#$BUILD_DIR}
            src_dir=$SRC_DIR${subdir:+/$subdir}
            args=()
            pro_passed=
            for arg in "$@"; do
                if [[ -f $src_dir/$arg/CMakeLists.txt ]]; then
                    args+=("$src_dir/$arg")
                    pro_passed=1
                else
                    args+=("$arg")
                fi
            done
            if [[ ! $pro_passed ]]; then
                echo "$self: Failed to adjust project directory path"
                exit 1
            fi
            set -- "${args[@]}"
        fi

        # NBSP used to prevent Qt Creator treating this as an error when issued for 'cmake'
        echo "$self:${NBSP}Executing real $command:" >&2

        set -x
        "$real" "$@" "${EXTRA_CONFIGURE_ARGS[@]}"
    }

    do_build() {
        local args=() build_tool_args=()
        while [[ $# -gt 0 ]]; do
            case $1 in
                --build)
                    if [[ $2 != . ]]; then
                        echo "$self: The argument to '--build' passed in .spec must be '.' (literally)" >&2
                        exit 1
                    fi
                    args+=("$1" "$2")
                    shift
                    ;;
                --target)
                    if [[ $2 != "$MAKE_TARGET" ]]; then
                        echo "$self: Argument to '--target' passed on command line does not march the argument passed in .spec" >&2
                        exit 1
                    fi
                    args+=("$1" "$2")
                    shift
                    ;;
                --)
                    shift
                    build_tool_args=("$@")
                    shift $#
                    break
                    ;;
                *)
                    args+=("$1")
                    ;;
            esac
            shift
        done

        # NBSP used to prevent Qt Creator treating this as an error when issued for 'cmake'
        echo "$self:${NBSP}Executing real $command:" >&2

        set -x
        "$real" "${args[@]}" "${EXTRA_BUILD_ARGS[@]}" -- "${build_tool_args[@]}" "${EXTRA_BUILD_TOOL_ARGS[@]}"
    }

    main() {
        self=${0#$PWD/}
        command=${0##*/}
        NBSP=$'\xC2\xA0'

        path=${0%/*}
        PATH=${PATH/$path:/}

        real=$(which "$command")
        if [[ ! $real || $real == "$0" ]]; then
            echo "$self: Cannot find real $command" >&2
            exit 1
        fi

        if [[ $1 != --build ]]; then
            if [[ ! $ALLOWED_MODE || $ALLOWED_MODE == configure ]]; then
                do_configure "$@"
            else
                # NBSP used to prevent Qt Creator treating this as an error when issued for 'cmake'
                echo "$self:${NBSP}Ignoring $command invoked in a way to create a project buildsystem" >&2
            fi
        else
            if [[ ! $ALLOWED_MODE || $ALLOWED_MODE == build ]]; then
                do_build "$@"
            else
                # NBSP used to prevent Qt Creator treating this as an error when issued for 'cmake'
                echo "$self:${NBSP}Ignoring $command invoked in a way to build the project" >&2
            fi
        fi
    }

    init_wrappers_dir
    cat <<END >"$wrapper"
#!/bin/bash

IS_SHADOW_BUILD=$(is_shadow_build && echo 1)
BUILD_DIR=$(quote "$PWD")
SRC_DIR=$(quote "${OPT_SRC_DIR:-$PWD}")
ALLOWED_MODE=$(quote "$CMAKE_MODE")
EXTRA_CONFIGURE_ARGS=($(quote "${CMAKE_EXTRA_CONFIGURE_ARGS[@]}"))
EXTRA_BUILD_ARGS=($(quote "${CMAKE_EXTRA_BUILD_ARGS[@]}"))
EXTRA_BUILD_TOOL_ARGS=($(quote "${CMAKE_EXTRA_BUILD_TOOL_ARGS[@]}"))
BUILD_TARGET=$(quote "$CMAKE_BUILD_TARGET")

$(declare -f main)

main "\$@"
END
    chmod +x "$wrapper"
)

init_simple_wrapper() {
    local wrapper=$1
    local extra_args=("${@:2}")

    init_wrappers_dir
    {
        cat <<'END'
#!/bin/bash
self=${0#$PWD/}
command=${0##*/}
NBSP=$'\xC2\xA0'

path=${0%/*}
PATH=${PATH/$path:/}

real=$(which "$command")
if [[ ! $real || $real == "$0" ]]; then
    echo "$self: Cannot find real $command" >&2
    exit 1
fi

# NBSP used to prevent Qt Creator treating this as an error when issued for 'make'
echo "$self:${NBSP}Executing real $command:" >&2

set -x

"$real" "$@" \
END
        quote "${extra_args[@]}"
        echo
    } >"$wrapper"
    chmod +x "$wrapper"
}

init_noop_wrapper() {
    local wrapper=$1

    init_wrappers_dir
    cat <<'END' >"$wrapper"
#!/bin/bash
self=${0#$PWD/}
command=${0##*/}
NBSP=$'\xC2\xA0'
# NBSP used to prevent Qt Creator treating this as an error when issued for 'qmake'
echo "$self:${NBSP}Ignoring $command" >&2
END
    chmod +x "$wrapper"
}

switch_to_snapshot() {
    OPT_SNAPSHOT_SUFFIX=${OPT_SNAPSHOT_SUFFIX//%{task\}/$OPT_TASK}

    if [[ $OPT_SNAPSHOT_SUFFIX ]]; then
        OPT_TARGET=$OPT_ORIGINAL_TARGET.$OPT_SNAPSHOT_SUFFIX
        sdk-manage target snapshot --reset=outdated "$OPT_ORIGINAL_TARGET" "$OPT_TARGET" || return
    else
        local lock=$STATEDIR/snapshot.lock
        exec 10> "$lock" || return
        if ! flock --nonblock 10; then
            fatal "Failed to flock '$lock'"
        fi
        OPT_TARGET=$(sdk-manage target reserve "$OPT_ORIGINAL_TARGET" \
            "$OPT_ORIGINAL_TARGET.$SNAPSHOT_POOL_SUFFIX" "$lock" "$SNAPSHOT_POOL_SIZE") || return
    fi

    notice "Using the '$OPT_TARGET' snapshot of the build target"
}

run_build_requires() {
    if [[ $BUILD_REQUIRES_MODE == reset ]]; then
        if ! sdk-manage target snapshot --reset=force "$OPT_ORIGINAL_TARGET" "$OPT_TARGET"; then
            fatal "Failed to reset build target snapshot '$OPT_TARGET' to '$OPT_ORIGINAL_TARGET'"
        fi
    fi
    if [[ ! $BUILD_REQUIRES_NOREFRESH ]]; then
        # Refresh repos before installing dependencies
        sb2 -t "$OPT_TARGET" -m sdk-install -R zypper --non-interactive ref
    fi
    verify_target_dependencies
}

run_apply() {
    local message="Applying"
    local common_op=()
    if [[ $APPLY_REVERSE ]]; then
        message="Reversing"
        common_op+=(-R)
    fi

    local to_apply=
    local auto_applied=$(grep -q "^%autosetup" "$OPT_SPEC" \
        && ! grep -q "^%patch[0-9]" "$OPT_SPEC" \
        && echo 1)
    if [[ $auto_applied ]]; then
        to_apply=$(sed -n 's/^Patch\([0-9]*\):.*/\1/p' "$OPT_SPEC")
        common_op+=($(sed -n 's/^%autosetup\( .*\)\? \(-p *[0-9]\+\).*/\2/p' "$OPT_SPEC"))
    else
        to_apply=$(sed -n 's/^%patch\([0-9]*\).*/\1/p' "$OPT_SPEC")
    fi

    if [[ $APPLY_REVERSE ]]; then
        to_apply=$(tac <<<"$to_apply")
    fi

    (
        cd_to_spec_setup_dir
        for p in $to_apply; do
            if [[ ! $auto_applied ]]; then
                op="$(sed -n "s/^%patch$p \+\(.*\)/\1/p" "$OPT_SPEC")"
            fi
            patch_file="$(sed -n "s/^Patch$p: \+\(.*\)/\1/p" "$OPT_SPEC")"
            echo "$message $patch_file" >&2
            patch "${common_op[@]}" $op < "$(dirname "$OPT_SPEC")/$patch_file" >&2
        done
    )
}

run_build() {
    # intended to provide mb build behaviour
    verify_target_dependencies

    increment_build_number;
    if [[ $BUILD_NOPREP ]]; then
        sed -e '/^%patch/d' "$OPT_SPEC" > "$TMP_SPEC"
    else
        cp "$OPT_SPEC" "$TMP_SPEC"
    fi

    try_to_make_changelog >> "$TMP_SPEC"

    # get rid of potential windows linefeeds
    sed -i "s/\x0D$//g" "$TMP_SPEC"

    fix_package_version "$TMP_SPEC"

    local build_tgt=$(sb2 -t $OPT_TARGET gcc -dumpmachine)
    build_tgt=${build_tgt%-gnueabi}

    if is_shadow_build; then
        init_qmake_wrapper $WRAPPERSDIR/qmake
        init_cmake_wrapper $WRAPPERSDIR/cmake
    fi

    (
        cd_to_spec_setup_dir;
        [[ $OPT_CLEAN_OUTPUTDIR ]] && rm -f "$OPT_OUTPUTDIR/"*.rpm;
        sb2 -t $OPT_TARGET env PATH="$WRAPPERSDIR:$USERWRAPPERSDIR:$PATH" rpmbuild \
            --build-in-place --target=$build_tgt \
            "${BUILD_DEBUG[@]}" \
            --define "_smp_mflags -j$(rpm_quote "$BUILD_JOBS")" \
            --define "_rpmdir $OPT_OUTPUTDIR" \
            --define "_sourcedir $(dirname $OPT_SPEC)" \
            --define "_rpmfilename %%{name}-%%{version}-%%{release}.%%{arch}.rpm" \
            --define "_buildhost $(get_hostname)" \
            --buildroot="$buildroot" \
            "${BUILD_NOPREP[@]}" \
            -bb \
            "$TMP_SPEC" \
            "$@"
    )
}

run_prepare() {
    verify_target_dependencies

    increment_build_number;
    # TODO maybe add toggle here for disabling patch applying?
    cp "$OPT_SPEC" "$TMP_SPEC"

    # get rid of potential windows linefeeds
    sed -i "s/\x0D$//g" "$TMP_SPEC"

    fix_package_version "$TMP_SPEC"

    local build_tgt=$(sb2 -t $OPT_TARGET gcc -dumpmachine)
    build_tgt=${build_tgt%-gnueabi}
    (
        cd_to_spec_setup_dir;
        [[ $OPT_CLEAN_OUTPUTDIR ]] && rm -f "$OPT_OUTPUTDIR/"*.rpm;
        sb2 -t $OPT_TARGET rpmbuild --build-in-place --target=$build_tgt \
            "${BUILD_DEBUG[@]}" \
            --define "_smp_mflags -j$BUILD_JOBS" \
            --define "_rpmdir $OPT_OUTPUTDIR" \
            --define "_sourcedir $(dirname $OPT_SPEC)" \
            --define "_rpmfilename %%{name}-%%{version}-%%{release}.%%{arch}.rpm" \
            --define "_buildhost $(get_hostname)" \
            --buildroot="$buildroot" \
            -bp --short-circuit \
            "$TMP_SPEC"
    )
}

cmake_post_cleanup() {
    # Handle path changes for Qt Creator
    local cmakefiles="CMakeCache.txt"

    cp -p CMakeCache.txt CMakeCache.txt.qtccache

    for cbpfile in *.cbp; do
        [[ -f $cbpfile ]] || continue
        cp -p "$cbpfile" "$cbpfile.qtccache"
        cmakefiles="$cmakefiles $cbpfile"
    done

    if [[ $STATEDIR == /home/mersdk/share* && $MER_SSH_HOST_SHARED_HOME ]]; then
        sed -i "s|/home/mersdk/share|$MER_SSH_HOST_SHARED_HOME|g" $cmakefiles
    elif [[ $STATEDIR == /home/src1* && $MER_SSH_HOST_SHARED_SRC ]]; then
        sed -i "s|/home/src1|$MER_SSH_HOST_SHARED_SRC|g" $cmakefiles
    else
        echo "Failed to set CMake paths for Qt Creator"
        rm *.qtccache
    fi
}

cmake_pre_setup() {
    # Undo path changes for Qt Creator
    if [[ -f "CMakeCache.txt.qtccache" ]]; then
        mv CMakeCache.txt.qtccache CMakeCache.txt
        for cbp_file in *.cbp.qtccache; do
            mv $cbp_file ${cbp_file%.qtccache}
        done
    fi
}

run_cmake__process_args() {
    CMAKE_MODE=
    CMAKE_EXTRA_CONFIGURE_ARGS=()
    CMAKE_EXTRA_BUILD_ARGS=()
    CMAKE_EXTRA_BUILD_TOOL_ARGS=()
    CMAKE_BUILD_TARGET=

    [[ $1 ]] || fatal "Argument expected"

    case $1 in
        --build)
            CMAKE_MODE=build

            [[ $2 ]] || fatal "Option expects argument: '--build'"
            [[ $2 == . ]] || fatal "The argument to '--build' must be '.' (literally)"
            shift 2

            while [[ $# -gt 0 ]]; do
                case $1 in
                    --target)
                        [[ $2 ]] || fatal "Option expects argument: '--target'"
                        CMAKE_BUILD_TARGET=$2
                        shift
                        ;;
                    --)
                        shift
                        break
                        ;;
                    *)
                        CMAKE_EXTRA_BUILD_ARGS+=("$1")
                        ;;
                esac
                shift
            done
            CMAKE_EXTRA_BUILD_TOOL_ARGS=("$@")
            ;;
        *)
            [[ -e $1 ]] || fatal "Unrecognized argument: '$1'"

            CMAKE_MODE=configure

            local project_dir="${1%%+(/)}"
            handle_pro_file_or_dir_option "$project_dir"
            shift

            while [[ $1 == -- ]]; do shift; done
            CMAKE_EXTRA_CONFIGURE_ARGS=("$@")
            ;;
    esac
}

run_cmake() {
    local rpmbuild="--build . --target all"

    declare -p OPT_SPEC
    set -x
    if [[ $OPT_SPEC ]]; then
        local build_tgt=$(sb2 -t $OPT_TARGET gcc -dumpmachine)
        build_tgt=${build_tgt%-gnueabi}

        cp -a "$OPT_SPEC" "$TMP_SPEC"

        # get rid of potential windows linefeeds
        sed -i "s/\x0D$//g" "$TMP_SPEC"

        fix_package_version "$TMP_SPEC"

        # This is a good time to verify the target dependencies as per mb
        verify_target_dependencies

        case $CMAKE_MODE in
            configure)
                init_cmake_wrapper $WRAPPERSDIR/cmake
                init_noop_wrapper $WRAPPERSDIR/make
                ;;
            build)
                init_cmake_wrapper $WRAPPERSDIR/cmake
                init_simple_wrapper $WRAPPERSDIR/make "${CMAKE_EXTRA_BUILD_TOOL_ARGS[@]}"
                ;;
            *)
                fatal "Internal error: Invalid value '$CMAKE_MODE' in CMAKE_MODE"
                ;;
        esac

        (
            cd_to_spec_setup_dir

            sb2 -t $OPT_TARGET env PATH="${WRAPPERSDIR}:${USERWRAPPERSDIR}:${PATH}" rpmbuild \
                --build-in-place --target=$build_tgt --define "noecho 1" \
                --define "_sourcedir $(dirname $OPT_SPEC)" -bc --short-circuit "$TMP_SPEC"
        )
    else
        sb2 -t $OPT_TARGET cmake "$@" ${OPT_PRO_FILE_OR_DIR:+"$OPT_PRO_FILE_OR_DIR"}
    fi
    set +x
}

run_qmake() {
    if [[ "$OPT_SPEC" ]]; then
        local build_tgt=$(sb2 -t $OPT_TARGET gcc -dumpmachine)
        build_tgt=${build_tgt%-gnueabi}

        cp -a "$OPT_SPEC" "$TMP_SPEC"

        # get rid of potential windows linefeeds
        sed -i "s/\x0D$//g" "$TMP_SPEC"

        fix_package_version "$TMP_SPEC"

        # This is a good time to verify the target dependencies as per mb
        verify_target_dependencies

        init_qmake_wrapper $WRAPPERSDIR/qmake "$@"
        init_noop_wrapper $WRAPPERSDIR/make

        (
            cd_to_spec_setup_dir;

            sb2 -t $OPT_TARGET env PATH="$WRAPPERSDIR:$USERWRAPPERSDIR:$PATH" rpmbuild \
                --build-in-place --target=$build_tgt \
                --define "noecho 1" \
                --define "_sourcedir $(dirname $OPT_SPEC)" \
                --define "_buildhost $(get_hostname)" \
                -bc --short-circuit \
                "$TMP_SPEC"
        )
    else
        sb2 -t $OPT_TARGET qmake "$@" ${OPT_PRO_FILE_OR_DIR:+"$OPT_PRO_FILE_OR_DIR"}
    fi
}

run_make() {
    if [[ "$OPT_SPEC" ]]; then

        cp -a "$OPT_SPEC" "$TMP_SPEC"

        # get rid of potential windows linefeeds
        sed -i "s/\x0D$//g" "$TMP_SPEC"

        fix_package_version "$TMP_SPEC"

        local build_tgt=$(sb2 -t $OPT_TARGET gcc -dumpmachine)
        build_tgt=${build_tgt%-gnueabi}

        init_noop_wrapper $WRAPPERSDIR/qmake
        init_simple_wrapper $WRAPPERSDIR/make "$@"

        (
            cd_to_spec_setup_dir;
            sb2 -t $OPT_TARGET env PATH="$WRAPPERSDIR:$USERWRAPPERSDIR:$PATH" rpmbuild \
                --build-in-place --target=$build_tgt \
                --define "noecho 1" \
                --define "_sourcedir $(dirname $OPT_SPEC)" \
                --define "_buildhost $(get_hostname)" \
                -bc --short-circuit \
                "$TMP_SPEC"
        )
    else
        sb2 -t $OPT_TARGET make "$@"
    fi
}

run_make_install() {
    # Internal, intentionally undocumented
    local maybe_nocheck=--nocheck
    if [[ ${1:-} == --check ]]; then
        local maybe_nocheck=
        shift
    fi

    local build_tgt=$(sb2 -t $OPT_TARGET gcc -dumpmachine)
    build_tgt=${build_tgt%-gnueabi}

    cp -a "$OPT_SPEC" "$TMP_SPEC"

    # get rid of potential windows linefeeds
    sed -i "s/\x0D$//g" "$TMP_SPEC"

    fix_package_version "$TMP_SPEC"

    # Install to buildroot which should be rsync'ed to /opt/sdk/$package on device
    (
        cd_to_spec_setup_dir;
        sb2 -t $OPT_TARGET rpmbuild --build-in-place --target=$build_tgt \
            --define "noecho 1" \
            --define "_sourcedir $(dirname $OPT_SPEC)" \
            --define "_buildhost $(get_hostname)" \
            --define "_skip_install_processing 1" \
            --buildroot="$buildroot" \
            -bi --short-circuit $maybe_nocheck \
            "$TMP_SPEC"
    )
}

run_package() {
    local build_tgt=$(sb2 -t $OPT_TARGET gcc -dumpmachine)
    build_tgt=${build_tgt%-gnueabi}

    cp -a "$OPT_SPEC" "$TMP_SPEC"

    try_to_make_changelog >> "$TMP_SPEC"

    # get rid of potential windows linefeeds
    sed -i "s/\x0D$//g" "$TMP_SPEC"

    fix_package_version "$TMP_SPEC"

    (
        increment_build_number;
        cd_to_spec_setup_dir;
        [[ $OPT_CLEAN_OUTPUTDIR ]] && rm -f "$OPT_OUTPUTDIR/"*.rpm;
        sb2 -t $OPT_TARGET rpmbuild --build-in-place --target=$build_tgt \
            --define "noecho 1" \
            --define "_rpmdir $OPT_OUTPUTDIR" \
            --define "_sourcedir $(dirname $OPT_SPEC)" \
            --define "_rpmfilename %%{name}-%%{version}-%%{release}.%%{arch}.rpm" \
            --define "_buildhost $(get_hostname)" \
            --buildroot="$buildroot" \
            -bb --noprep --nobuildstage --noclean \
            "$TMP_SPEC"
    )
}

run_deploy() {
    [[ $device_type ]] || fatal "No device specified"
    [[ -e $STATEDIR/spec ]] || fatal "No previoud build found"

    local method_opt= all_opt= patterns=('-*-debug@(info|source)')
    while [[ $# -ne 0 ]]; do
        case $1 in
            --sdk | --pkcon | --zypper | --rsync | --manual )
                [[ ! $method_opt ]] || fatal "Cannot combine '$1' and '$method_opt'"
                method_opt=$1
                ;;
            --all )
                all_opt=$1
                ;;
            --debug )
                patterns=()
                ;;
            -- )
                shift
                patterns+=("$@")
                break
                ;;
            *)
                patterns+=("$@")
                break
                ;;
        esac
        shift
    done

    [[ ! $all_opt || $method_opt != --rsync ]] || fatal "Cannot use '--all' with '--rsync'"
    [[ ${method_opt:-} ]] || fatal "Argument expected"

    local retcode=0

    case $method_opt in
        --sdk | --pkcon )
            local method;
            if [[ $method_opt == --sdk ]]; then
                method="sdk-deploy-rpm"
            else
                method="pkcon --plain --noninteractive install-local"
            fi
            ! behind_qtcreator || run_package || return
            rpms=$(find_rpms $all_opt "$OPT_OUTPUTDIR" "$STATEDIR/spec" "${patterns[@]}")
            [[ $rpms ]] || fatal "No package found or none matched the given criteria"
            rsync_as $deviceuser -av ${rpms} $device_ip:/home/$deviceuser/RPMS/
            [[ $? -ne 0 ]] && return 1
            device_rpms=$(sed "s,^$OPT_OUTPUTDIR/,RPMS/," <<<"$rpms")
            ssh_as $deviceuser $method ${device_rpms}
            retcode=$?
            ssh_as $deviceuser rm -f ${device_rpms}
            ;;
        --zypper )
            ! behind_qtcreator || run_package || return
            rpms=$(find_rpms $all_opt "$OPT_OUTPUTDIR" "$STATEDIR/spec" "${patterns[@]}")
            [[ $rpms ]] || fatal "No package found or none matched the given criteria"
            rsync_as root -av ${rpms} $device_ip:/root/RPMS/
            [[ $? -ne 0 ]] && return 1
            device_rpms=$(sed "s,^$OPT_OUTPUTDIR/,RPMS/," <<<"$rpms")
            ssh_as root zypper --non-interactive --quiet in -f ${device_rpms}
            retcode=$?
            ssh_as root rm -f ${device_rpms}
            ;;
        --rsync )
            ! behind_qtcreator || run_make_install || return
            name=$(get_spec_tag "%{name}")
            rsync_as $deviceuser -av ${buildroot}/. $device_ip:/opt/sdk/$name
            retcode=$?
            ;;
        --manual )
            ! behind_qtcreator || run_package || return
            rpms=$(find_rpms $all_opt "$OPT_OUTPUTDIR" "$STATEDIR/spec" "${patterns[@]}")
            [[ $rpms ]] || fatal "No package found or none matched the given criteria"
            rsync_as $deviceuser -av ${rpms} $device_ip:/home/$deviceuser/RPMS/
            [[ $? -ne 0 ]] && return 1
            retcode=0
            ;;
        *)
            fatal "Internal error: Invalid deployment method: '$1'"
            ;;
    esac

    [[ $retcode -eq 0 ]] || { echo "Deploy failed"; return 1; }
}

run_undeploy__process_args() {
    UNDEPLOY_ALL=
    UNDEPLOY_DRY_RUN=
    UNDEPLOY_METHOD_OPT=
    UNDEPLOY_PATTERNS=()

    [[ $device_type ]] || fatal "No device specified"

    while [[ $# -ne 0 ]]; do
        case $1 in
            --pkcon | --rpm | --rsync | --zypper )
                if [[ $UNDEPLOY_METHOD_OPT ]]; then
                    fatal "Cannot combine '$1' and '$UNDEPLOY_METHOD_OPT'"
                fi
                UNDEPLOY_METHOD_OPT=$1
                ;;
            --all )
                UNDEPLOY_ALL=1
                ;;
            -n | --dry-run )
                UNDEPLOY_DRY_RUN=1
                ;;
            -- )
                shift
                UNDEPLOY_PATTERNS+=("$@")
                break
                ;;
            * )
                while [[ $# -ne 0 ]]; do
                    case $1 in
                        # Try to avoid bad surprices
                        -n | --dry-run )
                            fatal "Options must precede patterns"
                            ;;
                        * )
                            UNDEPLOY_PATTERNS+=("$1")
                            ;;
                    esac
                    shift
                done
                break
                ;;
        esac
        shift
    done

    [[ $UNDEPLOY_METHOD_OPT ]] || fatal "Argument expected"

    if [[ ! $UNDEPLOY_ALL ]]; then
        [[ -e $STATEDIR/spec ]] || fatal "No previoud build found"
    fi
}

run_undeploy() {
    local user=
    case $UNDEPLOY_METHOD_OPT in
        --pkcon | --rsync )
            user=$deviceuser
            ;;
        --rpm | --zypper )
            user=root
            ;;
        * )
            fatal "Internal error: Invalid undeploy method '$UNDEPLOY_METHOD_OPT'"
            ;;
    esac

    local candidates=
    if [[ $UNDEPLOY_METHOD_OPT == --rsync ]]; then
        # Consider all directories under /opt/sdk
        candidates=$(ssh_as "$user" ls /opt/sdk)
        candidates=$(sed 's,.*,& /opt/sdk/&,' <<<"$candidates")
    else
        # Consider all packages with matching BUILDHOST
        local format='%{BUILDHOST} %{SOURCERPM} %{NAME} %{EVR}\n'
        candidates=$(ssh_as "$user" rpm -q --queryformat "$format" -a)
        candidates=$(
            [[ $candidates ]] || exit 0
            wanted_buildhost=$(get_hostname)
            while read buildhost rest; do
                [[ $buildhost == "$wanted_buildhost" ]] && printf '%s\n' "$rest"
            done <<<"$candidates"
        )
    fi

    # candidates now contains [{src_name, name, maybe_evr}], optionally filter
    # by src_name, discard src_name.
    if [[ $UNDEPLOY_ALL ]]; then
        candidates=$(cut -d' ' -f2- <<<"$candidates")
    else
        candidates=$(
            [[ $candidates ]] || exit 0
            local wanted_src_name=$(get_spec_tag "%{name}")
            while read src_name rest; do
                [[ $src_name =~ ^"$wanted_src_name"(-[0-9].*)?$ ]] && printf '%s\n' "$rest"
            done <<<"$candidates"
        )
    fi

    # candidates now contains [{name, maybe_evr}], optionally filter by name
    if [[ ${#UNDEPLOY_PATTERNS[*]} -gt 0 ]]; then
        candidates=$(
            [[ $candidates ]] || exit 0
            while read name maybe_evr; do
                if match_multi "$name" "${UNDEPLOY_PATTERNS[@]}"; then
                    printf "%s %s\n" "$name" "$maybe_evr"
                fi
            done <<<"$candidates"
        )
    fi

    if [[ $UNDEPLOY_DRY_RUN ]]; then
        if [[ ! $candidates ]]; then
            echo "No candidate for removal found"
            return
        else
            echo "The following packages would be removed:"
            local name= evr=
            while read name evr; do
                printf '%s%s\n' "$name" "${evr:+-$evr}"
            done <<<"$candidates"
        fi
    fi

    # candidates now contains [{name, maybe_evr}], discard maybe_evr
    candidates=$(cut -d' ' -f1 <<<"$candidates")

    if [[ $UNDEPLOY_METHOD_OPT != --rsync ]]; then
        if ! ssh_as "$user" rpm --test -e $candidates; then
            return 1
        fi
    fi

    if [[ $UNDEPLOY_DRY_RUN ]]; then
        return 0
    fi

    case $UNDEPLOY_METHOD_OPT in
        --pkcon )
            ssh_as "$user" pkcon --plain --noninteractive remove $candidates
            ;;
        --rpm )
            ssh_as "$user" rpm -e $candidates
            ;;
        --rsync )
            local unsafe_to_rm_f=$(grep --invert-match '^/opt/sdk/[^.][^/]*$' <<<"$candidates")
            if [[ $unsafe_to_rm_f ]]; then
                fatal "Internal error: Refusing to remove '$unsafe_to_rm_f'"
            fi
            ssh_as "$user" rm -rf $candidates
            ;;
        --zypper )
            ssh_as "$user" zypper --non-interactive rm $candidates
            ;;
    esac
}

run_check__process_args() {
    local check_levels=$1
    local check_suites=$2
    local check_artefacts=("${@:3}")

    CHECK_SOURCE_ARTEFACT=
    CHECK_PACKAGE_ARTEFACTS=()
    for artefact in ${check_artefacts:+"${check_artefacts[@]}"}; do
        if [[ ! -e $artefact ]]; then
            fatal "No such file or directory: '$artefact'"
        fi
        if [[ $artefact == *.rpm && -f $artefact ]]; then
            CHECK_PACKAGE_ARTEFACTS+=("$artefact")
        elif [[ -d $artefact ]]; then
            if [[ $CHECK_SOURCE_ARTEFACT ]]; then
                fatal "Multiple artefacts of type 'source tree' specified"
            fi
            CHECK_SOURCE_ARTEFACT=$artefact
        else
            fatal "Unhandled type of artefact '$artefact'"
        fi
    done

    if [[ $CHECK_SOURCE_ARTEFACT && ${#CHECK_PACKAGE_ARTEFACTS[*]} -eq 0 ]]; then
        CHECK_LEVELS=($CHECK_LEVEL_SOURCE)
    elif [[ ! $CHECK_SOURCE_ARTEFACT && ${#CHECK_PACKAGE_ARTEFACTS[*]} -ne 0 ]]; then
        CHECK_LEVELS=($CHECK_LEVEL_PACKAGE)
    else
        CHECK_LEVELS=($CHECK_LEVEL_SOURCE $CHECK_LEVEL_PACKAGE)
    fi
    if [[ $check_levels ]]; then
        local expanded_check_levels=() level=
        for level in ${check_levels//,/ }; do
            local op=
            if [[ $level = [-+]* ]]; then
                op=${level:0:1}
                level=${level:1}
            fi
            case $level in
                $CHECK_LEVEL_STATIC)
                    expanded_check_levels+=($op$CHECK_LEVEL_SOURCE $op$CHECK_LEVEL_PACKAGE) ;;
                $CHECK_LEVEL_DYNAMIC)
                    expanded_check_levels+=($op$CHECK_LEVEL_UNIT $op$CHECK_LEVEL_SYSTEM) ;;
                $CHECK_LEVEL_SOURCE|$CHECK_LEVEL_PACKAGE|$CHECK_LEVEL_UNIT|$CHECK_LEVEL_SYSTEM)
                    expanded_check_levels+=($op$level) ;;
                *)
                    fatal "Not a recognized test level '$level'" ;;
            esac
        done
        set_update CHECK_LEVELS ${expanded_check_levels[*]}
    fi
    if [[ ${#CHECK_LEVELS[*]} -eq 0 ]]; then
        fatal "No test level selected"
    fi

    local rpmvalidation_suites_info=$(rpmvalidation --target "$OPT_TARGET" --list-suites)
    RPMVALIDATION_ALL_SUITES=($(awk '{print $1}' <<<"$rpmvalidation_suites_info"))
    local rpmvalidation_essential_suites=($(awk -v essential="$CHECK_ESSENTIAL" \
        '($2 == essential) { print $1 }' <<<"$rpmvalidation_suites_info"))
    CHECK_SUITES=($CHECK_RPMSPEC ${rpmvalidation_essential_suites[*]})
    if [[ $check_suites ]]; then
        for suite in ${check_suites//[,+-]/ }; do
            if [[ $suite != $CHECK_RPMSPEC ]] && ! set_contains RPMVALIDATION_ALL_SUITES "$suite"; then
                fatal "Not a known test suite '$suite'"
            fi
        done
        set_update CHECK_SUITES ${check_suites//,/ }
    fi
    if [[ ${#CHECK_SUITES[*]} -eq 0 ]]; then
        fatal "No test suite selected"
    fi
}

run_check() {
    if [[ $CHECK_LIST_SUITES ]]; then
        local US=$'\x1F'
        print_suite() ( IFS=$US; printf '%s\n' "$*"; )
        local raw=$(
            print_suite NAME ESSENTIAL LEVELS URL DESCRIPTION
            {
                print_suite "$CHECK_RPMSPEC" "$CHECK_ESSENTIAL" "$CHECK_LEVEL_UNIT" "-" \
                    "Execute the %check section of the .spec file"

                local name= essential= url= description=
                rpmvalidation --target "$OPT_TARGET" --list-suites \
                    |while read name essential url description; do
                        print_suite "$name" "$essential" "$CHECK_LEVEL_PACKAGE" "$url" "$description"
                    done
            } |sort --field-separator "$US" --key 1,1
        )

        local odd=$(cut -d "$US" -f 1-4 <<<"$raw" |column --table --separator "$US")
        local even=$(cut -d "$US" -f 5 <<<"$raw")
        paste -d $'\n' <(cat <<<"$odd") <(cat <<<"$even") |sed '2~2s/^/    /; 2d'
        return
    fi

    local rc=0 done_count=0

    if set_contains CHECK_LEVELS "$CHECK_LEVEL_UNIT"; then
        if set_contains CHECK_SUITES "$CHECK_RPMSPEC"; then
            let done_count++
            run_make_install --check || rc=1
        fi
    fi
    if set_contains CHECK_LEVELS "$CHECK_LEVEL_PACKAGE"; then
        local selected_rpmvalidation_suites=()
        set_intersect selected_rpmvalidation_suites RPMVALIDATION_ALL_SUITES CHECK_SUITES
        selected_rpmvalidation_suites=$(IFS=,; printf '%s' "${selected_rpmvalidation_suites[*]}")
        if [[ $selected_rpmvalidation_suites ]]; then
            local packages=(${CHECK_PACKAGE_ARTEFACTS:+"${CHECK_PACKAGE_ARTEFACTS[@]}"})
            if [[ ${#packages[*]} -eq 0 ]]; then
                if [[ ! -e $STATEDIR/spec ]]; then
                    notice "No previous build found and no package to verify specified explicitly"
                else
                    packages=($(find_rpms "$OPT_OUTPUTDIR" "$STATEDIR/spec" \
                        '-*-debug@(source|info)'))
                    if [[ ${#packages[*]} -eq 0 ]]; then
                        notice "No packages found and none specified explicitly"
                    fi
                fi
            fi
            local package=
            for package in "${packages[@]}"; do
                let done_count++
                rpmvalidation -t "$OPT_TARGET" --suites "$selected_rpmvalidation_suites" "$package" \
                    || rc=1
            done
        fi
    fi

    # The other levels are currently unimplemented

    if [[ $done_count -eq 0 ]]; then
        fatal "None of the selected test suites operate on the selected test levels. Nothing to do."
    fi

    return $rc
}

get_shared_dir() {
    echo "$OPT_SHARED_DIR"
}

inside_build_engine() [[ -f /etc/mer-sdk-vbox ]]
inside_git_worktree() { git_ status &>/dev/null; }

behind_qtcreator() {
    # Consider this the default frontend for backward compatibility
    inside_build_engine && [[ ! $SAILFISH_SDK_FRONTEND || $SAILFISH_SDK_FRONTEND == qtcreator ]]
}
behind_sfdk() {
    inside_build_engine && [[ $SAILFISH_SDK_FRONTEND == sfdk ]]
}

# Symlink creation under VirtualBox shared folder shared from Windows requires special permissions
# which are not always granted
maybe_symlink_create() {
    local target=$1 maybe_symlink=$2
    if inside_build_engine; then
        ln -sfn "$target" "$maybe_symlink" &>/dev/null || printf '%s' "$target" > "$maybe_symlink"
    else
        ln -sfn "$target" "$maybe_symlink"
    fi
}

maybe_symlink_read() {
    local maybe_symlink=$1
    if [[ -L $maybe_symlink ]]; then
        readlink -f "$maybe_symlink"
    else
        cat "$maybe_symlink"
    fi
}

# this is same as basename $0
ME=${0/#*\//}

DEF_TASK='git:^[[:alpha:]]{2,5}[[:digit:]]{3,}'

# option variables
OPT_SPEC=
OPT_TARGET=
OPT_ORIGINAL_TARGET=
OPT_SNAPSHOT=
OPT_SNAPSHOT_SUFFIX=
OPT_NO_SNAPSHOT=
OPT_DEVICE=
OPT_OUTPUTDIR=$(readlink -f ./RPMS)
OPT_CLEAN_OUTPUTDIR=1
OPT_SEARCH_OUTPUTDIR=
OPT_SEARCH_OUTPUTDIR_VERBOSITY=verbose
OPT_OUTPUT_PREFIX=
OPT_PKGDIR="./rpm"
OPT_PRO_FILE_OR_DIR=
OPT_SRC_DIR=
OPT_NEEDSPEC=
OPT_FIX_VERSION=
OPT_FIX_VERSION_HINT=
OPT_NO_FIX_VERSION=
OPT_GIT_CHANGE_LOG=
OPT_GIT_CHANGE_LOG_ARGS=
OPT_SHARED_DIR=/etc/mersdk/share
OPT_INC_BUILD_NUMBER=0
OPT_NO_DEPS=
OPT_WRAP=()
deviceuser=nemo

STATEDIR=$PWD/.mb2
TMP_SPEC=$STATEDIR/spec
SNAPSHOT_POOL_SUFFIX=mb2.XXX
SNAPSHOT_POOL_SIZE=5

CHECK_LEVEL_SOURCE=source
CHECK_LEVEL_PACKAGE=package
CHECK_LEVEL_STATIC=static
CHECK_LEVEL_UNIT=unit
CHECK_LEVEL_SYSTEM=system
CHECK_LEVEL_DYNAMIC=dynamic

CHECK_ESSENTIAL=Essential
CHECK_OPTIONAL=Optional

CHECK_RPMSPEC=rpmspec

# The working directory inside build engine is noexec and symlink creation under VirtualBox
# shared folder shared from Windows requires special permissions
if inside_build_engine; then
    WRAPPERSDIR=$HOME/.mb2/wrappers${PWD#"$HOME"}
    USERWRAPPERSDIR=$HOME/.mb2/user-wrappers${PWD#"$HOME"}
else
    WRAPPERSDIR=$STATEDIR/wrappers
    USERWRAPPERSDIR=$STATEDIR/user-wrappers
fi

# Virtualbox environment will install in this hardcoded location
if inside_build_engine; then
    buildroot=/home/deploy/installroot
else
    buildroot="$PWD/installroot"
fi

################################################################################
if [[ $1 != --self-test ]]; then  ###  M A I N  EXECUTION BEGINS HERE  #########
################################################################################

# The project-dir-or-file command line option serves just one purpose: to locate the source tree
# when doing a shadow build.  Including the file name is optional and takes no effect. If multiple
# .pro files exist in the directory, the selection is done inside the .spec file, mentioning one on
# qmake command line.
#
# An exception applies if there is no .spec file. In this case the qmake and make commands behave as
# plain qmake/make invocations, just wrapped with sb2, and the project-dir-or-file option is
# forwarded to qmake without modifications.
#
# If this is called with an empty argument, the default settings is restored.
handle_pro_file_or_dir_option() {
    local pro_file_or_dir=$1

    rm -f "$STATEDIR/src"

    if [[ ! $pro_file_or_dir ]]; then
        return
    fi

    local pro_dir=
    if [[ -d $pro_file_or_dir ]]; then
        pro_dir=$(readlink -f "$pro_file_or_dir")
    else
        pro_dir=$(dirname "$(readlink -f "$pro_file_or_dir")")
    fi

    local src_dir=
    local dir=$pro_dir
    while true; do
        if [[ -d $dir/rpm && $(find "$dir/rpm" -maxdepth 1 -name '*.spec' -o -name '*.yaml') ]]; then
            src_dir=$dir
            break
        fi
        # Skip any "rpm" ancestor in path to avoid misintepreting it as THE rpm directory
        while [[ $(basename "$dir") == rpm ]]; do
            dir=$(dirname "$dir")
        done
        dir=$(dirname "$dir")
        # For in-place builds do not search above the CWD, for shadow builds do not search above
        # common prefix
        if [[ $(readlink -f "$PWD") == "$dir"/* ]]; then
            break
        fi
    done

    # Silently fall back to the directory where the project file resides - some commands can be used
    # without spec file
    : ${src_dir:=$pro_dir}

    OPT_PRO_FILE_OR_DIR=$pro_file_or_dir

    # The project file/directory might be specified explicitly for non-shadow builds as well
    if [[ $src_dir != "$(readlink -f "$PWD")" ]]; then
        maybe_symlink_create "$src_dir" "$STATEDIR/src"
    fi
}

maybe_restore_shadow_build() {
    if [[ -e $STATEDIR/src ]]; then
        OPT_SRC_DIR=$(maybe_symlink_read "$STATEDIR/src")
        OPT_PKGDIR=$OPT_SRC_DIR/rpm
    fi
}

is_shadow_build() [[ -e $STATEDIR/src ]]

pro_file_or_dir=

while [[ "$1" ]]; do
    # only set variables in this loop
    case "$1" in
        "-t" | "--target") shift
            OPT_TARGET="$1"; shift
            ;;
        "-f" | "--shared-folder") shift
            OPT_SHARED_DIR="${1%%+(/)}"; shift
            ;;
        "-d" | "--device") shift
            OPT_DEVICE="$1"; shift
            ;;
        "-o" | "--outputdir" | "--output-dir")
            if [[ $1 == --outputdir ]]; then
                notice "The '$1' option is deprecated. Use '--output-dir' instead."
            fi
            shift
            [[ -d "$1" ]] || fatal "'$1' is not a directory"
            OPT_OUTPUTDIR="${1%%+(/)}"; shift
            OPT_OUTPUT_PREFIX=
            OPT_CLEAN_OUTPUTDIR=
            OPT_SEARCH_OUTPUTDIR=1
            ;;
        "-O" | "--output-prefix") shift
            [[ -d "$1" ]] || fatal "'$1' is not a directory"
            OPT_OUTPUT_PREFIX="${1%%+(/)}"; shift
            OPT_OUTPUTDIR=
            OPT_CLEAN_OUTPUTDIR=
            OPT_SEARCH_OUTPUTDIR=1
            ;;
        "-p" | "--projectdir")
            notice "The '$1' option is deprecated. Try '$ME --help' for more information."
            [[ -d "$2" ]] || fatal "'$2' is not a directory"
            pro_file_or_dir="${2%%+(/)}"
            shift 2
            ;;
        "--search-output-dir") shift
            OPT_SEARCH_OUTPUTDIR=1
            ;;
        "--search-output-dir"=* )
            OPT_SEARCH_OUTPUTDIR=1
            OPT_SEARCH_OUTPUTDIR_VERBOSITY=${1#*=}
            if [[ $OPT_SEARCH_OUTPUTDIR_VERBOSITY != verbose &&
                    $OPT_SEARCH_OUTPUTDIR_VERBOSITY != quiet ]]; then
                fatal "Unexpected argument to '--search-output-dir': '$OPT_SEARCH_OUTPUTDIR_VERBOSITY'"
            fi
            shift
            ;;
        "--no-search-output-dir") shift
            OPT_SEARCH_OUTPUTDIR=
            ;;
        "-s" | "--specfile" ) shift
            OPT_SPEC="$1"; shift
            ;;
        "-S" | "--snapshot" ) shift
            OPT_SNAPSHOT=1
            OPT_SNAPSHOT_SUFFIX=
            ;;
        "-S"=* | "--snapshot"=* )
            OPT_SNAPSHOT=1
            OPT_SNAPSHOT_SUFFIX=${1#*=}
            shift
            ;;
        "--no-snapshot" ) shift
            OPT_SNAPSHOT=
            OPT_SNAPSHOT_SUFFIX=
            OPT_NO_SNAPSHOT=1
            ;;
        "-T" | "--task" ) shift
            OPT_TASK=$DEF_TASK
            ;;
        "-T"=* | "--task"=* )
            OPT_TASK=${1#*=}
            shift
            ;;
        "--no-task" ) shift
            OPT_TASK=
            ;;
        "--wrap" )
            [[ $2 == *?:?* ]] || fatal "The '$1' options requires an argument"
            OPT_WRAP+=("$2")
            shift 2
            ;;
        "-i" | "--increment" ) shift
            OPT_INC_BUILD_NUMBER=1
            ;;
        "-P" | "--pedantic" )
            notice "The '$1' option is deprecated and does nothing currently"
            shift
            ;;
        "-x" | "--fix-version" ) shift
            OPT_FIX_VERSION=1
            OPT_FIX_VERSION_HINT=
            OPT_NO_FIX_VERSION=
            ;;
        "-x="* | "--fix-version="* )
            OPT_FIX_VERSION=1
            OPT_FIX_VERSION_HINT=${1#*=}
            OPT_NO_FIX_VERSION=
            shift
            ;;
        "-X" | "--no-fix-version" ) shift
            OPT_FIX_VERSION=
            OPT_FIX_VERSION_HINT=
            OPT_NO_FIX_VERSION=1
            ;;
        "-n" | "--no-deps") shift
            OPT_NO_DEPS=1
            ;;
        "-c" | "--git-change-log" ) shift
            OPT_GIT_CHANGE_LOG=1
            ;;
        "-c="* | "--git-change-log="* )
            OPT_GIT_CHANGE_LOG=1
            OPT_GIT_CHANGE_LOG_ARGS="${1#*=}"
            shift
            ;;
        "-m" | "--submodule" )
            notice "The '$1' option is deprecated and does nothing currently"
            shift 2
            ;;
        make-install | install | package | rpm | deploy | build | build-requires | installdeps \
            | apply | prepare | prep )
            OPT_NEEDSPEC=1;
            break
            ;;
        qmake | cmake | make )
            if behind_sfdk; then
                OPT_NEEDSPEC=1
            fi
            break
            ;;
        run | ssh | check | undeploy )
            break
            ;;
        --version )
            echo "$ME, version VERSION_FROM_SPEC"
            exit 0
            ;;
        --help )
            usage
            exit 0
            ;;
        *)
            short_usage quit
            ;;
    esac
done

mkdir -p "$STATEDIR" || exit
echo '*' > "$STATEDIR/.gitignore"

if [[ -n "$OPT_SPEC" ]]; then
    try_to_make_spec "$OPT_SPEC"
    [[ -f "$OPT_SPEC" ]] || fatal "'$OPT_SPEC' does not exist (and could not be made from a .yaml)"
fi

if [[ -n "$OPT_DEVICE" ]]; then
    if [[ ! -f $(get_shared_dir)/devices.xml ]]; then
        fatal "Unable to open '$(get_shared_dir)/devices.xml'." \
            "Please launch Qt Creator for the first time to finish the installation"
    fi
    if ! get_device "$OPT_DEVICE" < $(get_shared_dir)/devices.xml; then
        fatal "'$OPT_DEVICE' is not a known device"
    fi
fi

if [[ ! "$OPT_TARGET" ]]; then
    if [[ -f ~/.scratchbox2/config ]]; then
        . ~/.scratchbox2/config
        OPT_TARGET=$DEFAULT_TARGET
    fi
    [[ "$OPT_TARGET" ]] || fatal "No build target specified and there is no default one"
fi

OPT_ORIGINAL_TARGET=$OPT_TARGET

[[ -d ~/.scratchbox2/$OPT_TARGET ]] || fatal "'$OPT_TARGET' is not a known build target"

if [[ $OPT_SNAPSHOT ]]; then
    switch_to_snapshot || fatal "Failed to init build target snapshot"
elif [[ ! $OPT_NO_SNAPSHOT && ! $MB2_SELF_TEST_RUN ]]; then
    if [[ $(sdk-manage target list --snapshots-of "$OPT_TARGET") ]]; then
        echo >&2 "The '$OPT_TARGET' target has snapshots."
        echo >&2 "Pass '--no-snapshot' to confirm you really want to use the target directly."
        exit 1
    fi
fi

case "$1" in
    make | make-install | install | package | rpm | deploy | prepare | prep )
        if [[ $1 == install ]]; then
            notice "The 'install' command is deprecated. Use 'make-install' instead."
            set -- make-install "${@:2}"
        fi
        if [[ $1 == rpm ]]; then
            notice "The 'rpm' command is deprecated. Use 'package' instead."
            set -- package "${@:2}"
        fi
        if [[ $1 == prep ]]; then
            notice "The 'prep' command is deprecated. Use 'prepare' instead."
            set -- prepare "${@:2}"
        fi
        cmd=run_${1//-/_}
        shift
        ;;
    undeploy )
        cmd=run_$1; shift
        run_undeploy__process_args "$@"
        if [[ ! $UNDEPLOY_ALL ]]; then
            OPT_NEEDSPEC=1
        fi
        shift $#
        ;;
    build-requires | installdeps )
        if [[ $1 == installdeps ]]; then
            notice "The 'installdeps' command is deprecated. Use 'build-requires' instead."
        fi
        cmd=run_build_requires; shift
        if [[ $OPT_SNAPSHOT ]]; then
            BUILD_REQUIRES_NOREFRESH=1
        fi
        while [[ "$1" ]]; do
            case "$1" in
                --refresh) shift
                    BUILD_REQUIRES_NOREFRESH= ;;
                --no-refresh) shift
                    BUILD_REQUIRES_NOREFRESH=1 ;;
                reset|--reset)
                    if [[ $1 == --reset ]]; then
                        notice "The '--reset' option is deprecated. Use 'reset' (non-option) instead."
                    fi
                    shift
                    if [[ ! $OPT_SNAPSHOT ]]; then
                        fatal "Cannot do 'build-requires reset' without '--snapshot'"
                    fi
                    BUILD_REQUIRES_MODE=reset ;;
                pull) shift
                    BUILD_REQUIRES_MODE=pull ;;
                *)
                    short_usage quit
                    ;;
            esac
        done
        if [[ ! $BUILD_REQUIRES_MODE ]]; then
            notice "Omitting 'pull' is deprecated. Pass 'pull' explicitly."
            BUILD_REQUIRES_MODE=pull
        fi
        ;;
    apply )
        cmd=run_$1; shift
        APPLY_REVERSE=
        while [[ "$1" ]]; do
            case "$1" in
                -R) shift
                    APPLY_REVERSE=1 ;;
                *)
                    short_usage quit
                    ;;
            esac
        done
        ;;
    qmake )
        cmd=run_$1; shift
        while [[ "$1" ]]; do
            case "$1" in
                --) shift
                    break
                    ;;
                *)
                    if [[ -e $1 ]]; then
                        pro_file_or_dir="${1%%+(/)}"
                        shift
                    fi
                    break
                    ;;
            esac
        done
        handle_pro_file_or_dir_option "$pro_file_or_dir"
        ;;
    cmake )
        cmd=run_$1; shift
        run_cmake__process_args "$@"
        shift $#
        ;;
    build )
        cmd=run_$1; shift
        BUILD_DEBUG=(--define "debug_package %{nil}")
        BUILD_JOBS=
        BUILD_NOPREP=(--noprep)
        while [[ "$1" ]]; do
            case "$1" in
                -d|--enable-debug) shift
                    BUILD_DEBUG=() ;;
                -j*)
                    # support giving -j with and without space between
                    # it and the 'n'
                    if [[ ${#1} -gt 2 ]]; then
                        BUILD_JOBS=${1:2}; shift
                    else
                        [[ -z "$2" ]] && short_usage quit
                        BUILD_JOBS="$2"; shift 2;
                    fi
                    ;;
                -p|--doprep) shift
                    BUILD_NOPREP=()
                    ;;
                --) shift
                    break
                    ;;
                *)
                    if [[ -e $1 ]]; then
                        pro_file_or_dir="${1%%+(/)}"
                        shift
                    fi
                    break
                    ;;
            esac
        done
        handle_pro_file_or_dir_option "$pro_file_or_dir"
        [[ $BUILD_JOBS ]] || BUILD_JOBS=$(getconf _NPROCESSORS_ONLN)
        ;;
    run | ssh )
        if [[ $1 == ssh ]]; then
            notice "The 'ssh' command is deprecated. Use 'run' instead."
        fi
        shift
        if [[ "$OPT_DEVICE" ]]; then
            cmd="ssh_as $deviceuser"
        else
            if behind_sfdk; then
                fatal "No device specified"
            else
                notice "Using the 'run' command without '--device' is deprecated"
            fi
            cmd=""
        fi
        ;;
    check )
        cmd=run_$1; shift
        CHECK_LIST_SUITES=
        check_levels=
        check_suites=
        check_artefacts=()
        while [[ "$1" ]]; do
            case "$1" in
                --list-suites) shift
                    CHECK_LIST_SUITES=1
                    ;;
                -l|--levels) shift
                    [[ $1 ]] || short_usage quit
                    check_levels=$1
                    shift
                    ;;
                -s|--suites) shift
                    [[ $1 ]] || short_usage quit
                    check_suites=$1
                    shift
                    ;;
                --) shift
                    check_artefacts+=(${@:+"$@"})
                    break
                    ;;
                -*)
                    short_usage quit
                    ;;
                *)
                    check_artefacts+=("$1")
                    shift
                    ;;
            esac
        done

        if [[ ! $CHECK_LIST_SUITES ]]; then
            run_check__process_args "$check_levels" "$check_suites" ${check_artefacts:+"${check_artefacts[@]}"}

            notice "Testing on levels: ${CHECK_LEVELS[*]}"
            notice "Testing with suites: ${CHECK_SUITES[*]}"

            if set_contains CHECK_LEVELS "$CHECK_LEVEL_PACKAGE" && [[ ${#CHECK_PACKAGE_ARTEFACTS[*]} -eq 0 ]] \
                || set_contains CHECK_LEVELS "$CHECK_LEVEL_UNIT"; then
                OPT_NEEDSPEC=1
            fi
        fi
        ;;
    *)
        short_usage quit
        ;;
esac

maybe_restore_shadow_build

maybe_set_task_name_from_git_branch_name

if [[ $OPT_OUTPUT_PREFIX ]]; then
    OPT_OUTPUTDIR=$OPT_OUTPUT_PREFIX/${OPT_TASK:+$OPT_TASK-}$OPT_ORIGINAL_TARGET
fi

if [[ $OPT_SEARCH_OUTPUTDIR ]]; then
    mkdir -p "$OPT_OUTPUTDIR"
fi

if [[ $OPT_FIX_VERSION_HINT && ! $(git_ tag --list "$OPT_FIX_VERSION_HINT") ]]; then
    fatal "'$OPT_FIX_VERSION_HINT': no such Git tag"
fi

# spec rules are complex:
#  a .spec is required for some but not all operations
#  if -s is given then
#    if it does not exist then specify tries to make it
#    if it exists it will be used
#  if there is a rpm/*.spec then that is used
#  if there is a rpm/*.yaml then a spec is made and used

if [[ ! "$OPT_SPEC" ]]; then
    # set nullglob on so that the shell glob expansions will return
    # empty if files are not found
    shopt -s nullglob
    spec_files=("$OPT_PKGDIR"/*.spec)
    numspec=${#spec_files[@]}
    if [[ $numspec -gt 1 ]]; then
        [[ $OPT_NEEDSPEC ]] && fatal "Multiple spec files found - use --specfile to select one"
        echo "Multiple spec files found - not using any. Use --specfile to select one"
        # OPT_SPEC is not set
    elif [[ $numspec -eq 1 ]]; then
        OPT_SPEC="${spec_files[0]?}"
    else
        # No spec, try to find a yaml
        yaml_files=("$OPT_PKGDIR"/*.yaml)
        numyaml=${#yaml_files[@]}
        if [[ $numyaml -eq 1 ]]; then
            theyaml=("$OPT_PKGDIR"/*.yaml)
            try_to_make_spec_from_yaml "${theyaml[0]}"
            spec_files=("$OPT_PKGDIR"/*.spec)
            OPT_SPEC="${spec_files[0]?}"
        else
            [[ $OPT_NEEDSPEC ]] && fatal "No spec or yaml file found in '$OPT_PKGDIR/'"
        fi
    fi

    # unset nullglob so that any further globbing works normally
    shopt -u nullglob
fi

# Now if there is a spec given, make sure it is up-to-date
if [[ "$OPT_SPEC" ]]; then
    # turn 'OPT_SPEC' into an absolute path
    OPT_SPEC=$(readlink -f "$OPT_SPEC")
    ensure_spec_newer_than_yaml
fi

remove_wrappers_dir

if [[ -f "CMakeCache.txt" ]]; then
    cmake_pre_setup
fi

$cmd "$@"

rc=$?

if [[ -f "CMakeCache.txt" ]]; then
    cmake_post_cleanup
fi

exit $rc
##############################################################################
fi ###  S E L F - T E S T  EXECUTION BEGINS HERE #############################
##############################################################################

set -o nounset

SELF=$(readlink -f "$0")

: ${MB2_SELF_TEST_VERBOSE:=}
: ${MB2_SELF_TEST_TS:=}

temp=$(mktemp -d) || exit
trap "rm -rf '$temp'" EXIT
cd "$temp" || exit

mkdir stubs || exit
STUBS_DIR=$(readlink -f stubs)
ORIG_PATH=$PATH
export PATH="$STUBS_DIR:$PATH"

if ! which make >/dev/null; then
    fatal "Please install 'make' and try again"
fi

export MB2_SELF_TEST_RUN=1

################################################################################
# Test utils

tc_num=0
tc_failed_num=0

set_up_ts() {
    local ts=$1
    TS_NAME=$2

    if [[ $MB2_SELF_TEST_TS && $TS_NAME != "$MB2_SELF_TEST_TS" ]]; then
        return
    fi

    ${ts}_ts_set_up "${@:3}"
    if [[ $? -ne 0 ]]; then
        fatal "Test suite set-up failed: $ts"
    fi
}

tear_down_ts() {
    local ts=$1

    if [[ $MB2_SELF_TEST_TS && $TS_NAME != "$MB2_SELF_TEST_TS" ]]; then
        return
    fi

    ${ts}_ts_tear_down
    if [[ $? -ne 0 ]]; then
        fatal "Test suite tear-down failed: $ts"
    fi
    TS_NAME=
}

KNOWN_ISSUES=()
KNOWN_ISSUE() {
    KNOWN_ISSUES=(${KNOWN_ISSUES[@]:+"${KNOWN_ISSUES[@]}"} "$1")
}

run_tc() {
    local tc=$1
    TC_NAME=$2
    local args=("${@:3}")

    if [[ $MB2_SELF_TEST_TS && ${TS_NAME:-} != "$MB2_SELF_TEST_TS" ]]; then
        KNOWN_ISSUES=()
        return
    fi

    let tc_num++
    echo "*** Executing test case: ${TS_NAME:+$TS_NAME - }$TC_NAME"

    local known_issue
    for known_issue in ${KNOWN_ISSUES[@]:+"${KNOWN_ISSUES[@]}"}; do
        echo "    Known issue: $known_issue"
    done
    KNOWN_ISSUES=()

    local stderr=
    { stderr=$(${tc}_tc ${args[@]:+"${args[@]}"} 3>&1 1>&2 2>&3 3>&-); } 2>&1
    local rc=$?

    if [[ $rc -ne 0 ]]; then
        let tc_failed_num++
    fi

    if [[ $rc -ne 0 || $MB2_SELF_TEST_VERBOSE ]]; then
        cat <<END
  ** Stderr     ** [[
$stderr
]]
END
    fi

    if [[ $(type -t ${tc}_tc_tear_down) == function ]]; then
        ${tc}_tc_tear_down
        if [[ $? -ne 0 ]]; then
            fatal "Test case tear-down failed: $tc"
        fi
    fi

    return $rc
}

arg_pass_stub_create() {
    while [[ ${1:-} ]]; do
        local stub=$STUBS_DIR/$1
        local results=$STUBS_DIR/$1.args

        touch "$results" || return
        cat >"$stub" <<END || return
#!/bin/bash
echo "stub invoked: \$0 \$(printf "%q " "\$@")" >&2
{ [[ \$# -ne 0 ]] && printf "%q\\n" "\$@"; } >"$results"
exit 0
END
        chmod +x "$stub" || return
        shift
    done
}

arg_pass_stub_remove() {
    while [[ ${1:-} ]]; do
        local stub=$STUBS_DIR/$1
        local results=$STUBS_DIR/$1.args
        rm -f "$stub" || return
        rm -f "$results" || return
        shift
    done
}

arg_pass_stub_results() {
    local results=$STUBS_DIR/$1.args
    [[ -e $results ]] && cat "$results"
}

arg_pass_stub_clear() {
    while [[ ${1:-} ]]; do
        local results=$STUBS_DIR/$1.args
        rm -f "$results" || return
        shift
    done
}

expect_args() {
    [[ $# -ne 0 ]] && printf "%q\n" "$@" || true
}

sb2_stub() {
    echo "stub invoked: $0 $(printf "%q " "$@")" >&2

    local args=("$@")
    bad_args() {
        echo "stub $0: unexpected arguments: $(printf "%q " "${args[@]}")" >&2
    }

    if ! [[ $1 == -t && $3 != -* ]]; then
        bad_args
        return 1
    fi

    shift 2

    env=(env)
    if [[ $1 == env ]]; then
        shift
        while [[ $1 == -* || $1 =~ ^[[:alnum:]_]+= ]]; do
            env+=("$1")
            shift
        done
    fi

    case $1 in
        gcc)
            case $2 in
                -dumpmachine)
                    echo "i486-meego-linux"
                    ;;
                *)
                    bad_args
                    return 1
                    ;;
            esac
            ;;
        rpmbuild)
            # rpmbuild writes some progress messages to stdout
            exec "${env[@]}" "$@" >&2
            ;;
        rpmspec)
            exec "${env[@]}" "$@"
            ;;
        *)
            bad_args
            return 1
            ;;
    esac
}

sb2_stub_create() {
    cat >"$STUBS_DIR/sb2" <<END || return
#!/bin/bash
$(declare -f sb2_stub)
sb2_stub "\$@"
END
    chmod +x "$STUBS_DIR/sb2" || return
}

sb2_stub_remove() {
    rm -f "$STUBS_DIR/sb2" || return
}

DEFAULT_TARGET=$(. ~/.scratchbox2/config; echo "$DEFAULT_TARGET")
DEFAULT_JOBS=$(getconf _NPROCESSORS_ONLN)

if inside_build_engine; then
    # Assume the first one mentioned is the most recent one
    DEFAULT_DEVICE=$(sed -n 's/.*name="\(Sailfish OS Emulator[^"]*\)".*/\1/; T; p; q' \
        "$(get_shared_dir)/devices.xml")
else
    echo "Note: Skipping test cases involving device connection - not inside a Sailfish OS build engine" >&2
    DEFAULT_DEVICE=
fi

################################################################################
# Test the rpm_quote function

rpm_quote_tc() {
    arg_pass_stub_create make || return

    # Create an minimal spec file
    mkdir rpm || return
    cat >rpm/test.spec <<END || return
Name: test
Version: 1.0
Release: 0
Summary: Test
License: BSD

# This would normally come from the environment
%{!?make:%define make make}

%description
Test

%build
%make "x  y"
END

    rpmbuild -bc --short-circuit --noprep --build-in-place --define "_sourcedir $(readlink -f rpm)" rpm/test.spec \
        --define "make make $(rpm_quote "a b" "c  d" e f)" >&2 || return
    local rc=0 expected= actual= diff=
    expected=$(expect_args "a b" "c  d" e f "x  y")
    actual=$(arg_pass_stub_results make) || return
    if ! diff=$(diff <(cat <<<"$expected") <(cat <<<"$actual")); then
        rc=1
        cat <<END
Test case failed: $TC_NAME
  ** Mismatch   ** [[
$diff
]]
  ** Expected   ** [[
$expected
]]
  ** Actual     ** [[
$actual
]]
END
    fi

    arg_pass_stub_remove make || return
    rm -f rpm/test.spec || return
    rmdir rpm || return

    return $rc
}

run_tc rpm_quote "Test RPM macro escaping"

################################################################################
# Test sb2 argument passing

sb2_arg_pass_ts_set_up() {
    arg_pass_stub_create sb2 || return

    WRAPPERS_PATH="/tmp/@TMPDIR@/.mb2/wrappers:/tmp/@TMPDIR@/.mb2/user-wrappers"

    # Create an empty spec file
    mkdir rpm || return
    : >rpm/test.spec || return
}

sb2_arg_pass_ts_tear_down() {
    arg_pass_stub_remove sb2 || return
    rm -f rpm/test.spec || return
    rmdir rpm || return
    unset WRAPPERS_PATH
}

sb2_arg_pass_tc() {
    local expected=$1
    local args=("${@:2}")

    arg_pass_stub_clear sb2 || return
    "$SELF" "${args[@]}" || return
    local actual_raw= actual= diff=
    actual_raw=$(arg_pass_stub_results sb2) || return
    actual=$(sed -e 's,/home/mersdk/.mb2/wrappers/tmp/tmp\.[[:alnum:]]\+,/tmp/@TMPDIR@/.mb2/wrappers,g' \
                 -e 's,/home/mersdk/.mb2/user-wrappers/tmp/tmp\.[[:alnum:]]\+,/tmp/@TMPDIR@/.mb2/user-wrappers,g' \
                 -e 's,/tmp\.[[:alnum:]]\+,/@TMPDIR@,g' \
                 -e "s,/home/deploy,/tmp/@TMPDIR@,g" <<<"$actual_raw")
    if ! diff=$(diff <(cat <<<"$expected") <(cat <<<"$actual")); then
        cat <<END
Test case failed: $TC_NAME
  ** Command    ** $ME $(quote "${args[@]}")
  ** Mismatch   ** [[
$diff
]]
  ** Expected   ** [[
$expected
]]
  ** Actual     ** [[
$actual
]]
  ** Actual RAW ** [[
$actual_raw
]]
END
        return 1
    fi
}

set_up_ts sb2_arg_pass "Passing arguments to sb2"

KNOWN_ISSUE "Does not disable debug by default (ignores --enable-debug)"
KNOWN_ISSUE "Passes -j without argument"
KNOWN_ISSUE "Silently ignores extra arguments"
run_tc sb2_arg_pass "prepare" \
    "$(expect_args \
        -t "$DEFAULT_TARGET" rpmbuild --build-in-place --target= \
        --define '_smp_mflags -j' \
        --define '_rpmdir /tmp/@TMPDIR@/RPMS' \
        --define '_sourcedir /tmp/@TMPDIR@/rpm' \
        --define '_rpmfilename %%{name}-%%{version}-%%{release}.%%{arch}.rpm' \
        --buildroot=/tmp/@TMPDIR@/installroot \
        -bp --short-circuit \
        /tmp/@TMPDIR@/.mb2/spec)" \
    prepare "a b" "c  d" e f

run_tc sb2_arg_pass "build" \
    "$(expect_args \
        -t "$DEFAULT_TARGET" env PATH="$WRAPPERS_PATH:/tmp/@TMPDIR@/stubs:$ORIG_PATH" rpmbuild \
        --build-in-place --target= \
        --define 'debug_package %{nil}' \
        --define "_smp_mflags -j$(rpm_quote "bad  1")" \
        --define '_rpmdir /tmp/@TMPDIR@/RPMS' \
        --define '_sourcedir /tmp/@TMPDIR@/rpm' \
        --define '_rpmfilename %%{name}-%%{version}-%%{release}.%%{arch}.rpm' \
        --buildroot=/tmp/@TMPDIR@/installroot \
        -bb \
        /tmp/@TMPDIR@/.mb2/spec \
        "a b" "c  d" e f)" \
    build --doprep -j "bad  1" "a b" "c  d" e f

run_tc sb2_arg_pass "build with debug" \
    "$(expect_args \
        -t "$DEFAULT_TARGET" env PATH="$WRAPPERS_PATH:/tmp/@TMPDIR@/stubs:$ORIG_PATH" rpmbuild \
        --build-in-place --target= \
        --define "_smp_mflags -j$(rpm_quote "bad  1")" \
        --define '_rpmdir /tmp/@TMPDIR@/RPMS' \
        --define '_sourcedir /tmp/@TMPDIR@/rpm' \
        --define '_rpmfilename %%{name}-%%{version}-%%{release}.%%{arch}.rpm' \
        --buildroot=/tmp/@TMPDIR@/installroot \
        -bb \
        /tmp/@TMPDIR@/.mb2/spec \
        "a b" "c  d" e f)" \
    build --doprep --enable-debug -j "bad  1" "a b" "c  d" e f

run_tc sb2_arg_pass "qmake" \
    "$(expect_args \
        -t "$DEFAULT_TARGET" env PATH="$WRAPPERS_PATH:/tmp/@TMPDIR@/stubs:$ORIG_PATH" rpmbuild \
        --build-in-place --target= \
        --define 'noecho 1' \
        --define '_sourcedir /tmp/@TMPDIR@/rpm' \
        -bc --short-circuit \
        /tmp/@TMPDIR@/.mb2/spec)" \
    qmake "a b" "c  d" e f

run_tc sb2_arg_pass "make" \
    "$(expect_args \
        -t "$DEFAULT_TARGET" env PATH="$WRAPPERS_PATH:/tmp/@TMPDIR@/stubs:$ORIG_PATH" rpmbuild \
        --build-in-place --target= \
        --define 'noecho 1' \
        --define '_sourcedir /tmp/@TMPDIR@/rpm' \
        -bc --short-circuit \
        /tmp/@TMPDIR@/.mb2/spec)" \
    make "a b" "c  d" e f

KNOWN_ISSUE "Silently ignores extra arguments"
run_tc sb2_arg_pass "make-install" \
    "$(expect_args \
        -t "$DEFAULT_TARGET" rpmbuild --build-in-place --target= \
        --define 'noecho 1' \
        --define '_sourcedir /tmp/@TMPDIR@/rpm' \
        --define '_skip_install_processing 1' \
        --buildroot='/tmp/@TMPDIR@/installroot' \
        -bi --short-circuit --nocheck \
        /tmp/@TMPDIR@/.mb2/spec)" \
    make-install "a b" "c  d" e f

KNOWN_ISSUE "Silently ignores extra arguments"
run_tc sb2_arg_pass "package" \
    "$(expect_args \
        -t "$DEFAULT_TARGET" rpmbuild --build-in-place --target= \
        --define 'noecho 1' \
        --define '_rpmdir /tmp/@TMPDIR@/RPMS' \
        --define '_sourcedir /tmp/@TMPDIR@/rpm' \
        --define '_rpmfilename %%{name}-%%{version}-%%{release}.%%{arch}.rpm' \
        --buildroot='/tmp/@TMPDIR@/installroot' \
        -bb --noprep --nobuildstage --noclean \
        /tmp/@TMPDIR@/.mb2/spec)" \
    package "a b" "c  d" e f

tear_down_ts sb2_arg_pass

################################################################################
# Test arguments passing to commands invoked by rpmbuild

rpmbuild_arg_pass_ts_set_up() {
    RPMBUILD_STUBS=(qmake make)
    arg_pass_stub_create "${RPMBUILD_STUBS[@]}"

    sb2_stub_create || return

    # Create a minimal spec file
    mkdir rpm || return
    cat >rpm/test.spec <<END || return
Name:       test

# These would normally come from the environment
%{!?qmake:%define qmake qmake}
%{!?qmake5:%define qmake5 qmake}

# This is to not require meego-rpm-config installed for self-test execution
%global __os_install_post %{nil}

Summary:    Test
Version:    0.1
Release:    1
Group:      Qt/Qt
License:    LICENSE
URL:        http://example.org/
Source0:    %{name}-%{version}.tar.bz2

%description
Test

%prep
%setup -q -n %{name}-%{version}

%build
%qmake5
make %{?_smp_mflags}

%install
mkdir -p %{buildroot}

%files
%defattr(-,root,root,-)
END
}

rpmbuild_arg_pass_ts_tear_down() {
    arg_pass_stub_remove "${RPMBUILD_STUBS[@]}" || return
    sb2_stub_remove || return
    rm -f rpm/test.spec || return
    rmdir rpm || return
}

rpmbuild_arg_pass_tc() {
    local all_expected=("${@:1:${#RPMBUILD_STUBS[*]}}")
    local args=("${@:1+${#RPMBUILD_STUBS[*]}}")

    local rc=0

    arg_pass_stub_clear "${RPMBUILD_STUBS[@]}"
    "$SELF" "${args[@]}" || return
    local i=
    for ((i=0; i<${#RPMBUILD_STUBS[@]}; i++)); do
        local stub= expected= actual= diff=
        stub=${RPMBUILD_STUBS[i]}
        expected=${all_expected[i]}
        actual=$(arg_pass_stub_results "$stub")
        if ! diff=$(diff <(cat <<<"$expected") <(cat <<<"$actual")); then
            rc=1
            cat <<END
Test case failed: $TC_NAME/$i
  ** Command    ** $ME $(printf "%q " "${args[@]}")
  ** Failed for ** $stub
  ** Mismatch   ** [[
$diff
]]
  ** Expected   ** [[
$expected
]]
  ** Actual     ** [[
$actual
]]
END
        fi
    done

    return $rc
}

set_up_ts rpmbuild_arg_pass "Passing arguments to commands invoked by rpmbuild"

run_tc rpmbuild_arg_pass "build" \
    "$(expect_args )" \
    "$(expect_args -j"$DEFAULT_JOBS")" \
    build

run_tc rpmbuild_arg_pass "qmake" \
    "$(expect_args "a b" "c  d" e f)" \
    "$(expect_args )" \
    qmake "a b" "c  d" e f

if [[ $DEFAULT_JOBS -ne 1 ]]; then
    run_tc rpmbuild_arg_pass "make" \
        "$(expect_args )" \
        "$(expect_args -j"$DEFAULT_JOBS" "a b" "c  d" e f)" \
        make "a b" "c  d" e f
else
    run_tc rpmbuild_arg_pass "make" \
        "$(expect_args )" \
        "$(expect_args "a b" "c  d" e f)" \
        make "a b" "c  d" e f
fi

tear_down_ts rpmbuild_arg_pass

################################################################################
# Test arguments passing to commands invoked using run|ssh subcommand

ssh_arg_pass_ts_set_up() {
    :
}

ssh_arg_pass_ts_tear_down() {
    :
}

ssh_arg_pass_tc() {
    local expected=$1
    local args=("${@:2}")

    local actual= diff=
    actual=$("$SELF" "${args[@]}")
    if ! diff=$(diff <(cat <<<"$expected") <(cat <<<"$actual")); then
        cat <<END
Test case failed: $TC_NAME
  ** Command    ** $ME $(quote "${args[@]}")
  ** Mismatch   ** [[
$diff
]]
  ** Expected   ** [[
$expected
]]
  ** Actual     ** [[
$actual
]]
END
        return 1
    fi
}

set_up_ts ssh_arg_pass "Passing arguments using run|ssh subcommand"

run_tc ssh_arg_pass "local - just spaces" \
    "$(printf '%q ' 'a b' 'c  d' e f)" \
    run printf '%q ' 'a b' 'c  d' e f

run_tc ssh_arg_pass "local - spaces and newlines" \
    "$(printf '%q'$'\n' 'echo b' 'c  d' e f)" \
    run printf '%q'$'\n' 'echo b' 'c  d' e f

run_tc ssh_arg_pass "local - spaces and backslashes" \
    "$(printf '%q\n' 'a\ b' 'c  d' e f)" \
    run printf '%q\n' 'a\ b' 'c  d' e f

if [[ $DEFAULT_DEVICE ]]; then
    run_tc ssh_arg_pass "remote - just spaces" \
        "$(printf '%q ' 'a b' 'c  d' e f)" \
        --device "$DEFAULT_DEVICE" run printf '%q ' 'a b' 'c  d' e f

    run_tc ssh_arg_pass "remote - spaces and newlines" \
        "$(printf '%q'$'\n' 'echo b' 'c  d' e f)" \
        --device "$DEFAULT_DEVICE" run printf '%q'$'\n' 'echo b' 'c  d' e f

    run_tc ssh_arg_pass "remote - spaces and backslashes" \
        "$(printf '%q\n' 'a\ b' 'c  d' e f)" \
        --device "$DEFAULT_DEVICE" run printf '%q\n' 'a\ b' 'c  d' e f
fi

tear_down_ts ssh_arg_pass

################################################################################
# Test --fix-version behavior

fix_version_ts_set_up() {
    COMMITS_U=()
    COMMITS_D=()

    get_commit() {
        eval echo \${COMMITS_${1:0:1}[${1:1}]} |grep .
    }

    local i= commit= tag_name= tag_object=

    git init . --quiet || return
    git config user.email "john@doe.com" || return
    git config user.name "John Doe" || return

    git checkout -b upstream --quiet
    for ((i=0; i<=30; i++)); do
        printf "U%02d\n" "$i" > U
        git add U || return
        date="@$(TZ=UTC date --date="2000-01-01 00:00:00 UTC +$i days" +%s) +0000"
        GIT_AUTHOR_DATE=$date GIT_COMMITTER_DATE=$date \
            git commit --message "$(<U)" --quiet || return
        commit=$(git rev-list --max-count=1 --abbrev-commit HEAD) || return
        COMMITS_U=(${COMMITS_U[*]:-} $commit)
    done

    git checkout -b downstream "${COMMITS_U[10]}" --quiet || return
    for ((i=0; i<=20; i++)); do
        if [[ $i -eq 10 ]]; then
            git merge --no-commit "${COMMITS_U[20]}" --quiet 2>/dev/null || return
        fi
        printf "D%02d\n" "$i" > D
        git add D || return
        date="@$(TZ=UTC date --date="2000-01-01 00:00:00 UTC +$((i+10)) days +12 hours" +%s) +0000"
        GIT_AUTHOR_DATE=$date GIT_COMMITTER_DATE=$date \
            git commit --message "$(<D)" --quiet || return
        commit=$(git rev-list --max-count=1 --abbrev-commit HEAD) || return
        COMMITS_D=(${COMMITS_D[*]:-} $commit)
    done

    while [[ ${1:-} ]]; do
        case $1 in
            --tag)
                tag_name=$2
                tag_object=$(get_commit $3) || return
                git tag "$tag_name" "$tag_object" || return
                shift 2
                ;;
            --tag-a)
                tag_name=$2
                tag_object=$(get_commit $3) || return
                tag_annotation="$3"
                git tag -a -m "$tag_annotation" "$tag_name" "$tag_object" || return
                shift 2
                ;;
            *)
                return 1
                ;;
        esac
        shift
    done
}

fix_version_ts_tear_down() {
    unset COMMITS_U COMMITS_D
    unset -f get_commit
    rm -rf .git || return
    rm -f U D dirty || return
}

fix_version_tc() {
    local dirty=$1 head=$2 expected_raw=$3 hint=${4:-}

    head=$(get_commit "$head") || return

    git reset --hard --quiet || return
    git checkout -B downstream "$head" --quiet || return
    if [[ $dirty == dirty ]]; then
        echo dirty >> D
    fi

    local version_file=version
    local last_stash_file=last_stash

    echo "Version:" > $version_file

    (
        git() (
            echo "stub invoked: git" >&2
            if [[ $1 == stash && $2 == create ]]; then
                date="@$(TZ=UTC date --date="2000-12-31 18:00:00 UTC" +%s) +0000"
                GIT_AUTHOR_DATE=$date GIT_COMMITTER_DATE=$date \
                    command git stash create |tee $last_stash_file
            else
                command git "$@"
            fi
        )

        OPT_FIX_VERSION=1
        OPT_FIX_VERSION_HINT=$hint
        OPT_NO_FIX_VERSION=
        fix_package_version $version_file >&2
    ) || return

    local actual=$(sed 's/^Version: //' $version_file)

    local stash_sha1=
    if [[ -e $last_stash_file ]]; then
        stash_sha1=$(git rev-list --max-count=1 --abbrev-commit "$(<$last_stash_file)")
    fi

    local expected=$expected_raw i=
    for ((i=0; i<=30; i++)); do
        expected=${expected//@U$i@/${COMMITS_U[$i]}}
    done
    for ((i=0; i<=20; i++)); do
        expected=${expected//@D$i@/${COMMITS_D[$i]}}
    done
    expected=${expected//@STASH@/${stash_sha1:-<none>}}

    if [[ $actual != "$expected" ]]; then
        cat <<END
Test case failed: $TC_NAME
  ** Arguments    ** $(printf "%q " "$@")
  ** Expected     ** '$expected'
  ** Actual       ** '$actual'
  ** Expected RAW ** '$expected_raw'
  ** Git-status   ** [[
$(git status)
]]
  ** Git-log      ** [[
$(git log --graph --decorate --pretty=fuller --all ${stash_sha1:-})
]]
END
        return 1
    fi
}

# Works with Git history like this
#
# U00---...---U10---U11---...---U20---U21---...---U30 <-- upstream
#               \                 \
#                D00---D01---...---D10---D11---...---D20 <-- downstream
#
# Upstream commit dates are 2000-01-01 + <num> days 00:00 UTC, downstream commit dates are
# 2000-01-01 + <num+10> days 12:00 UTC, stashes are 2000-12-31 18:00 UTC.

set_up_ts fix_version "Test --fix-version behavior" \
    --tag v0.1 U5 \
    --tag v0.2 U10 \
    --tag v0.3 U15 \
    --tag v0.4 U20 \
    --tag v0.5 U25 \
    --tag mer/v0.2+git1 D5 \
    --tag mer/v0.4+git1 D11 \
    --tag-a mer/v0.4+git2 D15 \
    --tag mer/v0.4+git3 D20

run_tc fix_version "on tag, clean D5"               clean D5  0.2+git1
run_tc fix_version "ahead tag, clean D7"            clean D7  0.2+git1+downstream.2000''01''18''12''00''00.@D7@
run_tc fix_version "ahead tag, dirty D7"            dirty D7  0.2+git1+downstream.2000''12''31''18''00''00.@STASH@
run_tc fix_version "ahead upstream tag, clean D10"  clean D10 0.4+downstream.2000''01''21''12''00''00.@D10@
run_tc fix_version "on tag, clean D11"              clean D11 0.4+git1
run_tc fix_version "on tag, dirty D11"              dirty D11 0.4+git1+downstream.2000''12''31''18''00''00.@STASH@
run_tc fix_version "ahead tag, clean D12"           clean D12 0.4+git1+downstream.2000''01''23''12''00''00.@D12@
run_tc fix_version "ahead tag, dirty D12"           dirty D12 0.4+git1+downstream.2000''12''31''18''00''00.@STASH@
run_tc fix_version "on annotated, clean D15"        clean D15 0.4+git2
run_tc fix_version "ahead annotated, clean D16"     clean D16 0.4+git2+downstream.2000''01''27''12''00''00.@D16@
run_tc fix_version "ahead annotated, dirty D16"     dirty D16 0.4+git2+downstream.2000''12''31''18''00''00.@STASH@
run_tc fix_version "on tag, clean D15 + hint"       clean D15 0.4+git1+downstream.2000''01''26''12''00''00.@D15@    mer/v0.4+git1
run_tc fix_version "on tag, dirty D15 + hint"       dirty D15 0.4+git1+downstream.2000''12''31''18''00''00.@STASH@  mer/v0.4+git1
run_tc fix_version "ahead tag, clean D16 + hint"    clean D16 0.4+git1+downstream.2000''01''27''12''00''00.@D16@    mer/v0.4+git1
run_tc fix_version "ahead tag, dirty D16 + hint"    dirty D16 0.4+git1+downstream.2000''12''31''18''00''00.@STASH@  mer/v0.4+git1

tear_down_ts fix_version

################################################################################
# Test the readarray behavior - simplified version implemented as a shell
# function for compatibility with older BASH

readarray_tc() {
    local expected=('  abc *  def  ' '  g  h  i  ')
    local actual=()
    echo "Note: readarray is a $(type -t readarray)" >&2
    readarray -t actual < <(printf "%s\n" "${expected[@]}")
    if ! (
        [[ ${#expected[*]} -eq ${#actual[*]} ]] || exit
        for ((i=0; i<${#expected[*]}; i++)); do
            [[ ${actual[$i]} == "${expected[$i]}" ]] || exit
        done
        ); then
        cat <<END
Test case failed: $TC_NAME
  ** Expected   ** [[
$(declare -p expected)
]]
  ** Actual     ** [[
$(declare -p actual)
]]
END
        return 1
    fi
}

run_tc readarray "Test readarray behavior"

################################################################################
# Test build phases separation

rpmbuild_phases_ts_set_up() {
    RPMBUILD_STUBS=(my_setup qmake make my_install my_check)
    arg_pass_stub_create "${RPMBUILD_STUBS[@]}"

    sb2_stub_create || return

    # Create a minimal spec file
    mkdir rpm || return
    cat >rpm/test.spec <<END || return
Name:       test

# These would normally come from the environment
%{!?qmake:%define qmake qmake}
%{!?qmake5:%define qmake5 qmake}

# This is to not require meego-rpm-config installed for self-test execution
%global __os_install_post %{nil}

Summary:    Test
Version:    0.1
Release:    1
Group:      Qt/Qt
License:    LICENSE
URL:        http://example.org/
Source0:    %{name}-%{version}.tar.bz2

%description
Test

%prep
my_setup

%build
%qmake5
make %{?_smp_mflags}

%install
mkdir -p %{buildroot}
my_install

# Verifies that --noclean is used
touch %{buildroot}/foo

%check
my_check

%files
%defattr(-,root,root,-)
/foo
END
}

rpmbuild_phases_ts_tear_down() {
    arg_pass_stub_remove "${RPMBUILD_STUBS[@]}" || return
    sb2_stub_remove || return
    rm -f rpm/test.spec || return
    rmdir rpm || return
    rm -f RPMS/test-0.1-1.i486.rpm || return
    ! [[ -d RPMS ]] || rmdir RPMS || return
    rm -f "$buildroot/foo" || return
}

rpmbuild_phases_tc() {
    local expected=$1
    local args=("${@:2}")

    arg_pass_stub_clear "${RPMBUILD_STUBS[@]}" || return
    rm -f RPMS/test-0.1-1.i486.rpm || return

    "$SELF" "${args[@]}" || return

    local actual=
    if arg_pass_stub_results my_setup &>/dev/null; then
        actual="+prepare"
    else
        actual="-prepare"
    fi

    if arg_pass_stub_results qmake &>/dev/null; then
        actual="$actual +qmake"
    else
        actual="$actual -qmake"
    fi

    if arg_pass_stub_results make &>/dev/null; then
        actual="$actual +make"
    else
        actual="$actual -make"
    fi

    if arg_pass_stub_results my_install &>/dev/null; then
        actual="$actual +make-install"
    else
        actual="$actual -make-install"
    fi

    if arg_pass_stub_results my_check &>/dev/null; then
        actual="$actual +check"
    else
        actual="$actual -check"
    fi

    if [[ -e RPMS/test-0.1-1.i486.rpm ]]; then
        if rpm -q --requires -p RPMS/test-0.1-1.i486.rpm |grep -q '^rpmlib(ShortCircuited)'; then
            actual="$actual +package (short-circuited)"
        else
            actual="$actual +package"
        fi
    else
        actual="$actual -package"
    fi

    if [[ $actual != "$expected" ]]; then
        cat <<END
Test case failed: $TC_NAME
  ** Command    ** $ME $(printf "%q " "${args[@]}")
  ** Expected   ** $expected
  ** Actual     ** $actual
END
        return 1
    fi

    return 0
}

set_up_ts rpmbuild_phases "Separating build phases"

run_tc rpmbuild_phases "prepare" \
    "+prepare -qmake -make -make-install -check -package" prepare
run_tc rpmbuild_phases "build" \
    "-prepare +qmake +make +make-install +check +package" build
run_tc rpmbuild_phases "build --doprep" \
    "+prepare +qmake +make +make-install +check +package" build --doprep
run_tc rpmbuild_phases "qmake" \
    "-prepare +qmake -make -make-install -check -package" qmake
run_tc rpmbuild_phases "make" \
    "-prepare -qmake +make -make-install -check -package" make
run_tc rpmbuild_phases "make-install" \
    "-prepare -qmake -make +make-install -check -package" make-install
run_tc rpmbuild_phases "package" \
    "-prepare -qmake -make +make-install +check +package" package

tear_down_ts rpmbuild_phases

################################################################################
# Test compatibility with various packaging options

# Accepts up to one argument - .pro file or a directory where to looks for a pro file. Defaults to
# current working directory. Creates Makefile that makes single file named after the TARGET name and
# installs it directly under the INSTALL_ROOT.
special_packaging_qmake_stub() {
    shopt -s nullglob
    if [[ $# -eq 0 ]]; then
        pro_files=(*.pro)
    elif [[ $# -eq 1 ]]; then
        if [[ $1 == *.pro ]]; then
            if [[ ! -e $1 ]]; then
                echo "stub qmake: file not found: $1" >&2
                return 1
            fi
            pro_files=($1)
        elif [[ -d $1 ]]; then
            pro_files=("$1"/*.pro)
        else
            echo "stub qmake: not a directory: $1" >&2
            return 1
        fi
    else
        echo "stub qmake: up to one argument expected" >&2
        return 1
    fi

    if [[ ${#pro_files[*]} -lt 1 ]]; then
        echo "stub qmake: no project file found" >&2
        return 1
    elif [[ ${#pro_files[*]} -gt 1 ]]; then
        echo "stub qmake: multiple project files found - select one" >&2
        return 1
    fi

    target=$(sed -n 's/^TARGET=//p' $pro_files)
    if [[ ! $target ]]; then
        echo "stub qmake: failed to parse project file '$pro_files'" >&2
        return 1
    fi

    cat >Makefile <<EOF
all:
	echo $target > $target

install:
	cp $target \$(INSTALL_ROOT)/$target
EOF
}

special_packaging_ts_set_up() {
    sb2_stub_create || return

    cat >"$STUBS_DIR/qmake" <<END || return
#!/bin/bash
$(declare -f special_packaging_qmake_stub)
special_packaging_qmake_stub "\$@"
END
    chmod +x "$STUBS_DIR/qmake" || return
}

special_packaging_ts_tear_down() {
    sb2_stub_remove || return
    rm -f "$STUBS_DIR/qmake" || return
}

# Accepts 7 arguments described inline
special_packaging_tc() {
    # SUBDIR: Put sources under subdirectory
    #   - N: No
    #   - Y: Yes, pass it to the %setup macro
    #   - NOSET: Yes, do not pass it to the %setup macro
    local maybe_subdir=$([[ $1 == Y || $1 == NOSET ]] && echo test)
    local maybe_setupdir=$([[ $1 == Y ]] && echo "/%{name}")

    # MULTI: Create multiple .spec and .pro files
    #   - Y/N
    local enable_multi=$([[ $2 == Y ]] && echo 1)

    # PATCH: Create .spec with patches
    #   - N: No
    #   - APPLY: Yes, use 'mb2 apply' to apply them
    #   - PREP: Yes, use 'mb2 prepare' to apply them
    #   - DOPREP: Yes, use 'mb2 build --doprep' to apply them
    local enable_patch=$([[ $3 == APPLY || $3 == PREP || $3 == DOPREP ]] && echo "$3")

    # SHADOW BUILD: Do shadow build
    #   - Y/N
    local enable_shadow=$([[ $4 == Y ]] && echo 1)

    # PROJECT IN SPEC: Pass .pro file to qmake call in the .spec file
    #   - Y/N
    local maybe_project_in_spec=
    if [[ $5 == Y ]]; then
        if [[ ! $maybe_subdir || $maybe_setupdir ]]; then
            maybe_project_in_spec=test.pro
        else
            maybe_project_in_spec=$maybe_subdir/test.pro
        fi
    fi

    # PROJECT ON CMDLN: Pass .pro file or directory on command line
    #   - N: No
    #   - FILE: Yes
    #   - DIR: Yes, pass the path to the subdirectory containing the .pro file
    #   - OTHER: Yes, pass other .pro file than used in the .spec
    local project_on_cmdln=
    case $6 in
        FILE) project_on_cmdln=${maybe_subdir:+$maybe_subdir/}test.pro;;
        DIR) project_on_cmdln=$maybe_subdir;;
        OTHER) project_on_cmdln=${maybe_subdir:+$maybe_subdir/}other.pro;;
    esac

    # AUTO SETUP: Use %autosetup
    #   - Y/N
    local setup_method="setup -q"
    local enable_patch_auto=
    local enable_patch_explicit=$enable_patch
    if [[ $7 == Y ]]; then
        local setup_method="autosetup"
        local enable_patch_auto=$enable_patch_explicit
        enable_patch_explicit=
    fi

    local srcdir=test
    local builddir=test

    local spec_arg=()
    if [[ $enable_multi ]]; then
        if [[ $enable_shadow ]]; then
            spec_arg=(--specfile ../test/rpm/test.spec)
        else
            spec_arg=(--specfile rpm/test.spec)
        fi
    fi

    if [[ $enable_shadow ]]; then
        if [[ $project_on_cmdln ]]; then
            project_on_cmdln=/$project_on_cmdln
        fi
        project_on_cmdln=../test$project_on_cmdln
        builddir=test-build
    fi

    mkdir -p "$srcdir" || return
    mkdir -p "$builddir" || return

    mkdir "$srcdir/rpm" || return
    cat >"$srcdir/rpm/test.spec" <<END || return
Name:       test

# These would normally come from the environment
%{!?qmake:%define qmake qmake}
%{!?qmake5:%define qmake5 qmake}
%{!?qmake5_install:%define qmake5_install make install INSTALL_ROOT=%{buildroot}}

# This is to not require meego-rpm-config installed for self-test execution
%global __os_install_post %{nil}

# Make it noop
%define setup echo

Summary:    Test
Version:    0.1
Release:    1
Group:      Qt/Qt
License:    LICENSE
URL:        http://example.org/
Source0:    %{name}-%{version}.tar.bz2
# rpmbuild applies patches in the order they appear here, ignoring their numbering
${enable_patch:+Patch1:  test-fix-1.patch}
${enable_patch:+Patch0:  test-fix-2.patch}

%description
Test

%prep
%${setup_method} -n %{name}-%{version}${maybe_setupdir}${enable_patch_auto+ -p1}
${enable_patch_explicit:+%patch1 -p1}
${enable_patch_explicit:+%patch0 -p1}

%build
%qmake5 ${maybe_project_in_spec}
make %{?_smp_mflags}

%install
mkdir -p %{buildroot}
%qmake5_install

%files
%defattr(-,root,root,-)
/foo${enable_patch:+-patched}
END

    mkdir -p "$srcdir/$maybe_subdir" || return
    echo TARGET=foo > "$srcdir/$maybe_subdir/test.pro" || return

    if [[ $enable_multi ]]; then
        touch "$srcdir/rpm/other.spec" || return
        mkdir -p "$srcdir/$maybe_subdir" || return
        echo TARGET=bar > "$srcdir/$maybe_subdir/other.pro" || return
    fi

    if [[ $enable_patch ]]; then
        cat >"$srcdir/rpm/test-fix-1.patch" <<END || return
--- a/test.pro
+++ b/test.pro
@@ -1 +1 @@
-TARGET=foo
+TARGET=foo-patched-xxx
END
        cat >"$srcdir/rpm/test-fix-2.patch" <<END || return
--- a/test.pro
+++ b/test.pro
@@ -1 +1 @@
-TARGET=foo-patched-xxx
+TARGET=foo-patched
END
    fi

    find -ls >&2

    (
        maybe_doprep=
        case $enable_patch in
            APPLY) (
                cd "$srcdir" || return
                echo "--- Preparing sources" >&2
                set -x
                "$SELF" ${spec_arg[@]:+"${spec_arg[@]}"} apply || return
                ) || return;;
            PREP) (
                cd "$srcdir" || return
                echo "--- Preparing sources" >&2
                set -x
                "$SELF" ${spec_arg[@]:+"${spec_arg[@]}"} prepare || return
                ) || return;;
            DOPREP)
                maybe_doprep=--doprep
                ;;
        esac

        (
            cd "$builddir" || return
            echo "--- Running build" >&2
            set -x
            "$SELF" ${spec_arg[@]:+"${spec_arg[@]}"} build ${maybe_doprep} ${project_on_cmdln:+"$project_on_cmdln"} || return
        ) || return

        rm -rf "$builddir"/{.mb2,RPMS,Makefile,foo} "$buildroot" || return

        (
            cd "$builddir" || return
            echo "--- Running qmake/make/package" >&2
            set -x
            "$SELF" ${spec_arg[@]:+"${spec_arg[@]}"} qmake ${project_on_cmdln:+"$project_on_cmdln"} || return
            "$SELF" ${spec_arg[@]:+"${spec_arg[@]}"} make || return
            "$SELF" ${spec_arg[@]:+"${spec_arg[@]}"} package || return
        ) || return
    )

    if [[ $? -ne 0 ]]; then
        cat <<END
Test case failed: $TC_NAME
END
        return 1
    fi

    return 0
}

special_packaging_tc_tear_down() {
    rm -rf "$buildroot" || return
    rm -rf ./test ./test-build || return
}

#   SUBDIR  MULTI  PATCH  SHADOW  PROJECT  PROJECT   AUTO
#                         BUILD   IN SPEC  ON CMDLN  SETUP

set_up_ts special_packaging "Compatibility / Flat package"
run_tc special_packaging "Basic" \
    N       N      N      N       N        N         N
run_tc special_packaging "Basic (shadow)" \
    N       N      N      Y       N        N         N
run_tc special_packaging "Pass .pro file in spec" \
    N       N      N      N       Y        N         N
run_tc special_packaging "Pass .pro file in spec (shadow)" \
    N       N      N      Y       Y        N         N
run_tc special_packaging "Pass .pro file on cmdline" \
    N       N      N      N       N        FILE      N
run_tc special_packaging "Pass .pro file in spec and on cmdline (shadow)" \
    N       N      N      Y       Y        FILE      N
tear_down_ts special_packaging

#   SUBDIR  MULTI  PATCH  SHADOW  PROJECT  PROJECT   AUTO
#                         BUILD   IN SPEC  ON CMDLN  SETUP

set_up_ts special_packaging "Compatibility / Flat package / Multiple configs"
run_tc special_packaging "Basic" \
    N       Y      N      N       Y        N         N
run_tc special_packaging "Basic (shadow)" \
    N       Y      N      Y       Y        N         N
run_tc special_packaging "Pass .pro file" \
    N       Y      N      N       Y        FILE      N
run_tc special_packaging "Pass .pro file (shadow)" \
    N       Y      N      Y       Y        FILE      N
run_tc special_packaging "Pass other .pro file" \
    N       Y      N      N       Y        OTHER     N
run_tc special_packaging "Pass other .pro file (shadow)" \
    N       Y      N      Y       Y        OTHER     N
tear_down_ts special_packaging

#   SUBDIR  MULTI  PATCH  SHADOW  PROJECT  PROJECT   AUTO
#                         BUILD   IN SPEC  ON CMDLN  SETUP

set_up_ts special_packaging "Compatibility / Flat package / With patches"
run_tc special_packaging "Use apply" \
    N       N      APPLY  N       N        N         N
run_tc special_packaging "Use apply (shadow)" \
    N       N      APPLY  Y       N        N         N
run_tc special_packaging "Use prepare" \
    N       N      PREP   N       N        N         N
run_tc special_packaging "Use prepare (shadow)" \
    N       N      PREP   Y       N        N         N
run_tc special_packaging "Use --doprep" \
    N       N      DOPREP N       N        N         N
tear_down_ts special_packaging

#   SUBDIR  MULTI  PATCH  SHADOW  PROJECT  PROJECT   AUTO
#                         BUILD   IN SPEC  ON CMDLN  SETUP

set_up_ts special_packaging "Compatibility / Flat package / With patches and %autosetup"
run_tc special_packaging "Use apply" \
    N       N      APPLY  N       N        N         Y
run_tc special_packaging "Use apply (shadow)" \
    N       N      APPLY  Y       N        N         Y
run_tc special_packaging "Use prepare" \
    N       N      PREP   N       N        N         Y
run_tc special_packaging "Use prepare (shadow)" \
    N       N      PREP   Y       N        N         Y
run_tc special_packaging "Use --doprep" \
    N       N      DOPREP N       N        N         Y
tear_down_ts special_packaging

#   SUBDIR  MULTI  PATCH  SHADOW  PROJECT  PROJECT   AUTO
#                         BUILD   IN SPEC  ON CMDLN  SETUP

set_up_ts special_packaging "Compatibility / Subtree package"
run_tc special_packaging "Basic" \
    Y       N      N      N       N        N         N
run_tc special_packaging "Basic (shadow)" \
    Y       N      N      Y       N        N         N
run_tc special_packaging "Pass .pro file" \
    Y       N      N      N       N        FILE      N
run_tc special_packaging "Pass .pro file (shadow)" \
    Y       N      N      Y       N        FILE      N
run_tc special_packaging "Pass .pro dir" \
    Y       N      N      N       N        DIR       N
run_tc special_packaging "Pass .pro dir (shadow)" \
    Y       N      N      Y       N        DIR       N
tear_down_ts special_packaging

#   SUBDIR  MULTI  PATCH  SHADOW  PROJECT  PROJECT   AUTO
#                         BUILD   IN SPEC  ON CMDLN  SETUP

set_up_ts special_packaging "Compatibility / Subtree package / Without %setup subdir"
run_tc special_packaging "Basic" \
    NOSET   N      N      N       Y        N         N
run_tc special_packaging "Basic (shadow)" \
    NOSET   N      N      Y       Y        N         N
run_tc special_packaging "Pass .pro file" \
    NOSET   N      N      N       Y        FILE      N
run_tc special_packaging "Pass .pro file (shadow)" \
    NOSET   N      N      Y       Y        FILE      N
run_tc special_packaging "Pass .pro dir" \
    NOSET   N      N      N       Y        DIR       N
run_tc special_packaging "Pass .pro dir (shadow)" \
    NOSET   N      N      Y       Y        DIR       N
tear_down_ts special_packaging

#   SUBDIR  MULTI  PATCH  SHADOW  PROJECT  PROJECT   AUTO
#                         BUILD   IN SPEC  ON CMDLN  SETUP

set_up_ts special_packaging "Compatibility / Subtree package / Multiple configs"
run_tc special_packaging "Basic" \
    Y       Y      N      N       Y        N         N
run_tc special_packaging "Basic (shadow)" \
    Y       Y      N      Y       Y        N         N
run_tc special_packaging "Pass .pro file" \
    Y       Y      N      N       Y        FILE      N
run_tc special_packaging "Pass .pro file (shadow)" \
    Y       Y      N      Y       Y        FILE      N
run_tc special_packaging "Pass .pro dir" \
    Y       Y      N      N       Y        DIR       N
run_tc special_packaging "Pass .pro dir (shadow)" \
    Y       Y      N      Y       Y        DIR       N
run_tc special_packaging "Pass other .pro file" \
    Y       Y      N      N       Y        OTHER     N
run_tc special_packaging "Pass other .pro file (shadow)" \
    Y       Y      N      Y       Y        OTHER     N
tear_down_ts special_packaging

#   SUBDIR  MULTI  PATCH  SHADOW  PROJECT  PROJECT   AUTO
#                         BUILD   IN SPEC  ON CMDLN  SETUP

set_up_ts special_packaging "Compatibility - Subtree package / With patches"
run_tc special_packaging "Use apply" \
    Y       N      APPLY  N       N        N         N
run_tc special_packaging "Use apply (shadow)" \
    Y       N      APPLY  Y       N        N         N
run_tc special_packaging "Use prepare" \
    Y       N      PREP   N       N        N         N
run_tc special_packaging "Use prepare (shadow)" \
    Y       N      PREP   Y       N        N         N
run_tc special_packaging "Use doprep" \
    Y       N      DOPREP N       N        N         N
tear_down_ts special_packaging

#   SUBDIR  MULTI  PATCH  SHADOW  PROJECT  PROJECT   AUTO
#                         BUILD   IN SPEC  ON CMDLN  SETUP

set_up_ts special_packaging "Compatibility - Subtree package / With patches and %autosetup"
run_tc special_packaging "Use apply" \
    Y       N      APPLY  N       N        N         Y
run_tc special_packaging "Use apply (shadow)" \
    Y       N      APPLY  Y       N        N         Y
run_tc special_packaging "Use prepare" \
    Y       N      PREP   N       N        N         Y
run_tc special_packaging "Use prepare (shadow)" \
    Y       N      PREP   Y       N        N         Y
run_tc special_packaging "Use doprep" \
    Y       N      DOPREP N       N        N         Y
tear_down_ts special_packaging

################################################################################
# Test the match_multi function

match_multi_ts_set_up() {
    :
}

match_multi_ts_tear_down() {
    :
}

match_multi_tc() {
    local match_name=$1 no_match_name=$2 patterns=("${@:3}")

    local rc=0 problems=()

    if [[ $match_name ]] && ! match_multi "$match_name" ${patterns:+"${patterns[@]}"}; then
        rc=1
        problems+=("Not matched while it should")
    fi

    if [[ $no_match_name ]] && match_multi "$no_match_name" ${patterns:+"${patterns[@]}"}; then
        rc=1
        problems+=("Matched while it should not")
    fi

    if [[ $rc != 0 ]]; then
        cat <<END
Test case failed: $TC_NAME
END
        printf '    %s\n' "${problems[@]}"
    fi

    return $rc
}

set_up_ts match_multi "Test match_multi"
run_tc match_multi "No filter" foobar ""
run_tc match_multi "Implicit inclusion only" foobar doobar "foo*"
run_tc match_multi "Explicit inclusion only" foobar doobar "+foo*"
run_tc match_multi "Explicit exclusion only" foobar doobar "-doo*"
run_tc match_multi "Override exclusion" foobar doobar "-*bar" "foo*"
run_tc match_multi "Override inclusion" foobar doobar "*bar" "-doo*"
run_tc match_multi "Override exclusion later" foobar doobar "-*bar" "zoo*" "foo*"
run_tc match_multi "Override inclusion later" foobar doobar "*bar" "zoo*" "-doo*"
run_tc match_multi "Extglob" foobar doobar "foo@(bar|baz)"
tear_down_ts match_multi

################################################################################
# Test find_latest_rpms

make_test_package() {
    local name=$1 version=$2 release=$3

    # Create a minimal spec file
    mkdir -p rpm || return
    cat >rpm/test.spec <<END || return
Name:       ${name}

# This is to not require meego-rpm-config installed for self-test execution
%global __os_install_post %{nil}

Summary:    Test
Version:    ${version}
Release:    ${release}
Group:      Qt/Qt
License:    LICENSE
URL:        http://example.org/
Source0:    %{name}-%{version}.tar.bz2

%description
Test

%build

%install
mkdir -p %{buildroot}
touch %{buildroot}/foo

%files
%defattr(-,root,root,-)
/foo
END
    # Set output-dir explicitly to prevent removal of previously built packages
    mkdir -p RPMS || return
    "$SELF" --output-dir RPMS build || return
}

find_latest_rpms_tc() {
    sb2_stub_create || return

    make_test_package "test1" "1.2.3" "1" || return
    make_test_package "test1" "1.2.3+jb12345.20200202202020.deadbeef" "1" || return
    make_test_package "test1" "1.2.3+jb12345.20200222222222.beefbabe" "1" || return
    make_test_package "test2" "3.2.1" "1" || return
    make_test_package "test2" "3.3" "1" || return

    local expected=$(cat <<END
RPMS/test1-1.2.3+jb12345.20200222222222.beefbabe-1.i486.rpm
RPMS/test2-3.3-1.i486.rpm
END
)
    local actual=
    actual=$(set +o nounset; find_latest_rpms "RPMS") || return

    if [[ $actual != "$expected" ]]; then
        cat <<END
Test case failed: $TC_NAME
  ** Expected   ** [[
$expected
]]
  ** Actual     ** [[
$actual
]]
END
        return 1
    fi

    return 0
}

find_latest_rpms_tc_tear_down() {
    sb2_stub_remove || return
    rm -f rpm/test.spec || return
    rmdir rpm || return
    rm -f RPMS/test1-1.2.3-1.i486.rpm || return
    rm -f RPMS/test1-1.2.3+jb12345.20200202202020.deadbeef-1.i486.rpm || return
    rm -f RPMS/test1-1.2.3+jb12345.20200222222222.beefbabe-1.i486.rpm || return
    rm -f RPMS/test2-3.2.1-1.i486.rpm || return
    rm -f RPMS/test2-3.3-1.i486.rpm || return
    ! [[ -d RPMS ]] || rmdir RPMS || return
    rm -f "$buildroot/foo" || return
}

run_tc find_latest_rpms "Test find_latest_rpms"

################################################################################

if [[ $tc_failed_num -eq 0 ]]; then
    echo "*** All $tc_num tests passed"
else
    echo "*** $tc_failed_num out of $tc_num failed"
fi

# For Emacs:
# Local Variables:
# indent-tabs-mode:nil
# tab-width:4
# mode: sh
# End:
# For VIM:
# vim:set softtabstop=4 shiftwidth=4 tabstop=4 expandtab:
