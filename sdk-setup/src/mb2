#!/bin/bash
#
# Copyright (C) 2013 - 2020 Jolla Ltd.
# Copyright (C) 2019 - 2020 Open Mobile Platform LLC.
# Contact: http://jolla.com/
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
#
# - Redistributions of source code must retain the above copyright
#   notice, this list of conditions and the following disclaimer.
# - Redistributions in binary form must reproduce the above copyright
#   notice, this list of conditions and the following disclaimer in
#   the documentation and/or other materials provided with the
#   distribution.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.

shopt -s extglob

synopsis() {
    cat <<EOF
usage: $ME [global-opts] <command> [command-opts]
       $ME --version
EOF
}

short_usage() {
    synopsis
    cat <<EOF

Try '$ME --help' for more information.
EOF
    # exit if any argument is given
    [[ -n "$1" ]] && exit 1
}

usage() {
    less --quit-if-one-screen <<EOF
$(synopsis)

Executes all or a subset of build commands in the context of an rpmbuild.

<specfile> will be looked for in the current rpm/ dir. If there is more than
one it must be provided.  $ME is aware of spectacle and will update the spec
file if there is an obvious yaml file which is newer.


SHADOW BUILDS

CWD is used as a base dir for installroot/ and RPMS/ to allow for shadow
builds. Shadow builds can be done by passing project file or directory path to
the "build" or "qmake" (or "cmake") command:

    $ mkdir build && cd build
    $ mb2 build ../path/to/sources

    Or manually invoking each step:

    $ mkdir build && cd build
    $ mb2 qmake ../path/to/sources
    $ mb2 make
    $ mb2 package

Limitations related to shadow builds:

    1. Shadow build is only available for packages that use qmake (or CMake or
       GNU Automake).  Additionally, their build and install procedure must be
       fully realized using qmake (or CMake or GNU Automake) with no
       additional steps implemented at .spec level.
    2. The "--doprep" option to the "build" command cannot be used with shadow
       builds.
    3. If "prepare" or "apply" is needed, it must be used directly on the
       source tree prior to starting a shadow build (shadow builds for
       multiple targets are still possible provided that the %prep section is
       target-independent).
    4. GNU Automake, Autoconf and related tools, in case of packages that
       invoke these at build time, still store their outputs (Makefile.in,
       configure, etc.) under the source tree.


SHARED OUTPUT DIRECTORY

With shared output directory, it is possible to deploy all required packages
built from different sources more conveniently. This can be achieved with the
'--output-dir' option or even better with the combination of '--output-prefix'
and '--task' options.  Consider enabling '--output-prefix' and '--task' by
default by creating an alias in your '~/.mersdk.profile' to get build results
grouped by the tasks they are related to.  By default, the task will be
determined based on the current Git branch - check the '--task' option
description for more details:

    alias mb2='mb2 --output-prefix ~/RPMS --task'

    cd packageA
    git checkout -b bugXXXXX
    mb2 -t target build
    cd ../packageB
    git checkout -b bugXXXXX
    mb2 -t target build

    ls -1 ~/RPMS/bugXXXXX/my-target/
    mb2 -t target -d device deploy --manual --all \\
        && ssh device sudo zypper -p RPMS -v dup

With these options the output directory is also searched for build-time
dependencies by default, so if packageB requires packageA at build time, you
do not need to install packageA manually to the build target.

Note that it can be usefull to also pass '--from ~plus-repo-1' to 'zypper dup'.


CLEAN BUILDS

It is possible to avoid polluting build targets with build time dependencies
of a particular package by using the '--snapshot' option. With this option the
build target is not used directly. Instead a snapshot is taken and the build
is done using the snapshot of the build target. See '--snapshot' for details
on how the snapshot is chosen.

The snapshot will be reset automatically whenever the original build target is
updated, so if e.g. a locally built package is needed as a build-time
dependency, instead of installing it manually you should rely on the above
mentioned fact that with custom output directory the '--search-output-dir'
option is implied, and combine the '--snapshot' option with the
'--output-prefix' option.

For similar reasons, when mb2 fails to install build-time dependencies due to
errors like "file not found on the server", .i.e., because the local
repository cache got outdated, it is the original target that should be
updated, not the snapshot.

Consider enabling '--snapshot' by default as well:

    alias mb2='mb2 --output-prefix ~/RPMS --task --snapshot'

In order to ensure targets are not polluted by running mb2 without
'--snapshot' unintentionally, mb2 requires to use '--no-snapshot' explicitly
once at least one snapshot exists for a target.  Existing snapshots can be
listed and removed using 'sdk-assistant'.


QUALITY ASSURANCE

Certain quality checks may be performed with the help of the 'check' command:

    cd package
    mb2 build
    mb2 check

The command enables execution of (pluggable) test suites, each realizing
testing on one or more of the four recognized test levels:

    1. Static testing (verification) performed on the source tree

    2. Static testing (verification) performed on the build results (packages)

    3. Dynamic testing (validation) performed at build host (unit testing)

       Testing at this level is only supported with the built-in suite
       'rpmspec', that executes the steps defined by the '%check' section of
       the RPM .spec file if present.

       Testing at this level is normally performed by the 'build' and
       'package' commands (unless used with the '--no-check' option) and so it
       is not enabled by default for this command. Performed with this
       command, it involves execution of the 'make-install' command.

    4. Dynamic testing (validation) performed on a target device (system testing)

       The 'check' command does not include the deployment step. Package(s)
       need to be deployed to the device selected with the 'device'
       configuration option beforehand, possibly with the 'deploy' command in
       case of packages associated with the build tree under CWD.

The available test suites may be listed with the '--list-suites' option to the
'check' command.

See the 'check' command to learn how to override the default selection of test
levels, suites and artefacts.


MAINTAINING CHANGELOGS

If a file exists with '.changes' extension, otherwise matching the
spec file name, the effect will be the same as having a %changelog
section in the spec file.  If a file with '.changes.run' extension is
found instead, this file will be executed and its output treated as
the actual changelog.

COMMANDS
    build-requires [--[no-]refresh] {pull|reset}
        When 'pull' is used, install or update the build-time dependencies as
        is done implicitly by the 'prepare', 'build' and 'qmake' (or 'cmake')
        commands but refresh the package cache first, unless '--no-refresh' is
        active.

        When the global '--snapshot' option is used, '--no-refresh' is
        implied.  This can be overriden with '--refresh' - do not use unless
        you know what you are doing. If refresh is needed, refresh (and
        update) the original target instead.

        The 'reset' command can only be used together with the '--snapshot'
        global option, with the effect of reseting the target snapshot
        forcefully to the (possibly updated) state of the original target
        first, pulling later.

    prepare
        Run rpmbuild. Execute just the %prep section of the .spec file.

    apply [-R]
        Apply all patches defined in the .spec file to the source tree.

        -R    reverse apply patches (patch -R)

    build [-p|--prepare] [--no-check] [-d|--enable-debug] [-j <n>]
          [<project-dir-or-file>] [[--] <rpmbuild-extra-arg>...]
        Run rpmbuild. Execute all sections of the .spec file except for %prep
        unless told otherwise.

        If path to a <project-dir-or-file> is passed, shadow build will be
        done. Otherwise the current working directory is treated as the
        project directory. (The file name part is ignored - project file
        selection is done by qmake call inside the .spec file.)

        --prepare         Run %prep section as well
        --no-check        Skip the %check section
        --enable-debug    Enable debug build
        -j <n>            Run up to <n> jobs simultaneously

    qmake [<project-dir-or-file>] [[--] <qmake-extra-arg>...]
        Run rpmbuild. Execute just the %build section of the .spec file,
        suppressing any 'make' invocation figuring in that section.

        If path to a <project-dir-or-file> is passed, shadow build will be
        done. Otherwise the current working directory is treated as the
        project directory. (The file name part is ignored - project file
        selection is done by qmake call inside the .spec file.)

    cmake [<project-dir>] [[--] <cmake-extra-arg>...]
    cmake --build . [<cmake-extra-arg>...] [-- <build-tool-extra-arg>...]
        Run rpmbuild. Execute just the %build section of the .spec file,
        suppressing any 'cmake' invocation figuring in that section, that does
        not match the execution form used here, i.e., does not trigger the
        desired action, namely 1) generate a project buildsystem or
        2) build the project.

        Additionally, any plain 'make' invocation will be recognized as
        implementing the 'build the project' action and will be treated
        accordingly. Any possible <cmake-extra-arg> will be silently ignored
        and any possible <build-tools-extra-arg> will be used equally for
        each 'make' invocation in that case.

        If path to a <project-dir> is passed, shadow build will be done.
        Otherwise the current working directory is treated as the project
        directory.

    make [<make-extra-arg>...]
        Run rpmbuild. Execute just the %build section of the .spec file,
        suppressing any command figuring in that section, that is recognized
        as a command to generate project buildsystem. The following is a
        complete list of such commands:

        - any 'qmake' invocation
        - any 'cmake' invocation using the corresponding execution form

        For CMake based projects the 'make <make-extra-arg>...' command is
        equivalent to 'cmake --build . -- <make-extra-arg>...' (provided that
        'make' is the build tool used by the project).

    make-install
        Run rpmbuild. Execute just the %install section of the .spec file.

    package [--no-check]
        Run rpmbuild. Execute just the %install section of the .spec file, then
        build binary packages. Unless '--no-check' is passed, execute also the
        %check section if present.

    build-shell [<command> [<arg>...]]
        Execute an arbitrary <command> in the build environment.  If no
        <command> is specified, an interactive shell is opened.

    compiledb [<make-extra-arg>...]
        Run rpmbuild. Execute just the %build section of the .spec file,
        modifying any 'make' invocation figuring in that section in order to
        generate Clang's JSON Compilation Database file
        'compile_commands.json' as described below.

        Unless the (top-level) makefile defines a target named 'compiledb' or
        'compile_commands.json', 'make' will be wrapped with the 'compiledb'
        tool as the default option to generate the compilation database.

        A custom mechanism to generate the compilation database may be
        supplied by defining one of the above mentioned targets. In that case
        'make' will be invoked with command line modified by adding that
        target name and removing any other target-like argument. (Any
        non-option, non-assignment argument will be removed.  Options that
        accept arguments need to be sticked together with their arguments with
        '='.)

    check --list-suites
    check [-l|--levels [+|-]<level>...] [-s|--suites [+|-]<suite>...]
          [<artefact>...]
        Perform quality checks.

        By default, test suites operate on the artefacts associated with build
        tree under CWD. Alternatively, single path to a source tree and/or one
        or more package files may be specified as <artefact> on command line
        (build tree is always looked for under CWD).

        Each test suite realizes testing on one or more of the four recognized
        test levels. This is indicated in the output produced with the
        '--list-suites' option, using the keywords found in the first column
        of the following table.

        | Level          | Tested art. | Executed at   | Default |
        |----------------+-------------+---------------+---------|
        |    static      |             |               |         |
        | 1. ├── source  | Sources     | Build host    | +       |
        | 2. └── package | Packages    | Build host    | +       |
        |    dynamic     |             |               |         |
        | 3. ├── unit    | Build tree  | Build host    | -       |
        | 4. └── system  | Packages    | Target device | -       |

        (See also QUALITY ASSURANCE above.)

        -l, --levels [+|-]<level>...
            Select testing levels. Levels are selected using the keywords
            'source', 'package', 'static', 'unit', 'system' and 'dynamic' as
            described before. The default selection is indicated in the above
            table and can be overriden with the global option
            '--check-levels'.

        --list-suites
            List available test suites.

        -s, --suites [+|-]<suite>...
            Select test suites to use. By default all and only the essential
            suites are selected. See '--list-suites'. The default selection
            may be overriden with the global option '--check-suites'.

        The '--levels' and '--suites' options may be passed multiple values,
        separated with comma. If a name is prefixed with '+' or '-', the
        effect is cumulative and persists until overriden with later name
        prefixed with the opposite operator.

    deploy {--pkcon|--rsync|--sdk|--zypper|--manual} [--all] [--debug]
           [--] [[+|-]<pattern>...]
        Deploy build results to a device.

        By default, just the build results of the project under current working
        directory will be deployed. When a shared output directory is used (see
        '--output-dir' and '--output-prefix'), the option '--all' can be used to
        require deployment of all packages found under the output directory, no
        matter of their origin. The '--all' option is not available when the
        '--rsync' method is used.

        Selection of (sub)packages for deployment can be influenced with glob
        <pattern>s, each of which may be preceded with '+' or '-' to opt for
        either inclusion (default) or exclusion respectively as the desired
        effect. Later specified patterns may override earlier ones.  Extended,
        Bash-compatible patterns are allowed.  The '-*-debug@(info|source)'
        pattern is implied unless the '--debug' option is used.  Options must
        precede patterns if any.

        The following deployment methods are available, corresponding to the
        mandatory option:

        --pkcon
            Uses 'pkcon' to install RPM package(s). Requires the "Allow
            untrusted software" option enabled in Settings, does not require
            root access to the device.

        --rsync
            This method is special.  Uses 'rsync' to copy the installed files
            under '/opt/sdk/<name>' without building/installing RPM package(s).
            Does not require root access to the device.  Incompatible with
            '--all'.

        --sdk
            Uses the method native to the SDK to install RPM package(s).
            Requires developer mode enabled on the device, does not require
            root access.

        --zypper
            Uses 'zypper' to install RPM package(s).  Requires 'zypper'
            installed on the device, requires root access to the device.

        --manual
            Only transfers the RPM package(s) to the device for manual
            installation. Uses '~/RPMS' as the target directory on the device.

        When used via Qt Creator, this command implies also the "make-install"
        and "package" commands unless the '--all' option or '--rsync' method is
        used.

    undeploy {--sdk|--pkcon|--rpm|--rsync|--zypper} [--all] [-n|--dry-run]
             [--] [[+|-]<pattern>...]
        Undeploy build results previously deployed to a device.

        Initially, device packages are collected based on the build host name
        recorded in their metadata.  Just those packages that seem to
        originate from the host where mb2 is running will be considered for
        removal from the device.  For that it is vital that the host name is
        stable and unique among the host names recorded by packages installed
        from other sources.

        Further, unless the '--all' option is used, just the build results of
        the project under current working directory will be considered for
        removal from the device.  When the '--all' option is used, any build
        results originated from this build host will be considered.  (Note how
        the effect of '--all' differs between 'deploy' and 'undeploy'.)

        Package origin is determined based on the build host name recorded in
        its metadata.  For that it is vital that 1) the build host name has
        not changed since the time the packages were built and that 2) the
        build host name is unique among the host names recorded by packages
        installed from other sources.  See the 'engine' command to learn more
        about the build host name.

        With the '--dry-run' option, the list of (sub)packages that would be
        removed may be previewed without applying the changes.

        If needed, the selection can be furthermore adjusted with glob
        <pattern>s, each of which may be preceded with '+' or '-' to opt for
        either inclusion (default) or exclusion respectively as the desired
        effect.  Later specified patterns may override earlier ones.
        Extended, Bash-compatible patterns are allowed.  Options must precede
        patterns if any.

        Except for the '--rsync' method, the selected method is not required to
        match the method previously used with the 'deploy' command.

        The following methods of undeployment are available, corresponding to
        the mandatory option:

        --pkcon
            Uses 'pkcon' to remove RPM package(s).  Requires the "Allow
            untrusted software" option enabled in Settings, does not require
            root access to the device.

        --rpm
            Uses plain 'rpm' to remove RPM package(s).  Requires root access
            to the device.

        --rsync
            This method is special.  It does not work with RPM packages.  It
            is only capable to remove files previously copied under
            '/opt/sdk/' with 'deploy --rsync'.  With this method, the origin
            of the data is not taken into consideration.  Does not require
            root access to the device.

        --sdk
            Uses the method native to the SDK to remove RPM package(s).
            Requires developer mode enabled on the device, does not require
            root access. Not available with older devices.

        --zypper
            Uses 'zypper' to remove RPM package(s).  Requires 'zypper'
            installed on the device, requires root access to the device.

    run [<command> [<arg>...]]
        Run the given command on the device specified with '--device'.  Can be
        used for running gdb and a gdb server.

GLOBAL OPTIONS
    The order of passing options matters. Options that occur later on the
    command line may override earlier options, including those implied by
    the earlier options.

    -i, --increment
        Increment release number in .spec file

    -t, --target <name>
        Specify the sb2 target to use

    -d, --device <name>
        Specify the device

    -o, --output-dir <dir>
        Defaults to './RPMS'. The resulting RPM packages will be placed
        directly under the specified <dir>. With this option existing files in
        the output directory are preserved.  Implies '--search-output-dir'

    -O, --output-prefix <dir>
        Much like '--output-dir' except that a subdirectory of the given <dir>
        will be used, denoted by the build target name (see '--target'). When
        the '--task' option is active, output directories will be further
        grouped by task name ('<dir>/[<task>/]<target>').

    --search-output-dir[={verbose|quiet}]
        Consider the RPM packages found in the output directory when installing
        build time dependencies. The optional value controls zypper verbosity.
        The default is 'verbose'.

    --no-search-output-dir
        Override '--search-output-dir' option

    -s, --specfile <file>
        Specify the .spec file

    -S, --snapshot[=<suffix>]
        Avoid installing build-time dependencies to the sb2 target - use a
        snapshot of that target instead.

        The snapshot name will be determined by combining the original target
        name with the given <suffix>. Any occurence of '%{task}' within the
        <suffix> will be substituted with the name specified with the '--task'
        option or with an empty string if the '--task' option is not used.
        When no suffix was specified or when the substitution yields an empty
        string, a temporary snapshot will be used (these have ".mb2." followed
        by random character sequence in their names).

        Snapshot state is preserved across mb2 invocations unless the original
        target was updated meanwhile or it is a temporary snapshot that was
        previously used with different build tree, in which cases the snapshot
        will be reset. Snapshot can be reset forcefully using the
        'build-requires reset' command.

    --no-snapshot
        Force mb2 to directly use a target for which snapshots exist.

    -f, --shared-folder <dir>
        The folder where QtCreator shares devices.xml and ssh keys. This option
        is useful when the deploy command is used outside of virtual machine.

    -T, --task[=<name>|=git:<regex>]
        Modifies behavior of '--output-prefix' and '--snapshot' options.
        The task name can be specified either directly as <name> or it can be
        derived from the current Git branch name, using the POSIX extended
        regular expression <regex> both as a condition to enable this option
        and as a mean to select substring of the branch name to be used as
        the task name.  Defaults to '$DEF_TASK'.
        The default expression is suitable to look for a leading bug reference
        in the branch name.  E.g. 'bug1234' in 'bug1234-quickfix'.

    --no-task
        Override --task option

    --wrap <command>:<wrapper>
        Instruct rpmbuild to use the given <wrapper> as a replacement for the
        <command>. <command> must be a valid file name, without directory part
        while <wrapper> must be specified as an absolute file path.

    -x, --fix-version[=<tag>]
        This option is implied when used inside a Git working tree (use -X to
        override). When used via Qt Creator, it is only implied if the version
        recorded in the .spec file is exactly "0".

        With this option the version recorded in the .spec file will be
        ignored.  Instead, package version will be derived from the name of the
        latest tag in the current git branch or the selected tag <tag>.

        If the current HEAD, index or working tree differs from the tree
        denoted by the (latest or selected) tag, a suffix composed from the
        current branch name, time stamp and a commit SHA1 will be added to the
        package version. If git-state is not clean a git-stash will be created
        and its SHA1 will be used.

        It is recommended to store 'Version: 0' and 'Release: 1' in the .spec
        file when this option is to be used; as a sign that the version
        recorded there is not relevant.

    -X, --no-fix-version
        Override --fix-version option.

    -n, --no-pull-build-requires
        Do not update build-time dependencies unless required explicitly with
        'build-requires pull'.

    -c, --git-change-log[=<args>]
        Include change log generated from Git history with 'git-change-log'
        command, forwarding any <args>.  This option is not intended for
        regular use - create a script file named after the .spec file but with
        '.changes.run' extension to instruct $ME to generate changelog with
        'git-change-log <args>' instead.

    --check-levels [+|-]<level>...
        Override the default test levels the 'check' command operates on. See
        the '--levels' option to the 'check' command for more details.

    --check-suites [+|-]<suite>...
        Override the default test suites the 'check' command executes. See
        the '--suites' option to the 'check' command for more details.


KNOWN ISSUES

Build target snapshot is not reset automatically when the original target is
changed just by removing packages via plain RPM usage. Either use zypper for
all package operations or use 'mb2 build-requires reset' to ensure snapshot is
reset.
EOF
}

notice() {
    echo "NOTICE: $*" >&2
}

fatal() {
    echo "Fatal: $*" >&2
    exit 1
}

# readarray is a bash >= 4.0 feature
if ! type readarray &>/dev/null; then
    readarray() {
        if ! [[ $# -eq 2 && $1 == -t && $(declare -p "$2" 2>/dev/null) == "declare -a "* ]]; then
            fatal "Internal error: readarray: unimplemented case"
        fi

        local line=
        eval $2=\(\)
        while IFS= read -r line; do
            eval $2=\(\${$2[@]:+\"\${$2[@]}\"} \"\$line\"\)
        done
    }
fi

set_insert() {
    eval local set=(\${$1[*]})
    local item=$2

    set=$(IFS=$'\n'; sort -u <<<"${set[*]}$IFS$item")

    eval $1=\(\$set\)
}

set_remove() {
    eval local set=(\${$1[*]})
    local item=$2

    set=$(IFS=$'\n'; grep --line-regexp -v -F "$item" <<<"${set[*]}")

    eval $1=\(\$set\)
}

set_intersect() {
    eval local set1=(\${$2[*]})
    eval local set2=(\${$3[*]})
    local out=()

    set1=$(IFS=$'\n'; sort <<<"${set1[*]}")
    set2=$(IFS=$'\n'; sort <<<"${set2[*]}")

    out=$(join <(cat <<<"$set1") <(cat <<<"$set2"))

    eval $1=\(\$out\)
}

# Usage: set_update <set> [+-]<item>...
#
# Update the set with the given items. If no item is prefixed with '+' or '-' it
# will simply replace the content of the set. The effect of '+' and '-' persists
# until overriden with later item prefixed with the opposite operator.
set_update() {
    eval local set=(\${$1[*]})
    local items=("${@:2}")

    local op= item=
    for item in "${items[@]}"; do
        if [[ $item == [+-]* ]]; then
            op=${item:0:1}
            item=${item:1}
        fi
        case $op in
            # TODO with Bash 4 reimplement set_insert and set_remove so that they can be used here
            +) set=($(IFS=$'\n'; sort -u <<<"${set[*]}$IFS$item"));;
            -) set=($(IFS=$'\n'; grep --line-regexp -v -F "$item" <<<"${set[*]}"));;
            '')
                set=($item)
                op=+
                ;;
        esac
    done

    eval $1=\(\${set[*]}\)
}

set_contains() {
    eval local set=(\${$1[*]})
    local item=$2

    [[ " ${set[*]} " == *" $item "* ]]
}

# Combine two recipes in form of comma separated list of "[+-]<item>" items
combine_set_update_recipes() {
    local recipe1=$1
    local recipe2=$2

    if [[ ! $recipe2 ]]; then
        printf '%s' "$recipe1"
    elif [[ $recipe1 && $recipe2 == [+-]* ]]; then
        printf '%s,%s' "$recipe1" "$recipe2"
    else
        printf '%s' "$recipe2"
    fi
}

git_() (
    local args=("$@")
    local extra_args=()

    # Cannot use the '-C' option - it requires newer Git.
    # Cannot use '--git-dir' + '--work-tree' options - they break at least git-stash.
    if [[ $OPT_SRC_DIR ]]; then
        cd "$OPT_SRC_DIR" || return
    fi

    # At least git-stash requires an explicitly set user identity. Setting environment
    # variables compared to passing options with '-c' works also for subprocesses invoked via
    # `git-submodule foreach`
    if inside_build_engine; then
        export GIT_AUTHOR_NAME='mersdk' GIT_AUTHOR_EMAIL='mersdk@mersdk'
        export GIT_COMMITTER_NAME='mersdk' GIT_COMMITTER_EMAIL='mersdk@mersdk'
    fi

    # File mode is not handled transparently on shared files
    if inside_build_engine; then
	extra_args+=(-c core.fileMode=false)
    fi

    git "${extra_args[@]}" "${args[@]}"
)

oomadvice() {
    /usr/libexec/sdk-setup/oomadvice "$@"
}

get_hostname_from_devices_xml() {
    local TAG_NAME= ATTRIBUTES=
    while read_dom; do
        if [[ $TAG_NAME == host ]]; then
            eval "local $ATTRIBUTES"
            printf '%s\n' "$name"
            break
        fi
    done < $(get_shared_dir)/devices.xml
}

get_hostname() {
    local hostname=
    if inside_build_engine; then
        hostname=$(get_hostname_from_devices_xml)
    else
        hostname=$({ hostname --fqdn; hostname; } \
            |sed '/^localhost\(\.localdomain\)\?$/d; q')
    fi

    printf '%s\n' "${hostname:-localhost.localdomain}"
}

try_to_make_spec() { # Tries to create a missing spec
    [[ -f "$1" ]] && return # It's not missing
    local yaml="${1%.spec}.yaml"
    [[ -f "$yaml" ]] || return # No yaml
    ANSI_COLORS_DISABLED=1 specify -n -N "$yaml" || fatal "Failed to convert .yaml to .spec"
}

try_to_make_spec_from_yaml() {
    # Tries to create a missing spec from a given yaml
    try_to_make_spec "${1%.yaml}.spec"
}

sanitize_changelog() {
    sed 's/%/%%/g'
}

try_to_make_changelog() {
    local changes_file=${OPT_SPEC%.spec}.changes
    local changes_run_file=${OPT_SPEC%.spec}.changes.run

    if [[ $OPT_GIT_CHANGE_LOG ]]; then
        notice "Auto generating changelog from Git history…"
        echo "%changelog"
        git-change-log $OPT_GIT_CHANGE_LOG_ARGS |sanitize_changelog
    elif [[ -f $changes_file ]]; then
        notice "Appending changelog entries to the .spec file…"
        echo "%changelog"
        cat $changes_file |sanitize_changelog
    elif [[ -f $changes_run_file ]]; then
        notice "Generating changelog entries with '$changes_run_file'…"
        local runner=
        # In build VM the shared filesystem is noexec
        if ! [[ -x $changes_run_file ]]; then
            if [[ $(head -c 3 <$changes_run_file |cat -v) == '#!/' ]]; then
                runner=$(sed -n '1s/^#!//p' $changes_run_file)
            else
                fatal "File is not executable: '$changes_run_file'"
            fi
        fi
        echo "%changelog"
        $runner $changes_run_file |sanitize_changelog
        [[ ${PIPESTATUS[0]} -eq 0 ]] || fatal "Failed to generate changelog entries"
    fi
}

ensure_spec_newer_than_yaml() {
    local yaml="${OPT_SPEC%.spec}.yaml"
    if [[ -f "$yaml" ]] && [[ "$yaml" -nt "$OPT_SPEC" ]]; then # -nt is newer than
        ANSI_COLORS_DISABLED=1 specify -n -N "$yaml" || fatal "Failed to convert .yaml to .spec"
    fi

    # it's ok also not to have a yaml
}

warn_if_crlf_is_used() {
    local crlf_used=

    local file=
    # Assume that these two are sufficient indicators
    for file in "${OPT_SPEC%.spec}"{.spec,.yaml}; do
        if [[ -f $file && $(file "$file") == *"CRLF line terminators"* ]]; then
            crlf_used=1
            break
        fi
    done

    if [[ $crlf_used ]]; then
        notice "Files with CRLF line endings found." \
            "Consult the Sailfish SDK FAQ to learn why to avoid that and how."
    fi
}

match_multi() {
    local name=$1 patterns=("${@:2}")

    if [[ ${#patterns[*]} -eq 0 ]]; then
        return 0
    fi

    local inclusion_limited= included= excluded= pattern=
    for pattern in "${patterns[@]}"; do
        local exclude=
        if [[ $pattern == +* ]]; then
            pattern=${pattern:1}
        elif [[ $pattern == -* ]]; then
            pattern=${pattern:1}
            exclude=1
        fi

        if [[ ! $pattern ]]; then
            notice "Got invalid, empty pattern"
            return 1
        fi

        if [[ $exclude ]]; then
            if [[ $name == $pattern ]]; then
                included=
                excluded=1
            fi
        else
            inclusion_limited=1
            if [[ $name == $pattern ]]; then
                included=1
                excluded=
            fi
        fi
    done

    [[ (! $inclusion_limited || $included) && ! $excluded ]]
}

find_latest_rpms() {
    local dir=$1 patterns=("${@:2}")

    local latest=$(
        sb2 -t "$OPT_TARGET" -m sdk-install \
            zypper --plus-repo "$dir/" search --repo ~plus-repo-1 --details \
            `# drop header` \
            |sed '1,/^--/d' \
            `# name|epoch|version|release|arch` \
            |awk -F ' *\\| *' -v OFS='|' '{
                    evr = gensub(/((.+):)?([^-]+)(-(.*))?/, "\\2|\\3|\\5", 1, $4);
                    print $2, evr, $5
                }' \
            `# sort by name and e-v-r` \
            |sort -t '|' -k 1,1 -k2,2rV -k3,3rV -k4,4rV \
            `# keep first for each name` \
            |sort -t '|' --stable -k 1,1 -u \
            `# $name $dir/$name-$evr.$arch.rpm` \
            |awk -F '|' -v dir="$dir" '{
                        evr=$3 "-" $4;
                        if ($2)
                            evr=$2 ":" evr;
                        print $1, dir "/" $1 "-" evr "." $5 ".rpm"
                    }'
    )

    [[ $latest ]] || return

    local name= pkg=
    while read name pkg; do
        if [[ ! -f "$pkg" ]]; then
            fatal "Internal error: Package does not exist: '$pkg'"
        fi
        if match_multi "$name" "${patterns[@]}"; then
            printf '%s\n' "$pkg"
        fi
    done <<<"$latest"
}

# Find binary rpms under <dir> built from the given <spec>, filtering according
# to <patterns>. If '--all' is used (must be the very first option), ignore
# <spec> and find latest packages no matter of their origin.
find_rpms()
{
    local all=
    if [[ $1 == --all ]]; then
        all=1
        shift
    fi

    local dir=$1 spec=$2 patterns=("${@:3}")

    if [[ $all ]]; then
        find_latest_rpms "$dir" "${patterns[@]}"
        return
    fi

    local wanted_source_name= wanted_evr=
    read wanted_source_name wanted_evr < <(rpmspec -q --srpm --queryformat '%{NAME} %{EVR}\n' "$spec")

    local pkg=
    while read -r pkg; do
        local name= source_rpm= evr=
        read name source_rpm evr < <(rpm -q --queryformat '%{NAME} %{SOURCERPM} %{EVR}\n' -p "$pkg")
        local source_name=${source_rpm%-$evr.src.rpm}
        if [[ $source_name == $wanted_source_name && $evr == $wanted_evr ]] \
                && match_multi "$name" "${patterns[@]}"; then
            printf '%s\n' "$pkg"
        fi
    done < <(find "$dir" -maxdepth 1 -name '*.rpm')
}

# Copy a repo excluding packages built from the given exclude_source_name package
filter_repo()
{
    local exclude_source_name=$1 repo=$2 output=$3

    rm -rf "$output"
    mkdir -p "$output"

    local pkg=
    while read -r pkg; do
        local source_rpm= evr=
        read source_rpm evr < <(rpm -q --queryformat '%{SOURCERPM} %{EVR}\n' -p "$pkg")
        local source_name=${source_rpm%-$evr.src.rpm}
        [[ $source_name != $exclude_source_name ]] || continue
        ln -s --target-directory="$output" "$pkg"
    done < <(find "$repo" -maxdepth 1 -name '*.rpm')

    createrepo_c "$output"
}

maybe_verify_target_dependencies() {
    [[ $OPT_PULL_BUILD_REQUIRES ]] || return 0

    local deps=()
    readarray -t deps < <(sb2 -t "$OPT_TARGET" rpmspec --query --buildrequires "$OPT_SPEC" |sed 's/\s*$//')
    if [[ $deps ]]; then
        if inside_build_engine; then
            local oldpkgs=$(sb2 -t "$OPT_TARGET" -m sdk-install rpm -qa)
        fi
        if [[ $OPT_SEARCH_OUTPUTDIR ]]; then
            local filtered_outputdir=$STATEDIR/filtered-output-dir
            local exclude_source_name=$(get_spec_tag "%{name}")
            filter_repo "$exclude_source_name" "$OPT_OUTPUTDIR" "$filtered_outputdir"
            local args=(--"$OPT_SEARCH_OUTPUTDIR_VERBOSITY" --non-interactive \
                --plus-repo "$filtered_outputdir" --no-gpg-checks)
            sb2 -t "$OPT_TARGET" -m sdk-install -R zypper "${args[@]}" dup --from '~plus-repo-1'
            sb2 -t "$OPT_TARGET" -m sdk-install -R zypper "${args[@]}" in "${deps[@]}"
        else
            sb2 -t "$OPT_TARGET" -m sdk-install -R zypper --quiet --non-interactive in "${deps[@]}"
        fi
        if inside_build_engine; then
            local newpkgs=$(sb2 -t "$OPT_TARGET" -m sdk-install rpm -qa)
            if [[ $newpkgs != $oldpkgs ]]; then
                sdk-manage target sync "$OPT_TARGET"
            fi
        fi
    fi
}

get_spec_tag() {
    rpmspec --query --srpm --queryformat="$1" "$OPT_SPEC"
}

maybe_fix_package_version() {
    local spec_file=$1

    local version_in_spec=$(sed -n 's/^Version:[[:space:]]*//p' "$spec_file")

    if [[ $OPT_NO_FIX_VERSION ]]; then
        return
    elif [[ ! $OPT_FIX_VERSION ]]; then
        # When used behind Qt Creator, fixing version is enabled implicitly only if the
        # version in spec file is exactly "0" - this is because there is no UI in Qt Creator
        # that would allow to override this.
        if behind_qtcreator && [[ $version_in_spec != 0 ]]; then
            return
        fi
    fi

    if ! inside_git_worktree; then
        if [[ $OPT_FIX_VERSION || $version_in_spec == 0 ]]; then
            notice "Not inside a Git working tree, will not fix package version."
        fi
        return
    fi

    local tag
    if [[ $OPT_FIX_VERSION_HINT ]]; then
        tag=$OPT_FIX_VERSION_HINT
    else
        if ! tag=$(git_ describe --tags --abbrev=0 2>/dev/null); then
            notice "No tags describe the HEAD, will not fix package version."
            return
        fi
    fi

    local version=$tag
    version=${version#*/}   # allow tags to have a prefix to allow vendor marking
    version=${version#v}    # some people like to prefix versions with a v

    local stash=
    if ! stash=$(git_ stash create); then
        fatal "Cannot save state of Git working tree: git-stash failed."
    fi
    local head=${stash:-$(git_ rev-parse HEAD)}

    local modified_submodules=
    modified_submodules=$(
        describe_if_modified()
        {
            local stash=
            stash=$(git stash create) || return
            local head=${stash:-$(git rev-parse HEAD)}
            if [[ $head != $sha1 ]]; then
                local short=$(git rev-list --max-count=1 --abbrev-commit "$head")
                local time=$(git log --max-count=1 --pretty=%ct "$head")
                printf '%s %s %s\n' "$name" "$short" "$time"
            fi
        }
        git_ submodule --quiet foreach --recursive \
            "$(declare -f describe_if_modified); describe_if_modified")
    if [[ $? -ne 0 ]]; then
        fatal "Cannot save state of Git submodules: git-stash failed for some."
    fi

    if [[ $(git_ rev-parse "$tag^{}") != "$head" || $modified_submodules ]]; then
        local branch=$(git_ rev-parse --abbrev-ref HEAD)

        local time=$(git_ log --max-count=1 --pretty=%ct "$head")
        local submodule_info=
        if [[ $modified_submodules ]]; then
            local subname= subsha1= subtime=
            while read subname subsha1 subtime; do
                submodule_info+=+$subname.$subsha1
                if (( subtime > time )); then
                    time=$subtime
                fi
            done <<<"$modified_submodules"
        fi

        local timestamp=$(TZ=UTC date --date=@"$time" +%Y%m%d%H%M%S)
        local sha1sum=$(git_ rev-list --max-count=1 --abbrev-commit "$head")
        version=$version+$branch.$timestamp.$sha1sum$submodule_info
    fi

    version=${version//[^+_[:alnum:]]/.} # replace characters not allowed in the version field

    echo "Setting version: ${version}"
    sed -i "s,^Version:.*,Version: ${version}," "$spec_file"
}

maybe_set_task_name_from_git_branch_name() {
    if [[ $OPT_TASK != git:* ]]; then
        return
    elif ! inside_git_worktree; then
        OPT_TASK=
        return
    fi

    local regex=${OPT_TASK#git:}
    local branch=$(git_ rev-parse --abbrev-ref HEAD)

    if [[ $branch =~ $regex ]]; then
        OPT_TASK=${BASH_REMATCH[0]}
        notice "Task name determined as '$OPT_TASK' (from the current Git branch)"
    else
        OPT_TASK=
    fi
}

# Helper to read XML
read_dom () {
    local IFS=\>
    read -d \< ENTITY CONTENT
    local RET=$?
    TAG_NAME=${ENTITY%% *}
    ATTRIBUTES=${ENTITY#* }
    ATTRIBUTES=${ATTRIBUTES%/}
    return $RET
}

# This slurps the XML and converts tags like <subnet> to $device_subnet
# Also sets device_name and device_type from the attributes
get_device() {
    local FOUND_DEVICE=
    local IN_DEVICE=
    local maintag=
    while read_dom; do
        case $TAG_NAME in
            device )
                maintag=$TAG_NAME
                eval local $ATTRIBUTES
                if [[ "$name" == "$1" ]] ; then
                    FOUND_DEVICE=1
                    IN_DEVICE=1
                    device_name="$name"
                    device_type="$type"
                else
                    IN_DEVICE=
                fi
                ;;
            engine )
                maintag=$TAG_NAME
                eval local $ATTRIBUTES
                ;;
            mac|index|subnet|ip|sshkeypath|sshport|username )
                # Don't process and store nested tags if we're in
                # device with wrong name
                if [[ "$maintag" == "device" ]] && [[ $IN_DEVICE != 1 ]]; then
                    continue
                fi
                eval ${maintag}_$TAG_NAME=\'$CONTENT\'
                ;;
        esac
    done
    # Set this up as it's useful
    if [[ "$device_subnet" ]]; then
        device_ip="$device_subnet".$device_index
    fi
    if [[ ! "$device_sshport" ]]; then
        device_sshport=22
    fi
    if [[ "$device_sshkeypath" == '$HOME/'* ]]; then
        local real_home=$(inside_build_engine && echo "/host_home" || echo "$HOME")
        device_sshkeypath=$real_home/${device_sshkeypath#\$HOME/}
    elif [[ "$device_sshkeypath" ]]; then
        device_sshkeypath=$(get_shared_dir)/${device_sshkeypath}
    fi
    if [[ "$FOUND_DEVICE" == 1 ]]; then return 0; else return 1; fi
}

# SSH requires that a private key file is only accessible to the user. Under
# build engine, file permissions under /host_home are too open to comply with
# that.  Loading key from stdin is a way to work this around.
with_specific_or_default_keys() {
    local user=$1 command=("${@:2}")

    local key=$device_sshkeypath
    if [[ $key ]]; then
        [[ -f $key ]] || key=$key/$user
        [[ -f $key ]] || fatal "SSH key not configured for user '$user' on '$device_name'"
    fi

    add_specific_or_default_keys() {

        ssh-add() {
            DISPLAY=:0 SSH_ASKPASS=/usr/libexec/sdk-setup/ssh-askpass command ssh-add "$@"
        } 

        local key=$1
        if [[ $key ]]; then
            ssh-add -q - <"$key" || return
        elif inside_build_engine; then
            local real_home="/host_home"
            local default_key=
            # See in Qt Creator sources for defaultKeys() in
            # genericlinuxdeviceconfigurationwizardpages.cpp
            for default_key in "$real_home"/.ssh/id_{rsa,ecdsa,ed25519}; do
                if [[ -f $default_key ]]; then
                    ssh-add -q - <"$default_key" || :
                fi
            done
        fi
    }

    ssh-agent bash -c "$(declare -f inside_build_engine add_specific_or_default_keys);
        add_specific_or_default_keys $(quote "$key") && $(quote "${command[@]}")" bash
}

rsync_as() {
    local user="$1";shift
    RSYNC_RSH="ssh -F /etc/ssh/ssh_config.sdk -l $user -p $device_sshport" \
        with_specific_or_default_keys "$user" \
        rsync "$@"
}

ssh_as() {
    local user="$1";shift
    with_specific_or_default_keys "$user" \
        ssh -F /etc/ssh/ssh_config.sdk -l $user $device_ip -p $device_sshport "$(quote "$@")"
}

get_spec_setup_subdir() {
    # avoid spawning another process for | cut -s -f2 -d '/'
    local setup_dir=$(grep -Po '%(auto)?setup.*-n[[:space:]]+[^[:space:]]+' "$OPT_SPEC")
    # if setup_dir has '/' return the part after it
    setup_dir=${setup_dir/#*\//}
    # if it did not have a '/' then we got the original match => erase it
    setup_dir=${setup_dir/#%?(auto)setup*/}

    # in case we got a spec %{tag} out of this, try to expand it
    get_spec_tag "$setup_dir"
}

maybe_cd_to_spec_setup_subdir() {
    local setup_dir=$(get_spec_setup_subdir)
    if [[ $setup_dir ]]; then
        is_shadow_build && mkdir -p "$setup_dir"
        cd "$setup_dir"
    fi
}

# handle release tags with format "x" or "x.y", where x and y are
# numbers, leave others untouched
#  get tag
#  check if it has x.y
#  if it is x.y get y and check if y is number
#  if y is number => increment
#  if it only is x check if x is number
#  if x is number => increment
#  else leave untouched
maybe_increment_build_number() {
    [[ $OPT_INC_BUILD_NUMBER -eq 0 ]] && return

    local release=$(get_spec_tag "%{release}")
    local x=$(echo $release | cut -f 1 -d .)
    local y=$(echo $release | cut -s -f 2 -d .)
    local z=$(echo $release | cut -s -f 3- -d .)

    # more than one dot found => don't touch
    [[ -n "$z" ]] && return

    if [[ -n "$y" ]]; then
        if [[ $y =~ ^-?[0-9]+$ ]]; then
            let new_release=$y+1
            echo "Incrementing release: $x.$y -> $x.$new_release"
            sed -i "s/^Release:.*/Release: $x.$new_release/" "$OPT_SPEC"
            return
        else
            # non-numeric after dot => don't touch
            return
        fi
    fi

    if [[ -n "$x" ]]; then
        if [[ $x =~ ^-?[0-9]+$ ]]; then
            let new_release=$x+1
            echo "Incrementing release: $x -> $new_release"
            sed -i "s/^Release:.*/Release: $new_release/" "$OPT_SPEC"
            return
        fi
    fi
}

quote() {
    [[ $# -gt 0 ]] && printf "%q " "$@" |sed 's/ $//'
}

rpm_quote() {
    quote "$@" |sed 's/\\/&&/g'
}

# Sometime's better to be paranoid than sorry.
clean_dir_no_recurse() {
    local dir=$1
    # Also ensure 'rmdir --parents' is not unnecessary verbose
    find "$dir" -maxdepth 1 ! -type d -delete && rmdir --parents "$dir" &>/dev/null
}

init_wrappers_dir() {
    [[ -e $WRAPPERSDIR ]] || mkdir -p "$WRAPPERSDIR"
    [[ -e $USERWRAPPERSDIR ]] || mkdir -p "$USERWRAPPERSDIR"
    local user_wrapper= command= wrapper=
    for user_wrapper in "${OPT_WRAP[@]}"; do
        command=${user_wrapper%%:*}
        wrapper=${user_wrapper#*:}
        ln -s "$wrapper" "$USERWRAPPERSDIR/$command"
    done
}

remove_wrappers_dir() {
    [[ -d $WRAPPERSDIR ]] && clean_dir_no_recurse "$WRAPPERSDIR"
    [[ -d $USERWRAPPERSDIR ]] && clean_dir_no_recurse "$USERWRAPPERSDIR"
}

# 1. Allows to pass extra arguments to qmake
# 2. Enables shadow build by adding path prefix to the project file, or
# 2.1 passing project directory path if the project file was not passed
# 3. Populates variable cache used by Qt Creator to augment its project model
init_qmake_wrapper() (
    local wrapper=$1
    local extra_args=("${@:2}")

    main() {
        local self=${0#$PWD/}
        local command=${0##*/}

        local path=${0%/*}
        PATH=${PATH/$path:/}

        local real=$(which "$command")
        if [[ ! $real || $real == "$0" ]]; then
            echo "$self: Cannot find real $command" >&2
            exit 1
        fi

        if [[ $IS_SHADOW_BUILD ]]; then
            local subdir=${PWD#$BUILD_DIR}
            local src_dir=$SRC_DIR${subdir:+/$subdir}
            local args=()
            local pro_passed=
            for arg in "$@"; do
                if [[ $arg == *.pro && -f $src_dir/$arg ]]; then
                    args+=("$src_dir/$arg")
                    pro_passed=1
                else
                    args+=("$arg")
                fi
            done
            if [[ ! $pro_passed ]]; then
                args+=("$src_dir")
            fi
            set -- "${args[@]}"
        fi

        local assignments=()
        for arg in "$@"; do
            if [[ $arg =~ ^[a-zA-Z_][a-zA-Z0-9_]*= ]]; then
                assignments+=("$arg")
            fi
        done
        printf '%s\0' "${assignments[@]}" > "$VARIABLES_CACHE"

        echo "$self: Executing real $command:" >&2

        set -x
        "$real" "$@" "${EXTRA_ARGS[@]}"
    }

    init_wrappers_dir
    cat <<END >"$wrapper"
#!/bin/bash

IS_SHADOW_BUILD=$(is_shadow_build && echo 1)
BUILD_DIR=$(quote "$PWD")
SRC_DIR=$(quote "${OPT_SRC_DIR:-$PWD}")
VARIABLES_CACHE=$STATEDIR/qmake_variables.$OPT_TARGET.cache
EXTRA_ARGS=($(quote "${extra_args[@]}"))

$(declare -f main)

main "\$@"
END
    chmod +x "$wrapper"
)

# 1. Allows to pass extra arguments to cmake
# 2. Enables shadow build by adding path prefix to the project-dir argument, or
# 2.1 passing project directory path if it was not passed
# 3. Allows to suppress cmake not invoked in the desired mode
init_cmake_wrapper() (
    local wrapper=$1

    do_configure() {
        local src_dir=
        if [[ $IS_SHADOW_BUILD ]]; then
            local subdir=${PWD#$BUILD_DIR}
            src_dir=$SRC_DIR${subdir:+/$subdir}
        else
            src_dir=.
        fi

        local args=()
        local maybe_src_arg=()
        for arg in "$@"; do
            # Allow .spec files do shadow build explicitly
            local prefixed_clean=$(readlink --canonicalize-missing "$src_dir/$arg")
            if [[ -f $prefixed_clean/CMakeLists.txt ]]; then
                maybe_src_arg=("$prefixed_clean")
            else
                args+=("$arg")
            fi
        done
        set -- "${args[@]}"

        if [[ $IS_SHADOW_BUILD && ${#maybe_src_arg[*]} -eq 0 ]]; then
            maybe_src_arg=("$src_dir")
        fi

        # NBSP used to prevent Qt Creator treating this as an error when issued for 'cmake'
        echo "$self:${NBSP}Executing real $command:" >&2

        (
            set -x
            "$real" "$@" "${EXTRA_CONFIGURE_ARGS[@]}" ${maybe_src_arg[@]:+"${maybe_src_arg[@]}"}
        )
    }

    do_build() {
        local args=() build_tool_args=()
        while [[ $# -gt 0 ]]; do
            case $1 in
                --build)
                    if [[ $2 != . ]]; then
                        echo "$self: The argument to '--build' passed in .spec must be '.' (literally)" >&2
                        exit 1
                    fi
                    args+=("$1" "$2")
                    shift
                    ;;
                --target)
                    if [[ $MAKE_TARGET && $2 != "$MAKE_TARGET" ]]; then
                        echo "$self: The argument to '--target' passed in .spec differs from that on command line" >&2
                        exit 1
                    fi
                    args+=("$1" "$2")
                    shift
                    ;;
                --)
                    shift
                    build_tool_args=("$@")
                    shift $#
                    break
                    ;;
                *)
                    args+=("$1")
                    ;;
            esac
            shift
        done

        # NBSP used to prevent Qt Creator treating this as an error when issued for 'cmake'
        echo "$self:${NBSP}Executing real $command:" >&2

        (
            set -x
            "$real" "${args[@]}" "${EXTRA_BUILD_ARGS[@]}" -- "${build_tool_args[@]}" "${EXTRA_BUILD_TOOL_ARGS[@]}"
        )
    }

    main() {
        local self=${0#$PWD/}
        local command=${0##*/}
        local NBSP=$'\xC2\xA0'

        local path=${0%/*}
        PATH=${PATH/$path:/}

        local real=$(which "$command")
        if [[ ! $real || $real == "$0" ]]; then
            echo "$self: Cannot find real $command" >&2
            exit 1
        fi

        if [[ $1 != --build ]]; then
            if [[ ! $ALLOWED_MODE || $ALLOWED_MODE == configure ]]; then
                do_configure "$@"
            else
                # NBSP used to prevent Qt Creator treating this as an error when issued for 'cmake'
                echo "$self:${NBSP}Ignoring $command invoked to create a project buildsystem" >&2
            fi
        else
            if [[ ! $ALLOWED_MODE || $ALLOWED_MODE == build ]]; then
                do_build "$@"
            else
                # NBSP used to prevent Qt Creator treating this as an error when issued for 'cmake'
                echo "$self:${NBSP}Ignoring $command invoked to build the project" >&2
            fi
        fi
    }

    init_wrappers_dir
    cat <<END >"$wrapper"
#!/bin/bash

IS_SHADOW_BUILD=$(is_shadow_build && echo 1)
BUILD_DIR=$(quote "$PWD")
SRC_DIR=$(quote "${OPT_SRC_DIR:-$PWD}")
ALLOWED_MODE=$(quote "$CMAKE_MODE")
EXTRA_CONFIGURE_ARGS=($(quote "${CMAKE_EXTRA_CONFIGURE_ARGS[@]}"))
EXTRA_BUILD_ARGS=($(quote "${CMAKE_EXTRA_BUILD_ARGS[@]}"))
EXTRA_BUILD_TOOL_ARGS=($(quote "${CMAKE_EXTRA_BUILD_TOOL_ARGS[@]}"))
BUILD_TARGET=$(quote "$CMAKE_BUILD_TARGET")

$(declare -f do_configure)
$(declare -f do_build)
$(declare -f main)

main "\$@"
END
    chmod +x "$wrapper"
)

init_autotools_wrappers() {
    local src_subdir=${1?}
    local src_dir=$OPT_SRC_DIR/$src_subdir

    if [[ -e $src_dir/configure.ac || -e $src_dir/configure.in || -e $src_dir/configure ]]; then
        init_source_tool_wrapper "$src_subdir/configure"
    fi

    if [[ -e $src_dir/autogen.sh ]]; then
        init_source_tool_wrapper --cd "$src_subdir/autogen.sh"
    fi

    local tool=
    for tool in "${AUTOTOOLS[@]}"; do
        init_cd_to_sources_wrapper "$WRAPPERSDIR/$tool"
    done
}

# Create a wrapper for a tool from source tree under the (shadow) build tree.
init_source_tool_wrapper() {
    local opt_cd=
    if [[ $1 == --cd ]]; then
        opt_cd=1
        shift
    fi
    local file=$1

    local subdir=${file%/*}

    mkdir -p "$subdir" || return

    {
        cat <<END
#!/bin/bash
# This file was auto-generated by 'mb2'.
END
        if [[ $opt_cd ]]; then
            cat <<END
cd "$OPT_SRC_DIR/$subdir" || exit
END
        fi

        cat <<END
exec "$OPT_SRC_DIR/$file" "\$@"
END
    } >"$file"
    chmod +x "$file"
}

init_cd_to_sources_wrapper() (
    local wrapper=$1

    main() {
        local self=${0#$PWD/}
        local command=${0##*/}

        local path=${0%/*}
        PATH=${PATH/$path:/}

        local real=$(which "$command")
        if [[ ! $real || $real == "$0" ]]; then
            echo "$self: Cannot find real $command" >&2
            exit 1
        fi

        if [[ $PWD/ != "$BUILD_DIR/"* ]]; then
            # We are not under the build dir. This means we are invoked by
            # another wrapped command that already did cd to sources. Execute
            # the real command silently in this case.
            "$real" "$@"
            return
        fi

        local subdir=${PWD#$BUILD_DIR}
        local src_dir=$SRC_DIR${subdir:+/$subdir}

        echo "$self: Executing real $command:" >&2

        set -x
        cd "$src_dir" && "$real" "$@"
    }

    init_wrappers_dir
    cat <<END >"$wrapper"
#!/bin/bash

BUILD_DIR=$(quote "$PWD")
SRC_DIR=$(quote "${OPT_SRC_DIR:-$PWD}")

$(declare -f main)

main "\$@"
END
    chmod +x "$wrapper"
)

init_make_compiledb_wrapper() (
    local wrapper=$1
    local extra_args=("${@:2}")

    main() {
        local self=${0#$PWD/}
        local command=${0##*/}

        local path=${0%/*}
        PATH=${PATH/$path:/}

        local real=$(which "$command")
        if [[ ! $real || $real == "$0" ]]; then
            echo "$self: Cannot find real $command" >&2
            exit 1
        fi

        # Check if the makefile defines any of the well known targets to
        # generate compilation database a custom way.
        local make_db=$("$real" "$@" --dry-run --silent \
            --print-data-base --no-builtin-rules --no-builtin-variables)
        local target= candidate_target=
        for candidate_target in "${CANDIDATE_TARGETS[@]}"; do
            if grep -q -e "^${candidate_target//./\\.}:" <<<"$make_db"; then
                target=$candidate_target
                break
            fi
        done

        rm -f "$COMPILEDB_INPUT"

        if [[ $target ]]; then
            # Keep only options and variable assignments, drop targets
            local filtered_args=() arg=
            for arg in "$@"; do
                [[ $arg == -* || $arg == *=* ]] && filtered_args+=("$arg")
            done

            echo "$self: Executing real $command:" >&2

            set -x
            "$real" "${filtered_args[@]}" "$target" "${EXTRA_ARGS[@]}"
        elif which compiledb >/dev/null; then
            echo "$self: Wrapping real $command with compiledb:" >&2

            set -x
            compiledb --no-build make "$@" "${EXTRA_ARGS[@]}"
        else
            echo "$self: Executing real $command in dry-run mode:" >&2

            (
                set -x
                "$real" "$@" --dry-run --always-make --print-directory --keep-going \
                    "${EXTRA_ARGS[@]}"
            ) >"$COMPILEDB_INPUT"
        fi
    }

    init_wrappers_dir
    cat <<END >"$wrapper"
#!/bin/bash

CANDIDATE_TARGETS=(compiledb compile_commands.json)
COMPILEDB_INPUT=$(quote "$COMPILEDB_INPUT")
EXTRA_ARGS=($(quote "${extra_args[@]}"))

$(declare -f main)

main "\$@"
END
    chmod +x "$wrapper"
)

init_simple_wrapper() {
    local wrapper=$1
    local extra_args=("${@:2}")

    init_wrappers_dir
    {
        cat <<'END'
#!/bin/bash
self=${0#$PWD/}
command=${0##*/}
NBSP=$'\xC2\xA0'

path=${0%/*}
PATH=${PATH/$path:/}

real=$(which "$command")
if [[ ! $real || $real == "$0" ]]; then
    echo "$self: Cannot find real $command" >&2
    exit 1
fi

# NBSP used to prevent Qt Creator treating this as an error when issued for 'make'
echo "$self:${NBSP}Executing real $command:" >&2

set -x

"$real" "$@" \
END
        quote "${extra_args[@]}"
        echo
    } >"$wrapper"
    chmod +x "$wrapper"
}

init_noop_wrapper() {
    local wrapper=$1

    init_wrappers_dir
    cat <<'END' >"$wrapper"
#!/bin/bash
self=${0#$PWD/}
command=${0##*/}
NBSP=$'\xC2\xA0'
# NBSP used to prevent Qt Creator treating this as an error when issued for 'qmake'
echo "$self:${NBSP}Ignoring $command" >&2
END
    chmod +x "$wrapper"
}

switch_to_snapshot() {
    OPT_SNAPSHOT_SUFFIX=${OPT_SNAPSHOT_SUFFIX//%{task\}/$OPT_TASK}

    if [[ $OPT_SNAPSHOT_SUFFIX ]]; then
        OPT_TARGET=$OPT_ORIGINAL_TARGET.$OPT_SNAPSHOT_SUFFIX
        sdk-manage target snapshot --reset=outdated "$OPT_ORIGINAL_TARGET" "$OPT_TARGET" || return
    else
        local lock=$STATEDIR/snapshot.lock
        exec 10> "$lock" || return
        if ! flock --nonblock 10; then
            fatal "Failed to flock '$lock'"
        fi
        OPT_TARGET=$(sdk-manage target reserve "$OPT_ORIGINAL_TARGET" \
            "$OPT_ORIGINAL_TARGET.$SNAPSHOT_POOL_SUFFIX" "$lock" "$SNAPSHOT_POOL_SIZE") || return
    fi

    notice "Using the '$OPT_TARGET' snapshot of the build target"
}

run_build_requires__process_args() {
    BUILD_REQUIRES_MODE=
    BUILD_REQUIRES_NOREFRESH=

    if [[ $OPT_SNAPSHOT ]]; then
        BUILD_REQUIRES_NOREFRESH=1
    fi
    while [[ "$1" ]]; do
        case "$1" in
            --refresh) shift
                BUILD_REQUIRES_NOREFRESH= ;;
            --no-refresh) shift
                BUILD_REQUIRES_NOREFRESH=1 ;;
            reset|--reset)
                if [[ $1 == --reset ]]; then
                    notice "The '--reset' option is deprecated. Use 'reset' (non-option) instead."
                fi
                shift
                if [[ ! $OPT_SNAPSHOT ]]; then
                    fatal "The 'reset' command is only effective with build target snapshots."
                fi
                BUILD_REQUIRES_MODE=reset ;;
            pull) shift
                BUILD_REQUIRES_MODE=pull ;;
            *)
                short_usage quit
                ;;
        esac
    done
    if [[ ! $BUILD_REQUIRES_MODE ]]; then
        notice "Omitting 'pull' is deprecated. Pass 'pull' explicitly."
        BUILD_REQUIRES_MODE=pull
    fi
}

run_build_requires() {
    if [[ $BUILD_REQUIRES_MODE == reset ]]; then
        if ! sdk-manage target snapshot --reset=force "$OPT_ORIGINAL_TARGET" "$OPT_TARGET"; then
            fatal "Failed to reset build target snapshot '$OPT_TARGET' to '$OPT_ORIGINAL_TARGET'"
        fi
    fi
    if [[ ! $BUILD_REQUIRES_NOREFRESH ]]; then
        # Refresh repos before installing dependencies
        sb2 -t "$OPT_TARGET" -m sdk-install -R zypper --non-interactive ref
    fi
    maybe_verify_target_dependencies
}

run_apply__process_args() {
    APPLY_REVERSE=
    while [[ "$1" ]]; do
        case "$1" in
            -R) shift
                APPLY_REVERSE=1 ;;
            *)
                short_usage quit
                ;;
        esac
    done
}

run_apply() {
    local message="Applying"
    local common_op=()
    if [[ $APPLY_REVERSE ]]; then
        message="Reversing"
        common_op+=(-R)
    fi

    tr -d '\r' < "$OPT_SPEC" > "$TMP_SPEC"
    cmp -s "$OPT_SPEC" "TMP_SPEC" || common_op+=(--binary)

    local to_apply=
    local auto_applied=$(grep -q "^%autosetup" "$TMP_SPEC" \
        && ! grep -q "^%patch[0-9]" "$TMP_SPEC" \
        && echo 1)
    if [[ $auto_applied ]]; then
        to_apply=$(sed -n 's/^Patch\([0-9]*\):.*/\1/p' "$TMP_SPEC")
        common_op+=($(sed -n 's/^%autosetup\( .*\)\? \(-p *[0-9]\+\).*/\2/p' "$TMP_SPEC"))
    else
        to_apply=$(sed -n 's/^%patch\([0-9]*\).*/\1/p' "$TMP_SPEC")
    fi

    if [[ $APPLY_REVERSE ]]; then
        to_apply=$(tac <<<"$to_apply")
    fi

    (
        maybe_cd_to_spec_setup_subdir
        for p in $to_apply; do
            if [[ ! $auto_applied ]]; then
                op="$(sed -n "s/^%patch$p \+\(.*\)/\1/p" "$TMP_SPEC")"
            fi
            patch_file="$(sed -n "s/^Patch$p: \+\(.*\)/\1/p" "$TMP_SPEC")"
            echo "$message $patch_file" >&2
            patch "${common_op[@]}" $op < "$(dirname "$OPT_SPEC")/$patch_file" >&2
        done
    )
}

run_build__process_args() {
    BUILD_DEBUG_ARGS=(--define "debug_package %{nil}")
    BUILD_JOBS=
    BUILD_NOPREP_ARGS=(--noprep)
    BUILD_NOCHECK_ARGS=()
    BUILD_EXTRA_ARGS=()
    while [[ "$1" ]]; do
        case "$1" in
            -d|--enable-debug) shift
                BUILD_DEBUG_ARGS=() ;;
            -j*)
                # support giving -j with and without space between
                # it and the 'n'
                if [[ ${#1} -gt 2 ]]; then
                    BUILD_JOBS=${1:2}; shift
                else
                    [[ -z "$2" ]] && short_usage quit
                    BUILD_JOBS="$2"; shift 2;
                fi
                ;;
            -p|--prepare|--doprep)
                if [[ $1 == --doprep ]]; then
                    notice "The '--doprep' option is deprecated. Use '--prepare|-p' instead."
                fi
                shift
                BUILD_NOPREP_ARGS=()
                ;;
            --no-check) shift
                BUILD_NOCHECK_ARGS=(--nocheck)
                ;;
            --) shift
                break
                ;;
            *)
                if [[ -e $1 ]]; then
                    OPT_PRO_FILE_OR_DIR="${1%%+(/)}"
                    shift
                fi
                break
                ;;
        esac
    done
    BUILD_EXTRA_ARGS=("$@")
    handle_pro_file_or_dir_option
    [[ $BUILD_JOBS ]] || BUILD_JOBS=$(getconf _NPROCESSORS_ONLN)
}

run_build() {
    # intended to provide mb build behaviour
    maybe_verify_target_dependencies

    maybe_increment_build_number;
    if [[ $BUILD_NOPREP_ARGS ]]; then
        sed -e '/^%patch/d' "$OPT_SPEC" > "$TMP_SPEC"
    else
        cp "$OPT_SPEC" "$TMP_SPEC"
    fi

    try_to_make_changelog >> "$TMP_SPEC"

    # get rid of potential windows linefeeds
    sed -i "s/\x0D$//g" "$TMP_SPEC"

    maybe_fix_package_version "$TMP_SPEC"

    local build_tgt=$(sb2 -t $OPT_TARGET gcc -dumpmachine)
    build_tgt=${build_tgt%-gnueabi}

    if is_shadow_build; then
        local subdir=$(get_spec_setup_subdir)
        : ${subdir:=.}
        local src_dir=$OPT_SRC_DIR/$subdir

        init_qmake_wrapper $WRAPPERSDIR/qmake
        init_cmake_wrapper $WRAPPERSDIR/cmake

        if [[ -e $src_dir/Makefile.am ]]; then
            init_autotools_wrappers "$subdir"
        fi
    fi

    (
        maybe_cd_to_spec_setup_subdir
        [[ $OPT_CLEAN_OUTPUTDIR ]] && rm -f "$OPT_OUTPUTDIR/"*.rpm;
        oomadvice sb2 -t $OPT_TARGET env PATH="$WRAPPERSDIR:$USERWRAPPERSDIR:$PATH" rpmbuild \
            --build-in-place --target=$build_tgt \
            "${BUILD_DEBUG_ARGS[@]}" \
            --define "_smp_mflags -j$(rpm_quote "$BUILD_JOBS")" \
            --define "_rpmdir $OPT_OUTPUTDIR" \
            --define "_sourcedir $(dirname $OPT_SPEC)" \
            --define "_rpmfilename %%{name}-%%{version}-%%{release}.%%{arch}.rpm" \
            --define "_buildhost $(get_hostname)" \
            --buildroot="$buildroot" \
            "${BUILD_NOPREP_ARGS[@]}" "${BUILD_NOCHECK_ARGS[@]}" \
            -bb \
            "$TMP_SPEC" \
            "${BUILD_EXTRA_ARGS[@]}"
    )
}

run_prepare() {
    maybe_verify_target_dependencies

    maybe_increment_build_number;
    # TODO maybe add toggle here for disabling patch applying?
    cp "$OPT_SPEC" "$TMP_SPEC"

    # get rid of potential windows linefeeds
    sed -i "s/\x0D$//g" "$TMP_SPEC"

    maybe_fix_package_version "$TMP_SPEC"

    local build_tgt=$(sb2 -t $OPT_TARGET gcc -dumpmachine)
    build_tgt=${build_tgt%-gnueabi}
    (
        maybe_cd_to_spec_setup_subdir
        [[ $OPT_CLEAN_OUTPUTDIR ]] && rm -f "$OPT_OUTPUTDIR/"*.rpm;
        oomadvice sb2 -t $OPT_TARGET rpmbuild --build-in-place --target=$build_tgt \
            --define "_smp_mflags -j$BUILD_JOBS" \
            --define "_rpmdir $OPT_OUTPUTDIR" \
            --define "_sourcedir $(dirname $OPT_SPEC)" \
            --define "_rpmfilename %%{name}-%%{version}-%%{release}.%%{arch}.rpm" \
            --define "_buildhost $(get_hostname)" \
            --buildroot="$buildroot" \
            -bp --short-circuit \
            "$TMP_SPEC"
    )
}

run_cmake__process_args() {
    CMAKE_MODE=
    CMAKE_EXTRA_CONFIGURE_ARGS=()
    CMAKE_EXTRA_BUILD_ARGS=()
    CMAKE_EXTRA_BUILD_TOOL_ARGS=()
    CMAKE_BUILD_TARGET=

    case $1 in
        --build)
            CMAKE_MODE=build

            [[ $2 ]] || fatal "Option expects argument: '--build'"
            [[ $2 == . ]] || fatal "The argument to '--build' must be '.' (literally)"
            shift 2

            while [[ $# -gt 0 ]]; do
                case $1 in
                    --target)
                        [[ $2 ]] || fatal "Option expects argument: '--target'"
                        CMAKE_BUILD_TARGET=$2
                        shift
                        ;;
                    --)
                        shift
                        break
                        ;;
                    *)
                        CMAKE_EXTRA_BUILD_ARGS+=("$1")
                        ;;
                esac
                shift
            done
            CMAKE_EXTRA_BUILD_TOOL_ARGS=("$@")
            ;;
        *)
            CMAKE_MODE=configure

            while [[ $# -gt 0 ]]; do
                case $1 in
                    --)
                        shift
                        break
                        ;;
                    *)
                        if [[ -e $1 ]]; then
                            OPT_PRO_FILE_OR_DIR=${1%%+(/)}
                            shift
                        fi
                        break
                        ;;
                esac
            done

            CMAKE_EXTRA_CONFIGURE_ARGS=("$@")
            handle_pro_file_or_dir_option
            ;;
    esac
}

run_cmake() {
    local build_tgt=$(sb2 -t $OPT_TARGET gcc -dumpmachine)
    build_tgt=${build_tgt%-gnueabi}

    cp -a "$OPT_SPEC" "$TMP_SPEC"

    # get rid of potential windows linefeeds
    sed -i "s/\x0D$//g" "$TMP_SPEC"

    maybe_fix_package_version "$TMP_SPEC"

    case $CMAKE_MODE in
        configure)
            maybe_verify_target_dependencies
            init_cmake_wrapper $WRAPPERSDIR/cmake
            init_noop_wrapper $WRAPPERSDIR/make
            ;;
        build)
            init_cmake_wrapper $WRAPPERSDIR/cmake
            init_simple_wrapper $WRAPPERSDIR/make "${CMAKE_EXTRA_BUILD_TOOL_ARGS[@]}" \
                ${CMAKE_BUILD_TARGET:+"$CMAKE_BUILD_TARGET"}
            ;;
        *)
            fatal "Internal error: Invalid value '$CMAKE_MODE' in CMAKE_MODE"
            ;;
    esac

    (
        maybe_cd_to_spec_setup_subdir
        oomadvice sb2 -t $OPT_TARGET env PATH="${WRAPPERSDIR}:${USERWRAPPERSDIR}:${PATH}" rpmbuild \
            --build-in-place --target=$build_tgt \
            --define "noecho 1" \
            --define "_sourcedir $(dirname $OPT_SPEC)" \
            --define "_buildhost $(get_hostname)" \
            -bc --short-circuit \
            "$TMP_SPEC"
    )
}

run_qmake__process_args() {
    QMAKE_EXTRA_ARGS=()
    while [[ "$1" ]]; do
        case "$1" in
            --) shift
                break
                ;;
            *)
                if [[ -e $1 ]]; then
                    OPT_PRO_FILE_OR_DIR="${1%%+(/)}"
                    shift
                fi
                break
                ;;
        esac
    done
    QMAKE_EXTRA_ARGS=("$@")
    handle_pro_file_or_dir_option
}

run_qmake() {
    local build_tgt=$(sb2 -t $OPT_TARGET gcc -dumpmachine)
    build_tgt=${build_tgt%-gnueabi}

    cp -a "$OPT_SPEC" "$TMP_SPEC"

    # get rid of potential windows linefeeds
    sed -i "s/\x0D$//g" "$TMP_SPEC"

    maybe_fix_package_version "$TMP_SPEC"

    # This is a good time to verify the target dependencies as per mb
    maybe_verify_target_dependencies

    init_qmake_wrapper $WRAPPERSDIR/qmake "${QMAKE_EXTRA_ARGS[@]}"
    init_noop_wrapper $WRAPPERSDIR/make

    (
        maybe_cd_to_spec_setup_subdir
        oomadvice sb2 -t $OPT_TARGET env PATH="$WRAPPERSDIR:$USERWRAPPERSDIR:$PATH" rpmbuild \
            --build-in-place --target=$build_tgt \
            --define "noecho 1" \
            --define "_sourcedir $(dirname $OPT_SPEC)" \
            --define "_buildhost $(get_hostname)" \
            -bc --short-circuit \
            "$TMP_SPEC"
    )
}

run_compiledb() {
    cp -a "$OPT_SPEC" "$TMP_SPEC"

    # get rid of potential windows linefeeds
    sed -i "s/\x0D$//g" "$TMP_SPEC"

    maybe_fix_package_version "$TMP_SPEC"

    # This is a good time to verify the target dependencies as per mb
    maybe_verify_target_dependencies

    local build_tgt=$(sb2 -t $OPT_TARGET gcc -dumpmachine)
    build_tgt=${build_tgt%-gnueabi}

    if is_shadow_build; then
        local subdir=$(get_spec_setup_subdir)
        : ${subdir:=.}
        local src_dir=$OPT_SRC_DIR/$subdir

        init_qmake_wrapper $WRAPPERSDIR/qmake
        init_cmake_wrapper $WRAPPERSDIR/cmake

        if [[ -e $src_dir/Makefile.am ]]; then
            init_autotools_wrappers "$subdir"
        fi
    fi

    init_make_compiledb_wrapper $WRAPPERSDIR/make "$@"

    (
        maybe_cd_to_spec_setup_subdir
        oomadvice sb2 -t $OPT_TARGET env PATH="$WRAPPERSDIR:$USERWRAPPERSDIR:$PATH" rpmbuild \
            --build-in-place --target=$build_tgt \
            --define "noecho 1" \
            --define "_sourcedir $(dirname $OPT_SPEC)" \
            --define "_buildhost $(get_hostname)" \
            -bc --short-circuit \
            "$TMP_SPEC" \
            || return

        if [[ -e "$COMPILEDB_INPUT" ]]; then
            compiledb --parse "$COMPILEDB_INPUT" && rm -f "$COMPILEDB_INPUT"
        fi
    )
}

run_make() {
    cp -a "$OPT_SPEC" "$TMP_SPEC"

    # get rid of potential windows linefeeds
    sed -i "s/\x0D$//g" "$TMP_SPEC"

    maybe_fix_package_version "$TMP_SPEC"

    local build_tgt=$(sb2 -t $OPT_TARGET gcc -dumpmachine)
    build_tgt=${build_tgt%-gnueabi}

    init_noop_wrapper $WRAPPERSDIR/qmake
    CMAKE_MODE=build
    CMAKE_EXTRA_BUILD_TOOL_ARGS=("$@")
    init_cmake_wrapper $WRAPPERSDIR/cmake
    init_simple_wrapper $WRAPPERSDIR/make "$@"

    (
        maybe_cd_to_spec_setup_subdir
        oomadvice sb2 -t $OPT_TARGET env PATH="$WRAPPERSDIR:$USERWRAPPERSDIR:$PATH" rpmbuild \
            --build-in-place --target=$build_tgt \
            --define "noecho 1" \
            --define "_sourcedir $(dirname $OPT_SPEC)" \
            --define "_buildhost $(get_hostname)" \
            -bc --short-circuit \
            "$TMP_SPEC"
    )
}

run_make_install() {
    # Internal, intentionally undocumented
    local maybe_nocheck=--nocheck
    if [[ ${1:-} == --check ]]; then
        local maybe_nocheck=
        shift
    fi

    local build_tgt=$(sb2 -t $OPT_TARGET gcc -dumpmachine)
    build_tgt=${build_tgt%-gnueabi}

    cp -a "$OPT_SPEC" "$TMP_SPEC"

    # get rid of potential windows linefeeds
    sed -i "s/\x0D$//g" "$TMP_SPEC"

    maybe_fix_package_version "$TMP_SPEC"

    # Install to buildroot which should be rsync'ed to /opt/sdk/$package on device
    (
        maybe_cd_to_spec_setup_subdir
        oomadvice sb2 -t $OPT_TARGET rpmbuild --build-in-place --target=$build_tgt \
            --define "noecho 1" \
            --define "_sourcedir $(dirname $OPT_SPEC)" \
            --define "_buildhost $(get_hostname)" \
            --define "_skip_install_processing 1" \
            --buildroot="$buildroot" \
            -bi --short-circuit $maybe_nocheck \
            "$TMP_SPEC"
    )
}

run_package__process_args() {
    PACKAGE_NOCHECK_ARGS=()

    while [[ $# -ne 0 ]]; do
        case $1 in
            --no-check)
                PACKAGE_NOCHECK_ARGS=(--nocheck)
                ;;
            *)
                fatal "Unexpected argument: $1"
                ;;
        esac
        shift
    done
}

run_package() {
    local build_tgt=$(sb2 -t $OPT_TARGET gcc -dumpmachine)
    build_tgt=${build_tgt%-gnueabi}

    cp -a "$OPT_SPEC" "$TMP_SPEC"

    try_to_make_changelog >> "$TMP_SPEC"

    # get rid of potential windows linefeeds
    sed -i "s/\x0D$//g" "$TMP_SPEC"

    maybe_fix_package_version "$TMP_SPEC"

    (
        maybe_increment_build_number
        maybe_cd_to_spec_setup_subdir
        [[ $OPT_CLEAN_OUTPUTDIR ]] && rm -f "$OPT_OUTPUTDIR/"*.rpm;
        oomadvice sb2 -t $OPT_TARGET rpmbuild --build-in-place --target=$build_tgt \
            --define "noecho 1" \
            --define "_rpmdir $OPT_OUTPUTDIR" \
            --define "_sourcedir $(dirname $OPT_SPEC)" \
            --define "_rpmfilename %%{name}-%%{version}-%%{release}.%%{arch}.rpm" \
            --define "_buildhost $(get_hostname)" \
            --buildroot="$buildroot" \
            -bb --noprep --nobuildstage "${PACKAGE_NOCHECK_ARGS[@]}" --noclean \
            "$TMP_SPEC"
    )
}

run_build_shell() {
    if [[ $# -gt 0 ]]; then
        oomadvice sb2 -t $OPT_TARGET -- "$@"
    else
        # Keep PS1 aligned with `sdk-manage maintain`
        sb2 -t $OPT_TARGET -- env PS1="[$OPT_ORIGINAL_TARGET] \W $ " /bin/bash --noprofile --norc
    fi
}

run_deploy() {
    [[ $device_type ]] || fatal "No device specified"
    [[ -e $STATEDIR/spec ]] || fatal "No previous build found"

    local method_opt= all_opt= patterns=('-*-debug@(info|source)')
    while [[ $# -ne 0 ]]; do
        case $1 in
            --sdk | --pkcon | --zypper | --rsync | --manual )
                [[ ! $method_opt ]] || fatal "Cannot combine '$1' and '$method_opt'"
                method_opt=$1
                ;;
            --all )
                all_opt=$1
                ;;
            --debug )
                patterns=()
                ;;
            -- )
                shift
                patterns+=("$@")
                break
                ;;
            *)
                patterns+=("$@")
                break
                ;;
        esac
        shift
    done

    [[ ! $all_opt || $method_opt != --rsync ]] || fatal "Cannot use '--all' with '--rsync'"
    [[ ${method_opt:-} ]] || fatal "Argument expected"

    local retcode=0

    case $method_opt in
        --sdk | --pkcon )
            local method;
            if [[ $method_opt == --sdk ]]; then
                method="sdk-deploy-rpm"
            else
                method="pkcon --plain --noninteractive install-local"
            fi
            ! behind_qtcreator || run_package || return
            rpms=$(find_rpms $all_opt "$OPT_OUTPUTDIR" "$STATEDIR/spec" "${patterns[@]}")
            [[ $rpms ]] || fatal "No package found or none matched the given criteria"
            rsync_as $device_username -av ${rpms} $device_ip:/home/$device_username/RPMS/
            [[ $? -ne 0 ]] && return 1
            device_rpms=$(sed "s,^$OPT_OUTPUTDIR/,RPMS/," <<<"$rpms")
            ssh_as $device_username $method ${device_rpms}
            retcode=$?
            ssh_as $device_username rm -f ${device_rpms}
            ;;
        --zypper )
            ! behind_qtcreator || run_package || return
            rpms=$(find_rpms $all_opt "$OPT_OUTPUTDIR" "$STATEDIR/spec" "${patterns[@]}")
            [[ $rpms ]] || fatal "No package found or none matched the given criteria"
            rsync_as root -av ${rpms} $device_ip:/root/RPMS/
            [[ $? -ne 0 ]] && return 1
            device_rpms=$(sed "s,^$OPT_OUTPUTDIR/,RPMS/," <<<"$rpms")
            ssh_as root zypper --non-interactive --quiet in -f ${device_rpms}
            retcode=$?
            [[ $retcode -eq 106 ]] && retcode=0
            ssh_as root rm -f ${device_rpms}
            ;;
        --rsync )
            ! behind_qtcreator || run_make_install || return
            name=$(get_spec_tag "%{name}")
            rsync_as $device_username -av ${buildroot}/. $device_ip:/opt/sdk/$name
            retcode=$?
            ;;
        --manual )
            ! behind_qtcreator || run_package || return
            rpms=$(find_rpms $all_opt "$OPT_OUTPUTDIR" "$STATEDIR/spec" "${patterns[@]}")
            [[ $rpms ]] || fatal "No package found or none matched the given criteria"
            rsync_as $device_username -av ${rpms} $device_ip:/home/$device_username/RPMS/
            [[ $? -ne 0 ]] && return 1
            retcode=0
            ;;
        *)
            fatal "Internal error: Invalid deployment method: '$1'"
            ;;
    esac

    [[ $retcode -eq 0 ]] || { echo "Deploy failed"; return 1; }
}

run_undeploy__process_args() {
    UNDEPLOY_ALL=
    UNDEPLOY_DRY_RUN=
    UNDEPLOY_METHOD_OPT=
    UNDEPLOY_PATTERNS=()

    [[ $device_type ]] || fatal "No device specified"

    while [[ $# -ne 0 ]]; do
        case $1 in
            --sdk | --pkcon | --rpm | --rsync | --zypper )
                if [[ $UNDEPLOY_METHOD_OPT ]]; then
                    fatal "Cannot combine '$1' and '$UNDEPLOY_METHOD_OPT'"
                fi
                UNDEPLOY_METHOD_OPT=$1
                ;;
            --all )
                UNDEPLOY_ALL=1
                ;;
            -n | --dry-run )
                UNDEPLOY_DRY_RUN=1
                ;;
            -- )
                shift
                UNDEPLOY_PATTERNS+=("$@")
                break
                ;;
            * )
                while [[ $# -ne 0 ]]; do
                    case $1 in
                        # Try to avoid bad surprices
                        -n | --dry-run )
                            fatal "Options must precede patterns"
                            ;;
                        * )
                            UNDEPLOY_PATTERNS+=("$1")
                            ;;
                    esac
                    shift
                done
                break
                ;;
        esac
        shift
    done

    [[ $UNDEPLOY_METHOD_OPT ]] || fatal "Argument expected"

    if [[ ! $UNDEPLOY_ALL ]]; then
        [[ -e $STATEDIR/spec ]] || fatal "No previous build found"
        OPT_NEEDSPEC=1
    fi
}

run_undeploy() {
    local user=
    case $UNDEPLOY_METHOD_OPT in
        --sdk | --pkcon | --rsync )
            user=$device_username
            ;;
        --rpm | --zypper )
            user=root
            ;;
        * )
            fatal "Internal error: Invalid undeploy method '$UNDEPLOY_METHOD_OPT'"
            ;;
    esac

    local candidates=
    if [[ $UNDEPLOY_METHOD_OPT == --rsync ]]; then
        # Consider all directories under /opt/sdk
        candidates=$(ssh_as "$user" ls /opt/sdk)
        candidates=$(sed 's,.*,& /opt/sdk/&,' <<<"$candidates")
    else
        # Consider all packages with matching BUILDHOST
        local format='%{BUILDHOST} %{SOURCERPM} %{NAME} %{EVR}\n'
        candidates=$(ssh_as "$user" rpm -q --queryformat "$format" -a)
        candidates=$(
            [[ $candidates ]] || exit 0
            wanted_buildhost=$(get_hostname)
            while read buildhost rest; do
                [[ $buildhost == "$wanted_buildhost" ]] && printf '%s\n' "$rest"
            done <<<"$candidates"
        )
    fi

    # candidates now contains [{src_name, name, maybe_evr}], optionally filter
    # by src_name, discard src_name.
    if [[ $UNDEPLOY_ALL ]]; then
        candidates=$(cut -d' ' -f2- <<<"$candidates")
    else
        candidates=$(
            [[ $candidates ]] || exit 0
            local wanted_src_name=$(get_spec_tag "%{name}")
            while read src_name rest; do
                [[ $src_name =~ ^"$wanted_src_name"(-[0-9].*)?$ ]] && printf '%s\n' "$rest"
            done <<<"$candidates"
        )
    fi

    # candidates now contains [{name, maybe_evr}], optionally filter by name
    if [[ ${#UNDEPLOY_PATTERNS[*]} -gt 0 ]]; then
        candidates=$(
            [[ $candidates ]] || exit 0
            while read name maybe_evr; do
                if match_multi "$name" "${UNDEPLOY_PATTERNS[@]}"; then
                    printf "%s %s\n" "$name" "$maybe_evr"
                fi
            done <<<"$candidates"
        )
    fi

    if [[ $UNDEPLOY_DRY_RUN ]]; then
        if [[ ! $candidates ]]; then
            echo "No candidate for removal found"
            return
        else
            echo "The following packages would be removed:"
            local name= evr=
            while read name evr; do
                printf '%s%s\n' "$name" "${evr:+-$evr}"
            done <<<"$candidates"
        fi
    fi

    # candidates now contains [{name, maybe_evr}], discard maybe_evr
    candidates=$(cut -d' ' -f1 <<<"$candidates")

    if [[ $UNDEPLOY_METHOD_OPT != --rsync ]]; then
        if ! ssh_as "$user" rpm --test -e $candidates; then
            return 1
        fi
    fi

    if [[ $UNDEPLOY_DRY_RUN ]]; then
        return 0
    fi

    case $UNDEPLOY_METHOD_OPT in
        --sdk )
            ssh_as "$user" sdk-deploy-rpm --undeploy $candidates
            ;;
        --pkcon )
            ssh_as "$user" pkcon --plain --noninteractive remove $candidates
            ;;
        --rpm )
            ssh_as "$user" rpm -e $candidates
            ;;
        --rsync )
            local unsafe_to_rm_f=$(grep --invert-match '^/opt/sdk/[^.][^/]*$' <<<"$candidates")
            if [[ $unsafe_to_rm_f ]]; then
                fatal "Internal error: Refusing to remove '$unsafe_to_rm_f'"
            fi
            ssh_as "$user" rm -rf $candidates
            ;;
        --zypper )
            ssh_as "$user" zypper --non-interactive rm $candidates
            ;;
    esac
}

run_check__process_args() {
    CHECK_LIST_SUITES=
    check_levels=
    check_suites=
    check_artefacts=()
    while [[ "$1" ]]; do
        case "$1" in
            --list-suites) shift
                CHECK_LIST_SUITES=1
                ;;
            -l|--levels) shift
                [[ $1 ]] || short_usage quit
                check_levels=$1
                shift
                ;;
            -s|--suites) shift
                [[ $1 ]] || short_usage quit
                check_suites=$1
                shift
                ;;
            --) shift
                check_artefacts+=(${@:+"$@"})
                break
                ;;
            -*)
                short_usage quit
                ;;
            *)
                check_artefacts+=("$1")
                shift
                ;;
        esac
    done

    if [[ ! $CHECK_LIST_SUITES ]]; then
        check_levels=$(combine_set_update_recipes "$OPT_CHECK_LEVELS" "$check_levels")
        check_suites=$(combine_set_update_recipes "$OPT_CHECK_SUITES" "$check_suites")

        run_check__process_args_helper "$check_levels" "$check_suites" \
            ${check_artefacts:+"${check_artefacts[@]}"}

        notice "Testing on levels: ${CHECK_LEVELS[*]}"
        notice "Testing with suites: ${CHECK_SUITES[*]}"

        if set_contains CHECK_LEVELS "$CHECK_LEVEL_PACKAGE" && [[ ${#CHECK_PACKAGE_ARTEFACTS[*]} -eq 0 ]] \
            || set_contains CHECK_LEVELS "$CHECK_LEVEL_UNIT"; then
            OPT_NEEDSPEC=1
        fi
    fi
}

run_check__process_args_helper() {
    local check_levels=$1
    local check_suites=$2
    local check_artefacts=("${@:3}")

    CHECK_SOURCE_ARTEFACT=
    CHECK_PACKAGE_ARTEFACTS=()
    for artefact in ${check_artefacts:+"${check_artefacts[@]}"}; do
        if [[ ! -e $artefact ]]; then
            fatal "No such file or directory: '$artefact'"
        fi
        if [[ $artefact == *.rpm && -f $artefact ]]; then
            CHECK_PACKAGE_ARTEFACTS+=("$artefact")
        elif [[ -d $artefact ]]; then
            if [[ $CHECK_SOURCE_ARTEFACT ]]; then
                fatal "Multiple artefacts of type 'source tree' specified"
            fi
            CHECK_SOURCE_ARTEFACT=$artefact
        else
            fatal "Unhandled type of artefact '$artefact'"
        fi
    done

    if [[ $CHECK_SOURCE_ARTEFACT && ${#CHECK_PACKAGE_ARTEFACTS[*]} -eq 0 ]]; then
        CHECK_LEVELS=($CHECK_LEVEL_SOURCE)
    elif [[ ! $CHECK_SOURCE_ARTEFACT && ${#CHECK_PACKAGE_ARTEFACTS[*]} -ne 0 ]]; then
        CHECK_LEVELS=($CHECK_LEVEL_PACKAGE)
    else
        CHECK_LEVELS=($CHECK_LEVEL_SOURCE $CHECK_LEVEL_PACKAGE)
    fi
    if [[ $check_levels ]]; then
        local expanded_check_levels=() level=
        for level in ${check_levels//,/ }; do
            local op=
            if [[ $level = [-+]* ]]; then
                op=${level:0:1}
                level=${level:1}
            fi
            case $level in
                $CHECK_LEVEL_STATIC)
                    expanded_check_levels+=($op$CHECK_LEVEL_SOURCE $op$CHECK_LEVEL_PACKAGE) ;;
                $CHECK_LEVEL_DYNAMIC)
                    expanded_check_levels+=($op$CHECK_LEVEL_UNIT $op$CHECK_LEVEL_SYSTEM) ;;
                $CHECK_LEVEL_SOURCE|$CHECK_LEVEL_PACKAGE|$CHECK_LEVEL_UNIT|$CHECK_LEVEL_SYSTEM)
                    expanded_check_levels+=($op$level) ;;
                *)
                    fatal "Not a recognized test level '$level'" ;;
            esac
        done
        set_update CHECK_LEVELS ${expanded_check_levels[*]}
    fi
    if [[ ${#CHECK_LEVELS[*]} -eq 0 ]]; then
        fatal "No test level selected"
    fi

    local rpmvalidation_suites_info=$(rpmvalidation --target "$OPT_TARGET" --list-suites)
    RPMVALIDATION_ALL_SUITES=($(awk '{print $1}' <<<"$rpmvalidation_suites_info"))
    local rpmvalidation_essential_suites=($(awk -v essential="$CHECK_ESSENTIAL" \
        '($2 == essential) { print $1 }' <<<"$rpmvalidation_suites_info"))
    local known_suites=($CHECK_RPMSPEC $CHECK_RPMLINT ${RPMVALIDATION_ALL_SUITES[*]})

    CHECK_SUITES=($CHECK_RPMSPEC $CHECK_RPMLINT ${rpmvalidation_essential_suites[*]})
    if [[ $check_suites ]]; then
        for suite in ${check_suites//[,+-]/ }; do
            if ! set_contains known_suites "$suite"; then
                fatal "Not a known test suite '$suite'"
            fi
        done
        set_update CHECK_SUITES ${check_suites//,/ }
    fi
    if [[ ${#CHECK_SUITES[*]} -eq 0 ]]; then
        fatal "No test suite selected"
    fi
}

run_check() {
    if [[ $CHECK_LIST_SUITES ]]; then
        local US=$'\x1F'
        print_suite() ( IFS=$US; printf '%s\n' "$*"; )
        local raw=$(
            print_suite NAME ESSENTIAL LEVELS URL DESCRIPTION
            {
                print_suite "$CHECK_RPMSPEC" "$CHECK_ESSENTIAL" "$CHECK_LEVEL_UNIT" "-" \
                    "Execute the %check section of the .spec file"

                print_suite "$CHECK_RPMLINT" "$CHECK_ESSENTIAL" "$CHECK_LEVEL_PACKAGE" "-" \
                    "Check for common packaging problems with rpmlint"

                local name= essential= url= description=
                rpmvalidation --target "$OPT_TARGET" --list-suites \
                    |while read name essential url description; do
                        print_suite "$name" "$essential" "$CHECK_LEVEL_PACKAGE" "$url" "$description"
                    done
            } |sort --field-separator "$US" --key 1,1
        )

        local odd=$(cut -d "$US" -f 1-4 <<<"$raw" |column --table --separator "$US")
        local even=$(cut -d "$US" -f 5 <<<"$raw")
        paste -d $'\n' <(cat <<<"$odd") <(cat <<<"$even") |sed '2~2s/^/    /; 2d'
        return
    fi

    local rc=0 done_count=0

    if set_contains CHECK_LEVELS "$CHECK_LEVEL_UNIT"; then
        if set_contains CHECK_SUITES "$CHECK_RPMSPEC"; then
            let done_count++
            run_make_install --check || rc=1
        fi
    fi

    if set_contains CHECK_LEVELS "$CHECK_LEVEL_PACKAGE"; then
        local selected_rpmvalidation_suites=()
        set_intersect selected_rpmvalidation_suites RPMVALIDATION_ALL_SUITES CHECK_SUITES
        selected_rpmvalidation_suites=$(IFS=,; printf '%s' "${selected_rpmvalidation_suites[*]}")

        local have_selected_suites=
        if [[ $selected_rpmvalidation_suites ]] \
                || set_contains CHECK_SUITES "$CHECK_RPMLINT"; then
            have_selected_suites=1
        fi

        local packages=
        if [[ $have_selected_suites ]]; then
            packages=(${CHECK_PACKAGE_ARTEFACTS:+"${CHECK_PACKAGE_ARTEFACTS[@]}"})
            if [[ ${#packages[*]} -eq 0 ]]; then
                if [[ ! -e $STATEDIR/spec ]]; then
                    notice "No previous build found and no package to verify specified explicitly"
                else
                    packages=($(find_rpms "$OPT_OUTPUTDIR" "$STATEDIR/spec" \
                        '-*-debug@(source|info)'))
                    if [[ ${#packages[*]} -eq 0 ]]; then
                        notice "No packages found and none specified explicitly"
                    fi
                fi
            fi
        fi

        local package=

        if [[ $selected_rpmvalidation_suites ]]; then
            for package in "${packages[@]}"; do
                let done_count++
                rpmvalidation -t "$OPT_TARGET" --suites "$selected_rpmvalidation_suites" "$package" \
                    || rc=1
            done
        fi

        if set_contains CHECK_SUITES "$CHECK_RPMLINT"; then
            for package in "${packages[@]}"; do
                let done_count++
                sb2 -t "$OPT_TARGET" -m sdk-build+pp rpmlint "$package" || rc=1
            done
        fi
    fi

    # The other levels are currently unimplemented

    if [[ $done_count -eq 0 ]]; then
        fatal "None of the selected test suites operate on the selected test levels. Nothing to do."
    fi

    return $rc
}

get_shared_dir() {
    echo "$OPT_SHARED_DIR"
}

inside_build_engine() [[ -f /etc/mer-sdk-vbox ]]
inside_git_worktree() { git_ status &>/dev/null; }

behind_qtcreator() {
    # Consider this the default frontend for backward compatibility
    inside_build_engine && [[ ! $SAILFISH_SDK_FRONTEND || $SAILFISH_SDK_FRONTEND == qtcreator ]]
}
behind_sfdk() {
    inside_build_engine && [[ $SAILFISH_SDK_FRONTEND == sfdk ]]
}

# Symlink creation under VirtualBox shared folder shared from Windows requires special permissions
# which are not always granted
maybe_symlink_create() {
    local target=$1 maybe_symlink=$2
    if inside_build_engine; then
        ln -sfn "$target" "$maybe_symlink" &>/dev/null || printf '%s' "$target" > "$maybe_symlink"
    else
        ln -sfn "$target" "$maybe_symlink"
    fi
}

maybe_symlink_read() {
    local maybe_symlink=$1
    if [[ -L $maybe_symlink ]]; then
        readlink -f "$maybe_symlink"
    else
        cat "$maybe_symlink"
    fi
}

# this is same as basename $0
ME=${0/#*\//}

DEF_TASK='git:^[[:alpha:]]{2,5}[[:digit:]]{3,}'

# option variables
OPT_SPEC=
OPT_TARGET=
OPT_ORIGINAL_TARGET=
OPT_SNAPSHOT=
OPT_SNAPSHOT_SUFFIX=
OPT_NO_SNAPSHOT=
OPT_DEVICE=
OPT_OUTPUTDIR=$(readlink -f ./RPMS)
OPT_CLEAN_OUTPUTDIR=1
OPT_SEARCH_OUTPUTDIR=
OPT_SEARCH_OUTPUTDIR_VERBOSITY=verbose
OPT_OUTPUT_PREFIX=
OPT_PKGDIR="./rpm"
OPT_PRO_FILE_OR_DIR=
OPT_SRC_DIR=
OPT_NEEDSPEC=
OPT_NEEDTARGET=
OPT_FIX_VERSION=
OPT_FIX_VERSION_HINT=
OPT_NO_FIX_VERSION=
OPT_GIT_CHANGE_LOG=
OPT_GIT_CHANGE_LOG_ARGS=
OPT_SHARED_DIR=/etc/mersdk/share
OPT_INC_BUILD_NUMBER=0
OPT_PULL_BUILD_REQUIRES=1
OPT_WRAP=()
OPT_CHECK_LEVELS=
OPT_CHECK_SUITES=

STATEDIR=$PWD/.mb2
TMP_SPEC=$STATEDIR/spec
COMPILEDB_INPUT=$STATEDIR/compiledb-input.txt
SNAPSHOT_POOL_SUFFIX=mb2.XXX
SNAPSHOT_POOL_SIZE=5

CHECK_LEVEL_SOURCE=source
CHECK_LEVEL_PACKAGE=package
CHECK_LEVEL_STATIC=static
CHECK_LEVEL_UNIT=unit
CHECK_LEVEL_SYSTEM=system
CHECK_LEVEL_DYNAMIC=dynamic

CHECK_ESSENTIAL=Essential
CHECK_OPTIONAL=Optional

CHECK_RPMSPEC=rpmspec
CHECK_RPMLINT=rpmlint

AUTOTOOLS=(autoreconf autoconf autoheader aclocal automake autopoint libtoolize)

# The working directory inside build engine is noexec and symlink creation under VirtualBox
# shared folder shared from Windows requires special permissions
if inside_build_engine; then
    WRAPPERSDIR=$HOME/.mb2/wrappers${PWD#"$HOME"}
    USERWRAPPERSDIR=$HOME/.mb2/user-wrappers${PWD#"$HOME"}
else
    WRAPPERSDIR=$STATEDIR/wrappers
    USERWRAPPERSDIR=$STATEDIR/user-wrappers
fi

# Virtualbox environment will install in this hardcoded location
if inside_build_engine; then
    # Intersperse with quotes to avoid /usr/lib/rpm/check-buildroot to complain
    # when building sdk-setup under build engine
    buildroot=/home/''deploy/installroot
else
    buildroot="$PWD/installroot"
fi

################################################################################
if [[ $1 != --self-test ]]; then  ###  M A I N  EXECUTION BEGINS HERE  #########
################################################################################

# The project-dir-or-file command line option serves just one purpose: to locate the source tree
# when doing a shadow build.  Including the file name is optional and takes no effect. If multiple
# .pro files exist in the directory, the selection is done inside the .spec file, mentioning one on
# qmake command line.
#
# An exception applies if there is no .spec file. In this case the qmake and make commands behave as
# plain qmake/make invocations, just wrapped with sb2, and the project-dir-or-file option is
# forwarded to qmake without modifications.
#
# If this is called with an empty argument, the default settings is restored.
handle_pro_file_or_dir_option() {
    rm -f "$STATEDIR/src"

    if [[ ! $OPT_PRO_FILE_OR_DIR ]]; then
        return
    fi

    local pro_dir=
    if [[ -d $OPT_PRO_FILE_OR_DIR ]]; then
        pro_dir=$(readlink -f "$OPT_PRO_FILE_OR_DIR")
    else
        pro_dir=$(dirname "$(readlink -f "$OPT_PRO_FILE_OR_DIR")")
    fi

    local src_dir=
    local dir=$pro_dir
    while true; do
        if [[ -d $dir/rpm && $(find "$dir/rpm" -maxdepth 1 -name '*.spec' -o -name '*.yaml') ]]; then
            src_dir=$dir
            break
        fi
        # Skip any "rpm" ancestor in path to avoid misintepreting it as THE rpm directory
        while [[ $(basename "$dir") == rpm ]]; do
            dir=$(dirname "$dir")
        done
        dir=$(dirname "$dir")
        # For in-place builds do not search above the CWD, for shadow builds do not search above
        # common prefix
        if [[ $(readlink -f "$PWD") == "$dir"/* ]]; then
            break
        fi
    done

    # Silently fall back to the directory where the project file resides - some commands can be used
    # without spec file
    : ${src_dir:=$pro_dir}

    # The project file/directory might be specified explicitly for non-shadow builds as well
    if [[ $src_dir != "$(readlink -f "$PWD")" ]]; then
        maybe_symlink_create "$src_dir" "$STATEDIR/src"
    fi
}

maybe_restore_shadow_build() {
    if [[ -e $STATEDIR/src ]]; then
        OPT_SRC_DIR=$(maybe_symlink_read "$STATEDIR/src")
        OPT_PKGDIR=$OPT_SRC_DIR/rpm
    fi
}

is_shadow_build() [[ -e $STATEDIR/src ]]

while [[ "$1" ]]; do
    # only set variables in this loop
    case "$1" in
        "-t" | "--target") shift
            OPT_TARGET="$1"; shift
            ;;
        "-f" | "--shared-folder") shift
            OPT_SHARED_DIR="${1%%+(/)}"; shift
            ;;
        "-d" | "--device") shift
            OPT_DEVICE="$1"; shift
            ;;
        "-o" | "--outputdir" | "--output-dir")
            if [[ $1 == --outputdir ]]; then
                notice "The '$1' option is deprecated. Use '--output-dir' instead."
            fi
            shift
            [[ -d "$1" ]] || fatal "'$1' is not a directory"
            OPT_OUTPUTDIR="${1%%+(/)}"; shift
            OPT_OUTPUT_PREFIX=
            OPT_CLEAN_OUTPUTDIR=
            OPT_SEARCH_OUTPUTDIR=1
            ;;
        "-O" | "--output-prefix") shift
            [[ -d "$1" ]] || fatal "'$1' is not a directory"
            OPT_OUTPUT_PREFIX="${1%%+(/)}"; shift
            OPT_OUTPUTDIR=
            OPT_CLEAN_OUTPUTDIR=
            OPT_SEARCH_OUTPUTDIR=1
            ;;
        "-p" | "--projectdir")
            notice "The '$1' option is deprecated. Try '$ME --help' for more information."
            [[ -d "$2" ]] || fatal "'$2' is not a directory"
            OPT_PRO_FILE_OR_DIR="${2%%+(/)}"
            shift 2
            ;;
        "--search-output-dir") shift
            OPT_SEARCH_OUTPUTDIR=1
            ;;
        "--search-output-dir"=* )
            OPT_SEARCH_OUTPUTDIR=1
            OPT_SEARCH_OUTPUTDIR_VERBOSITY=${1#*=}
            if [[ $OPT_SEARCH_OUTPUTDIR_VERBOSITY != verbose &&
                    $OPT_SEARCH_OUTPUTDIR_VERBOSITY != quiet ]]; then
                fatal "Unexpected argument to '--search-output-dir': '$OPT_SEARCH_OUTPUTDIR_VERBOSITY'"
            fi
            shift
            ;;
        "--no-search-output-dir") shift
            OPT_SEARCH_OUTPUTDIR=
            ;;
        "-s" | "--specfile" ) shift
            OPT_SPEC="$1"; shift
            ;;
        "-S" | "--snapshot" ) shift
            OPT_SNAPSHOT=1
            OPT_SNAPSHOT_SUFFIX=
            ;;
        "-S"=* | "--snapshot"=* )
            OPT_SNAPSHOT=1
            OPT_SNAPSHOT_SUFFIX=${1#*=}
            shift
            ;;
        "--no-snapshot" ) shift
            OPT_SNAPSHOT=
            OPT_SNAPSHOT_SUFFIX=
            OPT_NO_SNAPSHOT=1
            ;;
        "-T" | "--task" ) shift
            OPT_TASK=$DEF_TASK
            ;;
        "-T"=* | "--task"=* )
            OPT_TASK=${1#*=}
            shift
            ;;
        "--no-task" ) shift
            OPT_TASK=
            ;;
        "--wrap" )
            [[ $2 == *?:?* ]] || fatal "The '$1' options requires an argument"
            OPT_WRAP+=("$2")
            shift 2
            ;;
        "-i" | "--increment" ) shift
            OPT_INC_BUILD_NUMBER=1
            ;;
        "-P" | "--pedantic" )
            notice "The '$1' option is deprecated and does nothing currently"
            shift
            ;;
        "-x" | "--fix-version" ) shift
            OPT_FIX_VERSION=1
            OPT_FIX_VERSION_HINT=
            OPT_NO_FIX_VERSION=
            ;;
        "-x="* | "--fix-version="* )
            OPT_FIX_VERSION=1
            OPT_FIX_VERSION_HINT=${1#*=}
            OPT_NO_FIX_VERSION=
            shift
            ;;
        "-X" | "--no-fix-version" ) shift
            OPT_FIX_VERSION=
            OPT_FIX_VERSION_HINT=
            OPT_NO_FIX_VERSION=1
            ;;
        "-n" | "--no-deps" | "--no-pull-build-requires" ) shift
            if [[ $1 == --no-deps ]]; then
                notice "The '$1' option is deprecated. Use '--no-pull-build-requires|-n' instead."
            fi
            OPT_PULL_BUILD_REQUIRES=
            ;;
        "-c" | "--git-change-log" ) shift
            OPT_GIT_CHANGE_LOG=1
            ;;
        "-c="* | "--git-change-log="* )
            OPT_GIT_CHANGE_LOG=1
            OPT_GIT_CHANGE_LOG_ARGS="${1#*=}"
            shift
            ;;
        "-m" | "--submodule" )
            notice "The '$1' option is deprecated and does nothing currently"
            shift 2
            ;;
        "--check-levels" )
            [[ $2 ]] || fatal "The '$1' option requires an argument"
            OPT_CHECK_LEVELS=$2
            shift 2
            ;;
        "--check-suites" )
            [[ $2 ]] || fatal "The '$1' option requires an argument"
            OPT_CHECK_SUITES=$2
            shift 2
            ;;
        # Note that OPT_NEEDSPEC and OPT_NEEDTARGET may be additionaly set later
        # during command options parsing!
        build | build-requires | cmake | compiledb | deploy | install | installdeps \
            | make | make-install | package | prep | prepare | qmake | rpm )
            OPT_NEEDSPEC=1
            OPT_NEEDTARGET=1
            break
            ;;
        apply )
            OPT_NEEDSPEC=1
            break
            ;;
        check | build-shell )
            OPT_NEEDTARGET=1
            break;
            ;;
        run | ssh | undeploy )
            break
            ;;
        --version )
            echo "$ME, version VERSION_FROM_SPEC"
            exit 0
            ;;
        --help )
            usage
            exit 0
            ;;
        *)
            short_usage quit
            ;;
    esac
done

mkdir -p "$STATEDIR" || exit
echo '*' > "$STATEDIR/.gitignore"

if [[ -n "$OPT_SPEC" ]]; then
    try_to_make_spec "$OPT_SPEC"
    [[ -f "$OPT_SPEC" ]] || fatal "'$OPT_SPEC' does not exist (and could not be made from a .yaml)"
fi

if [[ -n "$OPT_DEVICE" ]]; then
    if [[ ! -f $(get_shared_dir)/devices.xml ]]; then
        fatal "Unable to open '$(get_shared_dir)/devices.xml'." \
            "Please launch Qt Creator for the first time to finish the installation"
    fi
    if ! get_device "$OPT_DEVICE" < $(get_shared_dir)/devices.xml; then
        fatal "'$OPT_DEVICE' is not a known device"
    fi
fi

if [[ ! "$OPT_TARGET" ]]; then
    if [[ -f ~/.scratchbox2/config ]]; then
        . ~/.scratchbox2/config
        OPT_TARGET=$DEFAULT_TARGET
    fi
    [[ "$OPT_TARGET" ]] || fatal "No build target specified and there is no default one"
fi

OPT_ORIGINAL_TARGET=$OPT_TARGET

[[ -d ~/.scratchbox2/$OPT_TARGET ]] || fatal "'$OPT_TARGET' is not a known build target"

if [[ $OPT_SNAPSHOT ]]; then
    switch_to_snapshot || fatal "Failed to init build target snapshot"
elif [[ ! $OPT_NO_SNAPSHOT && ! $MB2_SELF_TEST_RUN ]]; then
    if [[ $(sdk-manage target list --snapshots-of "$OPT_TARGET") ]]; then
        if [[ $OPT_NEEDTARGET ]]; then
            echo >&2 "The '$OPT_TARGET' target has snapshots - refusing to use it directly."
            exit 1
        else
            # Just in case we failed to set OPT_NEEDTARGET correctly
            OPT_TARGET+=--some-garbage-to-prevent-accidental-use
        fi
    fi
fi

case "$1" in
    build | qmake | cmake | make | make-install | install | package | rpm | deploy | undeploy \
            | build-requires | installdeps | prepare | prep | apply | build-shell | compiledb \
            | check )
        if [[ $1 == install ]]; then
            notice "The 'install' command is deprecated. Use 'make-install' instead."
            set -- make-install "${@:2}"
        fi
        if [[ $1 == installdeps ]]; then
            notice "The 'installdeps' command is deprecated. Use 'build-requires' instead."
            set -- build-requires "${@:2}"
        fi
        if [[ $1 == rpm ]]; then
            notice "The 'rpm' command is deprecated. Use 'package' instead."
            set -- package "${@:2}"
        fi
        if [[ $1 == prep ]]; then
            notice "The 'prep' command is deprecated. Use 'prepare' instead."
            set -- prepare "${@:2}"
        fi
        cmd=run_${1//-/_}
        shift
        if [[ $(type -t ${cmd}__process_args) == function ]]; then
            ${cmd}__process_args "$@"
            shift $#
        fi
        ;;
    run | ssh )
        if [[ $1 == ssh ]]; then
            notice "The 'ssh' command is deprecated. Use 'run' instead."
        fi
        shift
        if [[ ! "$OPT_DEVICE" ]]; then
            fatal "No device specified"
        fi
        cmd="ssh_as $device_username"
        ;;
    *)
        short_usage quit
        ;;
esac

maybe_restore_shadow_build

maybe_set_task_name_from_git_branch_name

if [[ $OPT_OUTPUT_PREFIX ]]; then
    OPT_OUTPUTDIR=$OPT_OUTPUT_PREFIX/${OPT_TASK:+$OPT_TASK/}$OPT_ORIGINAL_TARGET
fi

if [[ $OPT_SEARCH_OUTPUTDIR ]]; then
    mkdir -p "$OPT_OUTPUTDIR"
fi

if [[ $OPT_FIX_VERSION_HINT && ! $(git_ tag --list "$OPT_FIX_VERSION_HINT") ]]; then
    fatal "'$OPT_FIX_VERSION_HINT': no such Git tag"
fi

# spec rules are complex:
#  a .spec is required for some but not all operations
#  if -s is given then
#    if it does not exist then specify tries to make it
#    if it exists it will be used
#  if there is a rpm/*.spec then that is used
#  if there is a rpm/*.yaml then a spec is made and used

if [[ $OPT_NEEDSPEC && ! $OPT_SPEC ]]; then
    # set nullglob on so that the shell glob expansions will return
    # empty if files are not found
    shopt -s nullglob
    spec_files=("$OPT_PKGDIR"/*.spec)
    numspec=${#spec_files[@]}
    if [[ $numspec -gt 1 ]]; then
        fatal "Multiple spec files found - please select one."
    elif [[ $numspec -eq 1 ]]; then
        OPT_SPEC="${spec_files[0]?}"
    else
        # No spec, try to find a yaml
        yaml_files=("$OPT_PKGDIR"/*.yaml)
        numyaml=${#yaml_files[@]}
        if [[ $numyaml -eq 1 ]]; then
            theyaml=("$OPT_PKGDIR"/*.yaml)
            try_to_make_spec_from_yaml "${theyaml[0]}"
            spec_files=("$OPT_PKGDIR"/*.spec)
            OPT_SPEC="${spec_files[0]?}"
        else
            fatal "No spec or yaml file found in '$OPT_PKGDIR/'"
        fi
    fi

    # unset nullglob so that any further globbing works normally
    shopt -u nullglob
fi

# Now if there is a spec given, make sure it is up-to-date
if [[ "$OPT_SPEC" ]]; then
    # turn 'OPT_SPEC' into an absolute path
    OPT_SPEC=$(readlink -f "$OPT_SPEC")
    ensure_spec_newer_than_yaml
    warn_if_crlf_is_used
fi

remove_wrappers_dir

$cmd "$@"

##############################################################################
exit; fi ###  S E L F - T E S T  EXECUTION BEGINS HERE #######################
##############################################################################

set -o nounset

SELF=$(readlink -f "$0")

: ${MB2_SELF_TEST_VERBOSE:=}
: ${MB2_SELF_TEST_TS:=}

temp=$(mktemp -d) || exit
trap "rm -rf '$temp'" EXIT
cd "$temp" || exit

mkdir stubs || exit
STUBS_DIR=$(readlink -f stubs)
ORIG_PATH=$PATH
export PATH="$STUBS_DIR:$PATH"

BUILDHOST=$(get_hostname)

if ! which make >/dev/null; then
    fatal "Please install 'make' and try again"
fi

export MB2_SELF_TEST_RUN=1

################################################################################
# Test utils

tc_num=0
tc_failed_num=0

set_up_ts() {
    local ts=$1
    TS_NAME=$2

    if [[ $MB2_SELF_TEST_TS && $TS_NAME != "$MB2_SELF_TEST_TS" ]]; then
        return
    fi

    ${ts}_ts_set_up "${@:3}"
    if [[ $? -ne 0 ]]; then
        fatal "Test suite set-up failed: $ts"
    fi
}

tear_down_ts() {
    local ts=$1

    if [[ $MB2_SELF_TEST_TS && $TS_NAME != "$MB2_SELF_TEST_TS" ]]; then
        return
    fi

    ${ts}_ts_tear_down
    if [[ $? -ne 0 ]]; then
        fatal "Test suite tear-down failed: $ts"
    fi
    TS_NAME=
}

KNOWN_ISSUES=()
KNOWN_ISSUE() {
    KNOWN_ISSUES=(${KNOWN_ISSUES[@]:+"${KNOWN_ISSUES[@]}"} "$1")
}

run_tc() {
    local tc=$1
    TC_NAME=$2
    local args=("${@:3}")

    if [[ $MB2_SELF_TEST_TS && ${TS_NAME:-} != "$MB2_SELF_TEST_TS" ]]; then
        KNOWN_ISSUES=()
        return
    fi

    let tc_num++
    echo "*** Executing test case: ${TS_NAME:+$TS_NAME - }$TC_NAME"

    local known_issue
    for known_issue in ${KNOWN_ISSUES[@]:+"${KNOWN_ISSUES[@]}"}; do
        echo "    Known issue: $known_issue"
    done
    KNOWN_ISSUES=()

    local stderr=
    { stderr=$(${tc}_tc ${args[@]:+"${args[@]}"} 3>&1 1>&2 2>&3 3>&-); } 2>&1
    local rc=$?

    if [[ $rc -ne 0 ]]; then
        let tc_failed_num++
    fi

    if [[ $rc -ne 0 || $MB2_SELF_TEST_VERBOSE ]]; then
        cat <<END
  ** Stderr     ** [[
$stderr
]]
END
    fi

    if [[ $(type -t ${tc}_tc_tear_down) == function ]]; then
        ${tc}_tc_tear_down
        if [[ $? -ne 0 ]]; then
            fatal "Test case tear-down failed: $tc"
        fi
    fi

    return $rc
}

arg_pass_stub_create() {
    while [[ ${1:-} ]]; do
        local name=${1%:*}
        local opts=${1##*:}
        local stub=$STUBS_DIR/$name
        local results=$STUBS_DIR/$name.args

        local redirect='>'
        if [[ $opts == *a* ]]; then
            redirect='>>'
        fi

        touch "$results" || return
        cat >"$stub" <<END || return
#!/bin/bash
echo "stub invoked: \$0 \$(printf "%q " "\$@")" >&2
{ [[ \$# -ne 0 ]] && printf "%q\\n" "\$@"; } $redirect"$results"
exit 0
END
        chmod +x "$stub" || return
        shift
    done
}

arg_pass_stub_remove() {
    while [[ ${1:-} ]]; do
        local stub=$STUBS_DIR/$1
        local results=$STUBS_DIR/$1.args
        rm -f "$stub" || return
        rm -f "$results" || return
        shift
    done
}

arg_pass_stub_results() {
    local results=$STUBS_DIR/$1.args
    [[ -e $results ]] && cat "$results"
}

arg_pass_stub_clear() {
    while [[ ${1:-} ]]; do
        local results=$STUBS_DIR/$1.args
        rm -f "$results" || return
        shift
    done
}

expect_args() {
    [[ $# -ne 0 ]] && printf "%q\n" "$@" || true
}

expect_next_args() {
    echo
    expect_args "$@"
}

sb2_stub() {
    echo "stub invoked: $0 $(printf "%q " "$@")" >&2

    local args=("$@")
    bad_args() {
        echo "stub $0: unexpected arguments: $(printf "%q " "${args[@]}")" >&2
    }

    [[ $1 == -t ]] && shift 2 || { bad_args; return 1; }
    [[ $1 == -m ]] && shift 2
    [[ $1 == -- ]] && shift
    [[ $1 != -* ]] || { bad_args; return 1; }

    env=(env)
    if [[ $1 == env ]]; then
        shift
        while [[ $1 == -* || $1 =~ ^[[:alnum:]_]+= ]]; do
            env+=("$1")
            shift
        done
    fi

    case $1 in
        gcc)
            case $2 in
                -dumpmachine)
                    echo "i486-meego-linux"
                    ;;
                *)
                    bad_args
                    return 1
                    ;;
            esac
            ;;
        make)
            exec "${env[@]}" "$@"
            ;;
        rpmbuild)
            # rpmbuild writes some progress messages to stdout
            exec "${env[@]}" "$@" >&2
            ;;
        rpmspec)
            exec "${env[@]}" "$@"
            ;;
        zypper)
            exec "${env[@]}" "$@"
            ;;
        *)
            bad_args
            return 1
            ;;
    esac
}

sb2_stub_create() {
    cat >"$STUBS_DIR/sb2" <<END || return
#!/bin/bash
$(declare -f sb2_stub)
sb2_stub "\$@"
END
    chmod +x "$STUBS_DIR/sb2" || return
}

sb2_stub_remove() {
    rm -f "$STUBS_DIR/sb2" || return
}

DEFAULT_TARGET=$(. ~/.scratchbox2/config; echo "$DEFAULT_TARGET")
DEFAULT_JOBS=$(getconf _NPROCESSORS_ONLN)

if inside_build_engine; then
    # Assume the first one mentioned is the most recent one
    DEFAULT_DEVICE=$(sed -n 's/.*name="\(Sailfish OS Emulator[^"]*\)".*/\1/; T; p; q' \
        "$(get_shared_dir)/devices.xml")
else
    echo "Note: Skipping test cases involving device connection - not inside a Sailfish OS build engine" >&2
    DEFAULT_DEVICE=
fi

################################################################################
# Test the rpm_quote function

rpm_quote_tc() {
    arg_pass_stub_create make || return

    # Create an minimal spec file
    mkdir rpm || return
    cat >rpm/test.spec <<END || return
Name: test
Version: 1.0
Release: 0
Summary: Test
License: BSD

# This would normally come from the environment
%{!?make:%define make make}

%description
Test

%build
%make "x  y"
END

    rpmbuild -bc --short-circuit --noprep --build-in-place --define "_sourcedir $(readlink -f rpm)" rpm/test.spec \
        --define "make make $(rpm_quote "a b" "c  d" e f)" >&2 || return
    local rc=0 expected= actual= diff=
    expected=$(expect_args "a b" "c  d" e f "x  y")
    actual=$(arg_pass_stub_results make) || return
    if ! diff=$(diff <(cat <<<"$expected") <(cat <<<"$actual")); then
        rc=1
        cat <<END
Test case failed: $TC_NAME
  ** Mismatch   ** [[
$diff
]]
  ** Expected   ** [[
$expected
]]
  ** Actual     ** [[
$actual
]]
END
    fi

    arg_pass_stub_remove make || return
    rm -f rpm/test.spec || return
    rmdir rpm || return

    return $rc
}

run_tc rpm_quote "Test RPM macro escaping"

################################################################################
# Test sb2 argument passing

sb2_arg_pass_ts_set_up() {
    arg_pass_stub_create sb2 || return

    WRAPPERS_PATH="/tmp/@TMPDIR@/.mb2/wrappers:/tmp/@TMPDIR@/.mb2/user-wrappers"

    # Create an empty spec file
    mkdir rpm || return
    : >rpm/test.spec || return
}

sb2_arg_pass_ts_tear_down() {
    arg_pass_stub_remove sb2 || return
    rm -f rpm/test.spec || return
    rmdir rpm || return
    unset WRAPPERS_PATH
}

sb2_arg_pass_tc() {
    local expected=$1
    local args=("${@:2}")

    arg_pass_stub_clear sb2 || return
    "$SELF" "${args[@]}" || return
    local actual_raw= actual= diff=
    actual_raw=$(arg_pass_stub_results sb2) || return
    actual=$(sed -e 's,/home/mersdk/.mb2/wrappers/tmp/tmp\.[[:alnum:]]\+,/tmp/@TMPDIR@/.mb2/wrappers,g' \
                 -e 's,/home/mersdk/.mb2/user-wrappers/tmp/tmp\.[[:alnum:]]\+,/tmp/@TMPDIR@/.mb2/user-wrappers,g' \
                 -e 's,/tmp\.[[:alnum:]]\+,/@TMPDIR@,g' \
                 -e "s,/home/deploy,/tmp/@TMPDIR@,g" <<<"$actual_raw")
    if ! diff=$(diff <(cat <<<"$expected") <(cat <<<"$actual")); then
        cat <<END
Test case failed: $TC_NAME
  ** Command    ** $ME $(quote "${args[@]}")
  ** Mismatch   ** [[
$diff
]]
  ** Expected   ** [[
$expected
]]
  ** Actual     ** [[
$actual
]]
  ** Actual RAW ** [[
$actual_raw
]]
END
        return 1
    fi
}

set_up_ts sb2_arg_pass "Passing arguments to sb2"

KNOWN_ISSUE "Does not disable debug by default (ignores --enable-debug)"
KNOWN_ISSUE "Passes -j without argument"
KNOWN_ISSUE "Silently ignores extra arguments"
run_tc sb2_arg_pass "prepare" \
    "$(expect_args \
        -t "$DEFAULT_TARGET" rpmbuild --build-in-place --target= \
        --define '_smp_mflags -j' \
        --define '_rpmdir /tmp/@TMPDIR@/RPMS' \
        --define '_sourcedir /tmp/@TMPDIR@/rpm' \
        --define '_rpmfilename %%{name}-%%{version}-%%{release}.%%{arch}.rpm' \
        --define "_buildhost $BUILDHOST" \
        --buildroot=/tmp/@TMPDIR@/installroot \
        -bp --short-circuit \
        /tmp/@TMPDIR@/.mb2/spec)" \
    prepare "a b" "c  d" e f

run_tc sb2_arg_pass "build" \
    "$(expect_args \
        -t "$DEFAULT_TARGET" env PATH="$WRAPPERS_PATH:/tmp/@TMPDIR@/stubs:$ORIG_PATH" rpmbuild \
        --build-in-place --target= \
        --define 'debug_package %{nil}' \
        --define "_smp_mflags -j$(rpm_quote "bad  1")" \
        --define '_rpmdir /tmp/@TMPDIR@/RPMS' \
        --define '_sourcedir /tmp/@TMPDIR@/rpm' \
        --define '_rpmfilename %%{name}-%%{version}-%%{release}.%%{arch}.rpm' \
        --define "_buildhost $BUILDHOST" \
        --buildroot=/tmp/@TMPDIR@/installroot \
        -bb \
        /tmp/@TMPDIR@/.mb2/spec \
        "a b" "c  d" e f)" \
    build --doprep -j "bad  1" "a b" "c  d" e f

run_tc sb2_arg_pass "build with debug" \
    "$(expect_args \
        -t "$DEFAULT_TARGET" env PATH="$WRAPPERS_PATH:/tmp/@TMPDIR@/stubs:$ORIG_PATH" rpmbuild \
        --build-in-place --target= \
        --define "_smp_mflags -j$(rpm_quote "bad  1")" \
        --define '_rpmdir /tmp/@TMPDIR@/RPMS' \
        --define '_sourcedir /tmp/@TMPDIR@/rpm' \
        --define '_rpmfilename %%{name}-%%{version}-%%{release}.%%{arch}.rpm' \
        --define "_buildhost $BUILDHOST" \
        --buildroot=/tmp/@TMPDIR@/installroot \
        -bb \
        /tmp/@TMPDIR@/.mb2/spec \
        "a b" "c  d" e f)" \
    build --doprep --enable-debug -j "bad  1" "a b" "c  d" e f

run_tc sb2_arg_pass "qmake" \
    "$(expect_args \
        -t "$DEFAULT_TARGET" env PATH="$WRAPPERS_PATH:/tmp/@TMPDIR@/stubs:$ORIG_PATH" rpmbuild \
        --build-in-place --target= \
        --define 'noecho 1' \
        --define '_sourcedir /tmp/@TMPDIR@/rpm' \
        --define "_buildhost $BUILDHOST" \
        -bc --short-circuit \
        /tmp/@TMPDIR@/.mb2/spec)" \
    qmake "a b" "c  d" e f

run_tc sb2_arg_pass "cmake" \
    "$(expect_args \
        -t "$DEFAULT_TARGET" env PATH="$WRAPPERS_PATH:/tmp/@TMPDIR@/stubs:$ORIG_PATH" rpmbuild \
        --build-in-place --target= \
        --define 'noecho 1' \
        --define '_sourcedir /tmp/@TMPDIR@/rpm' \
        --define "_buildhost $BUILDHOST" \
        -bc --short-circuit \
        /tmp/@TMPDIR@/.mb2/spec)" \
    cmake . "a b" "c  d" e f

run_tc sb2_arg_pass "make" \
    "$(expect_args \
        -t "$DEFAULT_TARGET" env PATH="$WRAPPERS_PATH:/tmp/@TMPDIR@/stubs:$ORIG_PATH" rpmbuild \
        --build-in-place --target= \
        --define 'noecho 1' \
        --define '_sourcedir /tmp/@TMPDIR@/rpm' \
        --define "_buildhost $BUILDHOST" \
        -bc --short-circuit \
        /tmp/@TMPDIR@/.mb2/spec)" \
    make "a b" "c  d" e f

KNOWN_ISSUE "Silently ignores extra arguments"
run_tc sb2_arg_pass "make-install" \
    "$(expect_args \
        -t "$DEFAULT_TARGET" rpmbuild --build-in-place --target= \
        --define 'noecho 1' \
        --define '_sourcedir /tmp/@TMPDIR@/rpm' \
        --define "_buildhost $BUILDHOST" \
        --define '_skip_install_processing 1' \
        --buildroot='/tmp/@TMPDIR@/installroot' \
        -bi --short-circuit --nocheck \
        /tmp/@TMPDIR@/.mb2/spec)" \
    make-install "a b" "c  d" e f

run_tc sb2_arg_pass "package" \
    "$(expect_args \
        -t "$DEFAULT_TARGET" rpmbuild --build-in-place --target= \
        --define 'noecho 1' \
        --define '_rpmdir /tmp/@TMPDIR@/RPMS' \
        --define '_sourcedir /tmp/@TMPDIR@/rpm' \
        --define '_rpmfilename %%{name}-%%{version}-%%{release}.%%{arch}.rpm' \
        --define "_buildhost $BUILDHOST" \
        --buildroot='/tmp/@TMPDIR@/installroot' \
        -bb --noprep --nobuildstage --noclean \
        /tmp/@TMPDIR@/.mb2/spec)" \
    package

tear_down_ts sb2_arg_pass

################################################################################
# Test arguments passing to commands invoked by rpmbuild

rpmbuild_arg_pass_ts_set_up() {
    RPMBUILD_STUBS=(qmake cmake:a make)
    arg_pass_stub_create "${RPMBUILD_STUBS[@]}"
    RPMBUILD_STUBS=("${RPMBUILD_STUBS[@]%:*}")

    sb2_stub_create || return

    # Create a minimal spec file
    mkdir rpm || return
    cat >rpm/test.spec <<END || return
Name:       test

# These would normally come from the environment
%{!?qmake:%define qmake qmake}
%{!?qmake5:%define qmake5 qmake}
%{!?cmake:%define cmake cmake}

# This is to not require meego-rpm-config installed for self-test execution
%global __os_install_post %{nil}

Summary:    Test
Version:    0.1
Release:    1
Group:      Qt/Qt
License:    LICENSE
URL:        http://example.org/
Source0:    %{name}-%{version}.tar.bz2

%description
Test

%prep
%setup -q -n %{name}-%{version}

%build
%qmake5
%cmake .
cmake --build .
make %{?_smp_mflags}

%install
mkdir -p %{buildroot}

%files
%defattr(-,root,root,-)
END
}

rpmbuild_arg_pass_ts_tear_down() {
    arg_pass_stub_remove "${RPMBUILD_STUBS[@]}" || return
    sb2_stub_remove || return
    rm -f rpm/test.spec || return
    rmdir rpm || return
}

rpmbuild_arg_pass_tc() {
    local all_expected=("${@:1:${#RPMBUILD_STUBS[*]}}")
    local args=("${@:1+${#RPMBUILD_STUBS[*]}}")

    local rc=0

    arg_pass_stub_clear "${RPMBUILD_STUBS[@]}"
    "$SELF" "${args[@]}" || return
    local i=
    for ((i=0; i<${#RPMBUILD_STUBS[@]}; i++)); do
        local stub= expected= actual= diff=
        stub=${RPMBUILD_STUBS[i]}
        expected=${all_expected[i]}
        actual=$(arg_pass_stub_results "$stub")
        if ! diff=$(diff <(cat <<<"$expected") <(cat <<<"$actual")); then
            rc=1
            cat <<END
Test case failed: $TC_NAME/$i
  ** Command    ** $ME $(printf "%q " "${args[@]}")
  ** Failed for ** $stub
  ** Mismatch   ** [[
$diff
]]
  ** Expected   ** [[
$expected
]]
  ** Actual     ** [[
$actual
]]
END
        fi
    done

    return $rc
}

set_up_ts rpmbuild_arg_pass "Passing arguments to commands invoked by rpmbuild"

run_tc rpmbuild_arg_pass "build" \
    "$(expect_args )" \
    "$(expect_args .)$(expect_next_args --build .)" \
    "$(expect_args -j"$DEFAULT_JOBS")" \
    build

run_tc rpmbuild_arg_pass "qmake" \
    "$(expect_args "a b" "c  d" e f)" \
    "$(expect_args .)$(expect_next_args --build .)" \
    "$(expect_args )" \
    qmake "a b" "c  d" e f

run_tc rpmbuild_arg_pass "cmake / configure" \
    "$(expect_args )" \
    "$(expect_args . "a b" "c  d" e f)" \
    "$(expect_args )" \
    cmake . "a b" "c  d" e f

maybe_jopt=
if [[ $DEFAULT_JOBS -ne 1 ]]; then
    maybe_jopt=-j$DEFAULT_JOBS
fi

run_tc rpmbuild_arg_pass "cmake / build" \
    "$(expect_args )" \
    "$(expect_args --build . "a b" "c  d" e f -- "g h" "i  j" k l)" \
    "$(expect_args $maybe_jopt "g h" "i  j" k l foo)" \
    cmake --build . --target foo "a b" "c  d" e f -- "g h" "i  j" k l

run_tc rpmbuild_arg_pass "make" \
    "$(expect_args )" \
    "$(expect_args --build . -- "a b" "c  d" e f)" \
    "$(expect_args $maybe_jopt "a b" "c  d" e f)" \
    make "a b" "c  d" e f

tear_down_ts rpmbuild_arg_pass

################################################################################
# Test arguments passing to commands invoked using run|ssh subcommand

ssh_arg_pass_ts_set_up() {
    :
}

ssh_arg_pass_ts_tear_down() {
    :
}

ssh_arg_pass_tc() {
    local expected=$1
    local args=("${@:2}")

    local actual= diff=
    actual=$("$SELF" "${args[@]}")
    if ! diff=$(diff <(cat <<<"$expected") <(cat <<<"$actual")); then
        cat <<END
Test case failed: $TC_NAME
  ** Command    ** $ME $(quote "${args[@]}")
  ** Mismatch   ** [[
$diff
]]
  ** Expected   ** [[
$expected
]]
  ** Actual     ** [[
$actual
]]
END
        return 1
    fi
}

set_up_ts ssh_arg_pass "Passing arguments using run|ssh subcommand"

if [[ $DEFAULT_DEVICE ]]; then
    run_tc ssh_arg_pass "remote - just spaces" \
        "$(printf '%q ' 'a b' 'c  d' e f)" \
        --device "$DEFAULT_DEVICE" run printf '%q ' 'a b' 'c  d' e f

    run_tc ssh_arg_pass "remote - spaces and newlines" \
        "$(printf '%q'$'\n' 'echo b' 'c  d' e f)" \
        --device "$DEFAULT_DEVICE" run printf '%q'$'\n' 'echo b' 'c  d' e f

    run_tc ssh_arg_pass "remote - spaces and backslashes" \
        "$(printf '%q\n' 'a\ b' 'c  d' e f)" \
        --device "$DEFAULT_DEVICE" run printf '%q\n' 'a\ b' 'c  d' e f
fi

tear_down_ts ssh_arg_pass

################################################################################
# Test --fix-version behavior

fix_version_ts_set_up() {
    COMMITS_U=()
    COMMITS_D=()

    get_commit() {
        eval echo \${COMMITS_${1:0:1}[${1:1}]} |grep .
    }

    local i= commit= tag_name= tag_object=

    git init . --quiet || return
    git config user.email "john@doe.com" || return
    git config user.name "John Doe" || return

    git checkout -b upstream --quiet
    for ((i=0; i<=30; i++)); do
        printf "U%02d\n" "$i" > U
        git add U || return
        date="@$(TZ=UTC date --date="2000-01-01 00:00:00 UTC +$i days" +%s) +0000"
        GIT_AUTHOR_DATE=$date GIT_COMMITTER_DATE=$date \
            git commit --message "$(<U)" --quiet || return
        commit=$(git rev-list --max-count=1 --abbrev-commit HEAD) || return
        COMMITS_U=(${COMMITS_U[*]:-} $commit)
    done

    git checkout -b downstream "${COMMITS_U[10]}" --quiet || return
    for ((i=0; i<=20; i++)); do
        if [[ $i -eq 10 ]]; then
            git merge --no-commit "${COMMITS_U[20]}" --quiet 2>/dev/null || return
        fi
        printf "D%02d\n" "$i" > D
        git add D || return
        date="@$(TZ=UTC date --date="2000-01-01 00:00:00 UTC +$((i+10)) days +12 hours" +%s) +0000"
        GIT_AUTHOR_DATE=$date GIT_COMMITTER_DATE=$date \
            git commit --message "$(<D)" --quiet || return
        commit=$(git rev-list --max-count=1 --abbrev-commit HEAD) || return
        COMMITS_D=(${COMMITS_D[*]:-} $commit)
    done

    while [[ ${1:-} ]]; do
        case $1 in
            --tag)
                tag_name=$2
                tag_object=$(get_commit $3) || return
                git tag "$tag_name" "$tag_object" || return
                shift 2
                ;;
            --tag-a)
                tag_name=$2
                tag_object=$(get_commit $3) || return
                tag_annotation="$3"
                git tag -a -m "$tag_annotation" "$tag_name" "$tag_object" || return
                shift 2
                ;;
            *)
                return 1
                ;;
        esac
        shift
    done
}

fix_version_ts_tear_down() {
    unset COMMITS_U COMMITS_D
    unset -f get_commit
    rm -rf .git || return
    rm -f U D dirty || return
}

fix_version_tc() {
    local dirty=$1 head=$2 expected_raw=$3 hint=${4:-}

    head=$(get_commit "$head") || return

    git reset --hard --quiet || return
    git checkout -B downstream "$head" --quiet || return
    if [[ $dirty == dirty ]]; then
        echo dirty >> D
    fi

    local version_file=version
    local last_stash_file=last_stash

    echo "Version:" > $version_file

    (
        git() (
            echo "stub invoked: git" >&2
            if [[ $1 == stash && $2 == create ]]; then
                date="@$(TZ=UTC date --date="2000-12-31 18:00:00 UTC" +%s) +0000"
                GIT_AUTHOR_DATE=$date GIT_COMMITTER_DATE=$date \
                    command git stash create |tee $last_stash_file
            else
                command git "$@"
            fi
        )

        OPT_FIX_VERSION=1
        OPT_FIX_VERSION_HINT=$hint
        OPT_NO_FIX_VERSION=
        maybe_fix_package_version $version_file >&2
    ) || return

    local actual=$(sed 's/^Version: //' $version_file)

    local stash_sha1=
    if [[ -e $last_stash_file ]]; then
        stash_sha1=$(git rev-list --max-count=1 --abbrev-commit "$(<$last_stash_file)")
    fi

    local expected=$expected_raw i=
    for ((i=0; i<=30; i++)); do
        expected=${expected//@U$i@/${COMMITS_U[$i]}}
    done
    for ((i=0; i<=20; i++)); do
        expected=${expected//@D$i@/${COMMITS_D[$i]}}
    done
    expected=${expected//@STASH@/${stash_sha1:-<none>}}

    if [[ $actual != "$expected" ]]; then
        cat <<END
Test case failed: $TC_NAME
  ** Arguments    ** $(printf "%q " "$@")
  ** Expected     ** '$expected'
  ** Actual       ** '$actual'
  ** Expected RAW ** '$expected_raw'
  ** Git-status   ** [[
$(git status)
]]
  ** Git-log      ** [[
$(git log --graph --decorate --pretty=fuller --all ${stash_sha1:-})
]]
END
        return 1
    fi
}

# Works with Git history like this
#
# U00---...---U10---U11---...---U20---U21---...---U30 <-- upstream
#               \                 \
#                D00---D01---...---D10---D11---...---D20 <-- downstream
#
# Upstream commit dates are 2000-01-01 + <num> days 00:00 UTC, downstream commit dates are
# 2000-01-01 + <num+10> days 12:00 UTC, stashes are 2000-12-31 18:00 UTC.

set_up_ts fix_version "Test --fix-version behavior" \
    --tag v0.1 U5 \
    --tag v0.2 U10 \
    --tag v0.3 U15 \
    --tag v0.4 U20 \
    --tag v0.5 U25 \
    --tag mer/v0.2+git1 D5 \
    --tag mer/v0.4+git1 D11 \
    --tag-a mer/v0.4+git2 D15 \
    --tag mer/v0.4+git3 D20

run_tc fix_version "on tag, clean D5"               clean D5  0.2+git1
run_tc fix_version "ahead tag, clean D7"            clean D7  0.2+git1+downstream.2000''01''18''12''00''00.@D7@
run_tc fix_version "ahead tag, dirty D7"            dirty D7  0.2+git1+downstream.2000''12''31''18''00''00.@STASH@
run_tc fix_version "ahead upstream tag, clean D10"  clean D10 0.4+downstream.2000''01''21''12''00''00.@D10@
run_tc fix_version "on tag, clean D11"              clean D11 0.4+git1
run_tc fix_version "on tag, dirty D11"              dirty D11 0.4+git1+downstream.2000''12''31''18''00''00.@STASH@
run_tc fix_version "ahead tag, clean D12"           clean D12 0.4+git1+downstream.2000''01''23''12''00''00.@D12@
run_tc fix_version "ahead tag, dirty D12"           dirty D12 0.4+git1+downstream.2000''12''31''18''00''00.@STASH@
run_tc fix_version "on annotated, clean D15"        clean D15 0.4+git2
run_tc fix_version "ahead annotated, clean D16"     clean D16 0.4+git2+downstream.2000''01''27''12''00''00.@D16@
run_tc fix_version "ahead annotated, dirty D16"     dirty D16 0.4+git2+downstream.2000''12''31''18''00''00.@STASH@
run_tc fix_version "on tag, clean D15 + hint"       clean D15 0.4+git1+downstream.2000''01''26''12''00''00.@D15@    mer/v0.4+git1
run_tc fix_version "on tag, dirty D15 + hint"       dirty D15 0.4+git1+downstream.2000''12''31''18''00''00.@STASH@  mer/v0.4+git1
run_tc fix_version "ahead tag, clean D16 + hint"    clean D16 0.4+git1+downstream.2000''01''27''12''00''00.@D16@    mer/v0.4+git1
run_tc fix_version "ahead tag, dirty D16 + hint"    dirty D16 0.4+git1+downstream.2000''12''31''18''00''00.@STASH@  mer/v0.4+git1

tear_down_ts fix_version

################################################################################
# Test the readarray behavior - simplified version implemented as a shell
# function for compatibility with older BASH

readarray_tc() {
    local expected=('  abc *  def  ' '  g  h  i  ')
    local actual=()
    echo "Note: readarray is a $(type -t readarray)" >&2
    readarray -t actual < <(printf "%s\n" "${expected[@]}")
    if ! (
        [[ ${#expected[*]} -eq ${#actual[*]} ]] || exit
        for ((i=0; i<${#expected[*]}; i++)); do
            [[ ${actual[$i]} == "${expected[$i]}" ]] || exit
        done
        ); then
        cat <<END
Test case failed: $TC_NAME
  ** Expected   ** [[
$(declare -p expected)
]]
  ** Actual     ** [[
$(declare -p actual)
]]
END
        return 1
    fi
}

run_tc readarray "Test readarray behavior"

################################################################################
# Test build phases separation

rpmbuild_phases_ts_set_up() {
    RPMBUILD_STUBS=(my_setup qmake cmake:a make compiledb my_install my_check)
    arg_pass_stub_create "${RPMBUILD_STUBS[@]}"
    RPMBUILD_STUBS=("${RPMBUILD_STUBS[@]%:*}")

    sb2_stub_create || return

    # Create a minimal spec file
    mkdir rpm || return
    cat >rpm/test.spec <<END || return
Name:       test

# These would normally come from the environment
%{!?qmake:%define qmake qmake}
%{!?qmake5:%define qmake5 qmake}
%{!?cmake:%define cmake cmake}

# This is to not require meego-rpm-config installed for self-test execution
%global __os_install_post %{nil}

Summary:    Test
Version:    0.1
Release:    1
Group:      Qt/Qt
License:    LICENSE
URL:        http://example.org/
Source0:    %{name}-%{version}.tar.bz2

%description
Test

%prep
my_setup

%build
%qmake5
%cmake .
cmake --build .
make %{?_smp_mflags}

%install
mkdir -p %{buildroot}
my_install

# Verifies that --noclean is used
touch %{buildroot}/foo

%check
my_check

%files
%defattr(-,root,root,-)
/foo
END
}

rpmbuild_phases_ts_tear_down() {
    arg_pass_stub_remove "${RPMBUILD_STUBS[@]}" || return
    sb2_stub_remove || return
    rm -f rpm/test.spec || return
    rmdir rpm || return
    rm -f RPMS/test-0.1-1.i486.rpm || return
    ! [[ -d RPMS ]] || rmdir RPMS || return
    rm -f "$buildroot/foo" || return
}

rpmbuild_phases_tc() {
    local expected=$1
    local args=("${@:2}")

    arg_pass_stub_clear "${RPMBUILD_STUBS[@]}" || return
    rm -f RPMS/test-0.1-1.i486.rpm || return

    "$SELF" "${args[@]}" || return

    local actual=
    if arg_pass_stub_results my_setup &>/dev/null; then
        actual="+prepare"
    else
        actual="-prepare"
    fi

    if arg_pass_stub_results qmake &>/dev/null; then
        actual="$actual +qmake"
    else
        actual="$actual -qmake"
    fi

    if arg_pass_stub_results cmake |head -n1 |grep -q --line-regexp -F -e .; then
        actual="$actual +cmake-c"
    else
        actual="$actual -cmake-c"
    fi

    if arg_pass_stub_results cmake |grep -q --line-regexp -F -e --build; then
        actual="$actual +cmake-b"
    else
        actual="$actual -cmake-b"
    fi

    if arg_pass_stub_results make |grep -q -F -e --dry-run; then
        actual="$actual ~make"
    elif arg_pass_stub_results make &>/dev/null; then
        actual="$actual +make"
    else
        actual="$actual -make"
    fi

    if arg_pass_stub_results my_install &>/dev/null; then
        actual="$actual +make-install"
    else
        actual="$actual -make-install"
    fi

    if arg_pass_stub_results my_check &>/dev/null; then
        actual="$actual +check"
    else
        actual="$actual -check"
    fi

    if [[ -e RPMS/test-0.1-1.i486.rpm ]]; then
        if rpm -q --requires -p RPMS/test-0.1-1.i486.rpm |grep -q '^rpmlib(ShortCircuited)'; then
            actual="$actual +package (short-circuited)"
        else
            actual="$actual +package"
        fi
    else
        actual="$actual -package"
    fi

    if [[ $actual != "$expected" ]]; then
        cat <<END
Test case failed: $TC_NAME
  ** Command    ** $ME $(printf "%q " "${args[@]}")
  ** Expected   ** $expected
  ** Actual     ** $actual
END
        return 1
    fi

    return 0
}

set_up_ts rpmbuild_phases "Separating build phases"

run_tc rpmbuild_phases "prepare" \
    "+prepare -qmake -cmake-c -cmake-b -make -make-install -check -package" prepare
run_tc rpmbuild_phases "build" \
    "-prepare +qmake +cmake-c +cmake-b +make +make-install +check +package" build
run_tc rpmbuild_phases "build --doprep" \
    "+prepare +qmake +cmake-c +cmake-b +make +make-install +check +package" build --doprep
run_tc rpmbuild_phases "qmake" \
    "-prepare +qmake +cmake-c +cmake-b -make -make-install -check -package" qmake
run_tc rpmbuild_phases "cmake / configure" \
    "-prepare +qmake +cmake-c -cmake-b -make -make-install -check -package" cmake .
run_tc rpmbuild_phases "cmake / build" \
    "-prepare +qmake -cmake-c +cmake-b +make -make-install -check -package" cmake --build .
run_tc rpmbuild_phases "make" \
    "-prepare -qmake -cmake-c +cmake-b +make -make-install -check -package" make
run_tc rpmbuild_phases "make-install" \
    "-prepare -qmake -cmake-c -cmake-b -make +make-install -check -package" make-install
run_tc rpmbuild_phases "package" \
    "-prepare -qmake -cmake-c -cmake-b -make +make-install +check +package" package
run_tc rpmbuild_phases "compiledb" \
    "-prepare +qmake +cmake-c +cmake-b ~make -make-install -check -package" compiledb

tear_down_ts rpmbuild_phases

################################################################################
# Test compatibility with various packaging options

# Accepts up to one argument - .pro file or a directory where to looks for a pro file. Defaults to
# current working directory. Creates Makefile that makes single file named after the TARGET name and
# installs it directly under the INSTALL_ROOT.
special_packaging_qmake_stub() {
    shopt -s nullglob
    if [[ $# -eq 0 ]]; then
        pro_files=(*.pro)
    elif [[ $# -eq 1 ]]; then
        if [[ $1 == *.pro ]]; then
            if [[ ! -e $1 ]]; then
                echo "stub qmake: file not found: $1" >&2
                return 1
            fi
            pro_files=($1)
        elif [[ -d $1 ]]; then
            pro_files=("$1"/*.pro)
        else
            echo "stub qmake: not a directory: $1" >&2
            return 1
        fi
    else
        echo "stub qmake: up to one argument expected" >&2
        return 1
    fi

    if [[ ${#pro_files[*]} -lt 1 ]]; then
        echo "stub qmake: no project file found" >&2
        return 1
    elif [[ ${#pro_files[*]} -gt 1 ]]; then
        echo "stub qmake: multiple project files found - select one" >&2
        return 1
    fi

    target=$(sed -n 's/^TARGET=//p' $pro_files)
    if [[ ! $target ]]; then
        echo "stub qmake: failed to parse project file '$pro_files'" >&2
        return 1
    fi

    cat >Makefile <<EOF
all:
	echo $target > $target

install:
	cp $target \$(INSTALL_ROOT)/$target
EOF
}

special_packaging_ts_set_up() {
    sb2_stub_create || return

    cat >"$STUBS_DIR/qmake" <<END || return
#!/bin/bash
$(declare -f special_packaging_qmake_stub)
special_packaging_qmake_stub "\$@"
END
    chmod +x "$STUBS_DIR/qmake" || return
}

special_packaging_ts_tear_down() {
    sb2_stub_remove || return
    rm -f "$STUBS_DIR/qmake" || return
}

# Accepts 7 arguments described inline
special_packaging_tc() {
    # SUBDIR: Put sources under subdirectory
    #   - N: No
    #   - Y: Yes, pass it to the %setup macro
    #   - NOSET: Yes, do not pass it to the %setup macro
    local maybe_subdir=$([[ $1 == Y || $1 == NOSET ]] && echo test)
    local maybe_setupdir=$([[ $1 == Y ]] && echo "/%{name}")

    # MULTI: Create multiple .spec and .pro files
    #   - Y/N
    local enable_multi=$([[ $2 == Y ]] && echo 1)

    # PATCH: Create .spec with patches
    #   - N: No
    #   - APPLY: Yes, use 'mb2 apply' to apply them
    #   - PREP: Yes, use 'mb2 prepare' to apply them
    #   - DOPREP: Yes, use 'mb2 build --doprep' to apply them
    local enable_patch=$([[ $3 == APPLY || $3 == PREP || $3 == DOPREP ]] && echo "$3")

    # SHADOW BUILD: Do shadow build
    #   - Y/N
    local enable_shadow=$([[ $4 == Y ]] && echo 1)

    # PROJECT IN SPEC: Pass .pro file to qmake call in the .spec file
    #   - Y/N
    local maybe_project_in_spec=
    if [[ $5 == Y ]]; then
        if [[ ! $maybe_subdir || $maybe_setupdir ]]; then
            maybe_project_in_spec=test.pro
        else
            maybe_project_in_spec=$maybe_subdir/test.pro
        fi
    fi

    # PROJECT ON CMDLN: Pass .pro file or directory on command line
    #   - N: No
    #   - FILE: Yes
    #   - DIR: Yes, pass the path to the subdirectory containing the .pro file
    #   - OTHER: Yes, pass other .pro file than used in the .spec
    local project_on_cmdln=
    case $6 in
        FILE) project_on_cmdln=${maybe_subdir:+$maybe_subdir/}test.pro;;
        DIR) project_on_cmdln=$maybe_subdir;;
        OTHER) project_on_cmdln=${maybe_subdir:+$maybe_subdir/}other.pro;;
    esac

    # AUTO SETUP: Use %autosetup
    #   - Y/N
    local setup_method="setup -q"
    local enable_patch_auto=
    local enable_patch_explicit=$enable_patch
    if [[ $7 == Y ]]; then
        local setup_method="autosetup"
        local enable_patch_auto=$enable_patch_explicit
        enable_patch_explicit=
    fi

    local srcdir=test
    local builddir=test

    local spec_arg=()
    if [[ $enable_multi ]]; then
        if [[ $enable_shadow ]]; then
            spec_arg=(--specfile ../test/rpm/test.spec)
        else
            spec_arg=(--specfile rpm/test.spec)
        fi
    fi

    if [[ $enable_shadow ]]; then
        if [[ $project_on_cmdln ]]; then
            project_on_cmdln=/$project_on_cmdln
        fi
        project_on_cmdln=../test$project_on_cmdln
        builddir=test-build
    fi

    mkdir -p "$srcdir" || return
    mkdir -p "$builddir" || return

    mkdir "$srcdir/rpm" || return
    cat >"$srcdir/rpm/test.spec" <<END || return
Name:       test

# These would normally come from the environment
%{!?qmake:%define qmake qmake}
%{!?qmake5:%define qmake5 qmake}
%{!?qmake5_install:%define qmake5_install make install INSTALL_ROOT=%{buildroot}}

# This is to not require meego-rpm-config installed for self-test execution
%global __os_install_post %{nil}

# Make it noop
%define setup echo

Summary:    Test
Version:    0.1
Release:    1
Group:      Qt/Qt
License:    LICENSE
URL:        http://example.org/
Source0:    %{name}-%{version}.tar.bz2
# rpmbuild applies patches in the order they appear here, ignoring their numbering
${enable_patch:+Patch1:  test-fix-1.patch}
${enable_patch:+Patch0:  test-fix-2.patch}

%description
Test

%prep
%${setup_method} -n %{name}-%{version}${maybe_setupdir}${enable_patch_auto+ -p1}
${enable_patch_explicit:+%patch1 -p1}
${enable_patch_explicit:+%patch0 -p1}

%build
%qmake5 ${maybe_project_in_spec}
make %{?_smp_mflags}

%install
mkdir -p %{buildroot}
%qmake5_install

%files
%defattr(-,root,root,-)
/foo${enable_patch:+-patched}
END

    mkdir -p "$srcdir/$maybe_subdir" || return
    echo TARGET=foo > "$srcdir/$maybe_subdir/test.pro" || return

    if [[ $enable_multi ]]; then
        touch "$srcdir/rpm/other.spec" || return
        mkdir -p "$srcdir/$maybe_subdir" || return
        echo TARGET=bar > "$srcdir/$maybe_subdir/other.pro" || return
    fi

    if [[ $enable_patch ]]; then
        cat >"$srcdir/rpm/test-fix-1.patch" <<END || return
--- a/test.pro
+++ b/test.pro
@@ -1 +1 @@
-TARGET=foo
+TARGET=foo-patched-xxx
END
        cat >"$srcdir/rpm/test-fix-2.patch" <<END || return
--- a/test.pro
+++ b/test.pro
@@ -1 +1 @@
-TARGET=foo-patched-xxx
+TARGET=foo-patched
END
    fi

    find -ls >&2

    (
        maybe_doprep=
        case $enable_patch in
            APPLY) (
                cd "$srcdir" || return
                echo "--- Preparing sources" >&2
                set -x
                "$SELF" ${spec_arg[@]:+"${spec_arg[@]}"} apply || return
                ) || return;;
            PREP) (
                cd "$srcdir" || return
                echo "--- Preparing sources" >&2
                set -x
                "$SELF" ${spec_arg[@]:+"${spec_arg[@]}"} prepare || return
                ) || return;;
            DOPREP)
                maybe_doprep=--doprep
                ;;
        esac

        (
            cd "$builddir" || return
            echo "--- Running build" >&2
            set -x
            "$SELF" ${spec_arg[@]:+"${spec_arg[@]}"} build ${maybe_doprep} ${project_on_cmdln:+"$project_on_cmdln"} || return
        ) || return

        rm -rf "$builddir"/{.mb2,RPMS,Makefile,foo} "$buildroot" || return

        (
            cd "$builddir" || return
            echo "--- Running qmake/make/package" >&2
            set -x
            "$SELF" ${spec_arg[@]:+"${spec_arg[@]}"} qmake ${project_on_cmdln:+"$project_on_cmdln"} || return
            "$SELF" ${spec_arg[@]:+"${spec_arg[@]}"} make || return
            "$SELF" ${spec_arg[@]:+"${spec_arg[@]}"} package || return
        ) || return
    )

    if [[ $? -ne 0 ]]; then
        cat <<END
Test case failed: $TC_NAME
END
        return 1
    fi

    return 0
}

special_packaging_tc_tear_down() {
    rm -rf "$buildroot" || return
    rm -rf ./test ./test-build || return
}

#   SUBDIR  MULTI  PATCH  SHADOW  PROJECT  PROJECT   AUTO
#                         BUILD   IN SPEC  ON CMDLN  SETUP

set_up_ts special_packaging "Compatibility / Flat package"
run_tc special_packaging "Basic" \
    N       N      N      N       N        N         N
run_tc special_packaging "Basic (shadow)" \
    N       N      N      Y       N        N         N
run_tc special_packaging "Pass .pro file in spec" \
    N       N      N      N       Y        N         N
run_tc special_packaging "Pass .pro file in spec (shadow)" \
    N       N      N      Y       Y        N         N
run_tc special_packaging "Pass .pro file on cmdline" \
    N       N      N      N       N        FILE      N
run_tc special_packaging "Pass .pro file in spec and on cmdline (shadow)" \
    N       N      N      Y       Y        FILE      N
tear_down_ts special_packaging

#   SUBDIR  MULTI  PATCH  SHADOW  PROJECT  PROJECT   AUTO
#                         BUILD   IN SPEC  ON CMDLN  SETUP

set_up_ts special_packaging "Compatibility / Flat package / Multiple configs"
run_tc special_packaging "Basic" \
    N       Y      N      N       Y        N         N
run_tc special_packaging "Basic (shadow)" \
    N       Y      N      Y       Y        N         N
run_tc special_packaging "Pass .pro file" \
    N       Y      N      N       Y        FILE      N
run_tc special_packaging "Pass .pro file (shadow)" \
    N       Y      N      Y       Y        FILE      N
run_tc special_packaging "Pass other .pro file" \
    N       Y      N      N       Y        OTHER     N
run_tc special_packaging "Pass other .pro file (shadow)" \
    N       Y      N      Y       Y        OTHER     N
tear_down_ts special_packaging

#   SUBDIR  MULTI  PATCH  SHADOW  PROJECT  PROJECT   AUTO
#                         BUILD   IN SPEC  ON CMDLN  SETUP

set_up_ts special_packaging "Compatibility / Flat package / With patches"
run_tc special_packaging "Use apply" \
    N       N      APPLY  N       N        N         N
run_tc special_packaging "Use apply (shadow)" \
    N       N      APPLY  Y       N        N         N
run_tc special_packaging "Use prepare" \
    N       N      PREP   N       N        N         N
run_tc special_packaging "Use prepare (shadow)" \
    N       N      PREP   Y       N        N         N
run_tc special_packaging "Use --doprep" \
    N       N      DOPREP N       N        N         N
tear_down_ts special_packaging

#   SUBDIR  MULTI  PATCH  SHADOW  PROJECT  PROJECT   AUTO
#                         BUILD   IN SPEC  ON CMDLN  SETUP

set_up_ts special_packaging "Compatibility / Flat package / With patches and %autosetup"
run_tc special_packaging "Use apply" \
    N       N      APPLY  N       N        N         Y
run_tc special_packaging "Use apply (shadow)" \
    N       N      APPLY  Y       N        N         Y
run_tc special_packaging "Use prepare" \
    N       N      PREP   N       N        N         Y
run_tc special_packaging "Use prepare (shadow)" \
    N       N      PREP   Y       N        N         Y
run_tc special_packaging "Use --doprep" \
    N       N      DOPREP N       N        N         Y
tear_down_ts special_packaging

#   SUBDIR  MULTI  PATCH  SHADOW  PROJECT  PROJECT   AUTO
#                         BUILD   IN SPEC  ON CMDLN  SETUP

set_up_ts special_packaging "Compatibility / Subtree package"
run_tc special_packaging "Basic" \
    Y       N      N      N       N        N         N
run_tc special_packaging "Basic (shadow)" \
    Y       N      N      Y       N        N         N
run_tc special_packaging "Pass .pro file" \
    Y       N      N      N       N        FILE      N
run_tc special_packaging "Pass .pro file (shadow)" \
    Y       N      N      Y       N        FILE      N
run_tc special_packaging "Pass .pro dir" \
    Y       N      N      N       N        DIR       N
run_tc special_packaging "Pass .pro dir (shadow)" \
    Y       N      N      Y       N        DIR       N
tear_down_ts special_packaging

#   SUBDIR  MULTI  PATCH  SHADOW  PROJECT  PROJECT   AUTO
#                         BUILD   IN SPEC  ON CMDLN  SETUP

set_up_ts special_packaging "Compatibility / Subtree package / Without %setup subdir"
run_tc special_packaging "Basic" \
    NOSET   N      N      N       Y        N         N
run_tc special_packaging "Basic (shadow)" \
    NOSET   N      N      Y       Y        N         N
run_tc special_packaging "Pass .pro file" \
    NOSET   N      N      N       Y        FILE      N
run_tc special_packaging "Pass .pro file (shadow)" \
    NOSET   N      N      Y       Y        FILE      N
run_tc special_packaging "Pass .pro dir" \
    NOSET   N      N      N       Y        DIR       N
run_tc special_packaging "Pass .pro dir (shadow)" \
    NOSET   N      N      Y       Y        DIR       N
tear_down_ts special_packaging

#   SUBDIR  MULTI  PATCH  SHADOW  PROJECT  PROJECT   AUTO
#                         BUILD   IN SPEC  ON CMDLN  SETUP

set_up_ts special_packaging "Compatibility / Subtree package / Multiple configs"
run_tc special_packaging "Basic" \
    Y       Y      N      N       Y        N         N
run_tc special_packaging "Basic (shadow)" \
    Y       Y      N      Y       Y        N         N
run_tc special_packaging "Pass .pro file" \
    Y       Y      N      N       Y        FILE      N
run_tc special_packaging "Pass .pro file (shadow)" \
    Y       Y      N      Y       Y        FILE      N
run_tc special_packaging "Pass .pro dir" \
    Y       Y      N      N       Y        DIR       N
run_tc special_packaging "Pass .pro dir (shadow)" \
    Y       Y      N      Y       Y        DIR       N
run_tc special_packaging "Pass other .pro file" \
    Y       Y      N      N       Y        OTHER     N
run_tc special_packaging "Pass other .pro file (shadow)" \
    Y       Y      N      Y       Y        OTHER     N
tear_down_ts special_packaging

#   SUBDIR  MULTI  PATCH  SHADOW  PROJECT  PROJECT   AUTO
#                         BUILD   IN SPEC  ON CMDLN  SETUP

set_up_ts special_packaging "Compatibility / Subtree package / With patches"
run_tc special_packaging "Use apply" \
    Y       N      APPLY  N       N        N         N
run_tc special_packaging "Use apply (shadow)" \
    Y       N      APPLY  Y       N        N         N
run_tc special_packaging "Use prepare" \
    Y       N      PREP   N       N        N         N
run_tc special_packaging "Use prepare (shadow)" \
    Y       N      PREP   Y       N        N         N
run_tc special_packaging "Use doprep" \
    Y       N      DOPREP N       N        N         N
tear_down_ts special_packaging

#   SUBDIR  MULTI  PATCH  SHADOW  PROJECT  PROJECT   AUTO
#                         BUILD   IN SPEC  ON CMDLN  SETUP

set_up_ts special_packaging "Compatibility / Subtree package / With patches and %autosetup"
run_tc special_packaging "Use apply" \
    Y       N      APPLY  N       N        N         Y
run_tc special_packaging "Use apply (shadow)" \
    Y       N      APPLY  Y       N        N         Y
run_tc special_packaging "Use prepare" \
    Y       N      PREP   N       N        N         Y
run_tc special_packaging "Use prepare (shadow)" \
    Y       N      PREP   Y       N        N         Y
run_tc special_packaging "Use doprep" \
    Y       N      DOPREP N       N        N         Y
tear_down_ts special_packaging

################################################################################
# Test compatibility with various packaging options (cmake based projects)

# In "configure" mode accepts up to one argument - source directory path.
# Defaults to current working directory. Creates Makefile that makes single
# file named after the single executable name expected in CMakeLists.txt and
# installs it directly under the INSTALL_ROOT.
#
# In "build" mode expects "." as the build directory and invokes "make",
# passing optional build-tool arguments and optionally the target name.
special_packaging_cmake_stub() {
    if [[ $1 == --build ]]; then
        if [[ $2 != . ]]; then
            echo "stub cmake: unexpected argument to '--build': '$2'" >&2
            return 1
        fi
        shift 2
        target=
        make_args=()
        while [[ $# -gt 0 ]]; do
            case $1 in
                --target)
                    target=$2
                    shift
                    ;;
                --)
                    shift
                    make_args=("$@")
                    break
                    ;;
                *)
                    ;;
            esac
            shift
        done

        make "$@" $target
        return
    else
        if [[ ! $1 ]]; then
            sources=.
        elif [[ ! -d $1 ]]; then
            echo "stub cmake: directory not found: '$1'" >&2
            return 1
        else
            sources=$1
        fi

        if [[ ! -f $sources/CMakeLists.txt ]]; then
            echo "stub cmake: no CMakeLists.txt in '$1'" >&2
            return 1
        fi

        target=foo
        cat >Makefile <<EOF
all:
	echo $target > $target

install:
	cp $target \$(DESTDIR)/$target
EOF
    fi
}

special_packaging_cmake_ts_set_up() {
    sb2_stub_create || return

    cat >"$STUBS_DIR/cmake" <<END || return
#!/bin/bash
$(declare -f special_packaging_cmake_stub)
special_packaging_cmake_stub "\$@"
END
    chmod +x "$STUBS_DIR/cmake" || return
}

special_packaging_cmake_ts_tear_down() {
    sb2_stub_remove || return
    rm -f "$STUBS_DIR/cmake" || return
}

# Accepts 5 arguments described inline
special_packaging_cmake_tc() {
    # SUBDIR: Put sources under subdirectory
    #   - N: No
    #   - Y: Yes, pass it to the %setup macro
    #   - NOSET: Yes, do not pass it to the %setup macro
    local maybe_subdir=$([[ $1 == Y || $1 == NOSET ]] && echo test)
    local maybe_setupdir=$([[ $1 == Y ]] && echo "/%{name}")

    # SHADOW BUILD: Do shadow build
    #   - Y/N
    local enable_shadow=$([[ $2 == Y ]] && echo 1)

    # PROJECT IN SPEC: Pass project directory to cmake call in the .spec file
    #   - Y/N
    local maybe_project_in_spec=
    if [[ $3 == Y ]]; then
        if [[ ! $maybe_subdir || $maybe_setupdir ]]; then
            maybe_project_in_spec=.
        else
            maybe_project_in_spec=$maybe_subdir
        fi
    fi

    # PROJECT ON CMDLN: Pass project directory on command line
    #   - Y/N
    local project_on_cmdln=$([[ $4 == Y ]] && echo ${maybe_subdir:-.})

    # CMAKE BUILD: Use "cmake --build" instead of raw "make" in the .spec file
    #   - Y/N
    local use_cmake_build=$([[ $5 == Y ]] && echo 1)

    local srcdir=test
    local builddir=test

    if [[ $enable_shadow ]]; then
        if [[ $project_on_cmdln ]]; then
            project_on_cmdln=/$project_on_cmdln
        fi
        project_on_cmdln=../test$project_on_cmdln
        builddir=test-build
    fi

    mkdir -p "$srcdir" || return
    mkdir -p "$builddir" || return

    mkdir "$srcdir/rpm" || return
    cat >"$srcdir/rpm/test.spec" <<END || return
Name:       test

# These would normally come from the environment
%{!?cmake:%define cmake cmake}

# This is to not require meego-rpm-config installed for self-test execution
%global __os_install_post %{nil}

# Make it noop
%define setup echo

Summary:    Test
Version:    0.1
Release:    1
Group:      Qt/Qt
License:    LICENSE
URL:        http://example.org/
Source0:    %{name}-%{version}.tar.bz2

%description
Test

%prep
%setup -n %{name}-%{version}${maybe_setupdir}

%build
%cmake ${maybe_project_in_spec}
if [[ -n '${use_cmake_build}' ]]; then
    cmake --build .
else
    make %{?_smp_mflags}
fi

%install
mkdir -p %{buildroot}
make DESTDIR=%{buildroot} install

%files
%defattr(-,root,root,-)
/foo
END

    mkdir -p "$srcdir/$maybe_subdir" || return
    echo > "$srcdir/$maybe_subdir/CMakeLists.txt" || return

    find -ls >&2

    (
        (
            cd "$builddir" || return
            echo "--- Running build" >&2
            set -x
            "$SELF" build ${project_on_cmdln:+"$project_on_cmdln"} || return
        ) || return

        rm -rf "$builddir"/{.mb2,RPMS,Makefile,foo} "$buildroot" || return

        (
            cd "$builddir" || return
            echo "--- Running cmake/cmake --build/package" >&2
            set -x
            "$SELF" cmake ${project_on_cmdln:+"$project_on_cmdln"} || return
            "$SELF" cmake --build . || return
            "$SELF" package || return
        ) || return

        rm -rf "$builddir"/{.mb2,RPMS,Makefile,foo} "$buildroot" || return

        (
            cd "$builddir" || return
            echo "--- Running cmake/make/package" >&2
            set -x
            "$SELF" cmake ${project_on_cmdln:+"$project_on_cmdln"} || return
            "$SELF" make || return
            "$SELF" package || return
        ) || return
    )

    if [[ $? -ne 0 ]]; then
        cat <<END
Test case failed: $TC_NAME
END
        return 1
    fi

    return 0
}

special_packaging_cmake_tc_tear_down() {
    rm -rf "$buildroot" || return
    rm -rf ./test ./test-build || return
}

#   SUBDIR  SHADOW  PROJECT  PROJECT   CMAKE
#           BUILD   IN SPEC  ON CMDLN  BUILD

set_up_ts special_packaging_cmake "Compatibility / CMake / Flat package"
run_tc special_packaging_cmake "Basic" \
    N       N       N        N         N
run_tc special_packaging_cmake "Basic (shadow)" \
    N       Y       N        N         N
run_tc special_packaging_cmake "Pass project dir in spec" \
    N       N       Y        N         N
run_tc special_packaging_cmake "Pass project dir in spec (shadow)" \
    N       Y       Y        N         N
run_tc special_packaging_cmake "Pass project dir on cmdline" \
    N       N       N        Y         N
run_tc special_packaging_cmake "Pass project dir in spec and on cmdline (shadow)" \
    N       Y       Y        Y         N
tear_down_ts special_packaging_cmake

#   SUBDIR  SHADOW  PROJECT  PROJECT   CMAKE
#           BUILD   IN SPEC  ON CMDLN  BUILD

set_up_ts special_packaging_cmake "Compatibility / CMake / Flat package / cmake --build"
run_tc special_packaging_cmake "Basic" \
    N       N       N        N         Y
run_tc special_packaging_cmake "Basic (shadow)" \
    N       Y       N        N         Y
run_tc special_packaging_cmake "Pass project dir in spec" \
    N       N       Y        N         Y
run_tc special_packaging_cmake "Pass project dir in spec (shadow)" \
    N       Y       Y        N         Y
run_tc special_packaging_cmake "Pass project dir on cmdline" \
    N       N       N        Y         Y
run_tc special_packaging_cmake "Pass project dir in spec and on cmdline (shadow)" \
    N       Y       Y        Y         Y
tear_down_ts special_packaging_cmake

#   SUBDIR  SHADOW  PROJECT  PROJECT   CMAKE
#           BUILD   IN SPEC  ON CMDLN  BUILD

set_up_ts special_packaging_cmake "Compatibility / CMake / Subtree package"
run_tc special_packaging_cmake "Basic" \
    Y       N       N        N         N
run_tc special_packaging_cmake "Basic (shadow)" \
    Y       Y       N        N         N
run_tc special_packaging_cmake "Pass project dir" \
    Y       N       N        Y         N
run_tc special_packaging_cmake "Pass project dir (shadow)" \
    Y       Y       N        Y         N
tear_down_ts special_packaging_cmake

#   SUBDIR  SHADOW  PROJECT  PROJECT   CMAKE
#           BUILD   IN SPEC  ON CMDLN  BUILD

set_up_ts special_packaging_cmake "Compatibility / CMake / Subtree package / cmake --build"
run_tc special_packaging_cmake "Basic" \
    Y       N       N        N         Y
run_tc special_packaging_cmake "Basic (shadow)" \
    Y       Y       N        N         Y
run_tc special_packaging_cmake "Pass project dir" \
    Y       N       N        Y         Y
run_tc special_packaging_cmake "Pass project dir (shadow)" \
    Y       Y       N        Y         Y
tear_down_ts special_packaging_cmake

#   SUBDIR  SHADOW  PROJECT  PROJECT   CMAKE
#           BUILD   IN SPEC  ON CMDLN  BUILD

set_up_ts special_packaging_cmake "Compatibility / CMake / Subtree package / Without %setup subdir"
run_tc special_packaging_cmake "Basic" \
    NOSET   N       Y        N         N
run_tc special_packaging_cmake "Basic (shadow)" \
    NOSET   Y       Y        N         N
run_tc special_packaging_cmake "Pass project dir" \
    NOSET   N       Y        Y         N
run_tc special_packaging_cmake "Pass project dir (shadow)" \
    NOSET   Y       Y        Y         N
tear_down_ts special_packaging_cmake

#   SUBDIR  SHADOW  PROJECT  PROJECT   CMAKE
#           BUILD   IN SPEC  ON CMDLN  BUILD

set_up_ts special_packaging_cmake "Compatibility / CMake / Subtree package / Without %setup subdir / cmake --build"
run_tc special_packaging_cmake "Basic" \
    NOSET   N       Y        N         Y
run_tc special_packaging_cmake "Basic (shadow)" \
    NOSET   Y       Y        N         Y
run_tc special_packaging_cmake "Pass project dir" \
    NOSET   N       Y        Y         Y
run_tc special_packaging_cmake "Pass project dir (shadow)" \
    NOSET   Y       Y        Y         Y
tear_down_ts special_packaging_cmake

###############################################################################
# Test compatibility with various packaging options (Autotools based projects)

# Checks that 'configure.ac' exists and creates 'configure' from template.
# Checks that 'Makefile.am' exists and copies it as 'Makefile.in'.
special_packaging_autotools_autoreconf_stub() {
    if [[ $# -ne 0 ]]; then
        echo "stub autoreconf: unexpected argument: '$1'" >&2
        return 1
    fi

    if [[ ! -e Makefile.am ]]; then
        echo "stub autoreconf: no Makefile.am under '$PWD'" >&2
        return 1
    fi

    if [[ $(head -n1 Makefile.am) != "# bogus" ]]; then
        echo "stub autoreconf: unexpected content in Makefile.am under '$PWD'" >&2
        return 1
    fi

    cp Makefile.am Makefile.in || return

    if [[ ! -e configure.ac ]]; then
        echo "stub autoreconf: no configure.ac under '$PWD'" >&2
        return 1
    fi

    if [[ $(<configure.ac) != "dnl bogus" ]]; then
        echo "stub autoreconf: unexpected content in configure.ac under '$PWD'" >&2
        return 1
    fi

    # Creates 'Makefile' from 'Makefile.in', replacing @SRCDIR@ and @OUTDIR@
    special_packaging_autotools_configure_template() {
        local srcdir=$(dirname "$0")
        if [[ ! -f $srcdir/Makefile.in ]]; then
            echo "$0: no Makefile.in under '$srcdir'" >&2
            return 1
        fi
        sed < "$srcdir/Makefile.in" > ./Makefile \
            -e "s,@SRCDIR@,$srcdir,g" \
            -e "s,@OUTDIR@,$PWD,g"
    }

    # Cannot do '|| return' here. BASH would produce an invalid dump of
    # special_packaging_autotools_autoreconf_stub with 'declare -f', putting
    # 'return' on a separate line after 'END'
    cat <<END > configure #|| return
#!/bin/bash
$(declare -f special_packaging_autotools_configure_template)
special_packaging_autotools_configure_template "\$@"
END
    chmod +x configure || return
}

special_packaging_autotools_ts_set_up() {
    sb2_stub_create || return

    cat >"$STUBS_DIR/autoreconf" <<END || return
#!/bin/bash
$(declare -f special_packaging_autotools_autoreconf_stub)
special_packaging_autotools_autoreconf_stub "\$@"
END
    chmod +x "$STUBS_DIR/autoreconf" || return
}

special_packaging_autotools_ts_tear_down() {
    sb2_stub_remove || return
    rm -f "$STUBS_DIR/autotools" || return
}

# Accepts 2 arguments described inline
special_packaging_autotools_tc() {
    # SUBDIR: Put sources under subdirectory
    #   - N: No
    #   - Y: Yes
    local maybe_subdir=$([[ $1 == Y ]] && echo test)
    local maybe_setupdir=$([[ $1 == Y ]] && echo "/%{name}")

    # SHADOW BUILD: Do shadow build
    #   - Y/N
    local enable_shadow=$([[ $2 == Y ]] && echo 1)

    local srcdir=test
    local maybe_srcdir_on_cmdln=
    local builddir=test

    if [[ $enable_shadow ]]; then
        maybe_srcdir_on_cmdln=../test
        builddir=test-build
    fi

    mkdir -p "$srcdir" || return
    mkdir -p "$builddir" || return

    mkdir "$srcdir/rpm" || return
    cat >"$srcdir/rpm/test.spec" <<END || return
Name:       test

# This is to not require meego-rpm-config installed for self-test execution
%global __os_install_post %{nil}

# Make it noop
%define setup echo

Summary:    Test
Version:    0.1
Release:    1
Group:      Qt/Qt
License:    LICENSE
URL:        http://example.org/
Source0:    %{name}-%{version}.tar.bz2

%description
Test

%prep
%setup -n %{name}-%{version}${maybe_setupdir}

%build
./autogen.sh
./configure
make

%install
mkdir -p %{buildroot}
make DESTDIR=%{buildroot} install

%files
%defattr(-,root,root,-)
/foo
END

    mkdir -p "$srcdir/$maybe_subdir" || return

    echo foo > "$srcdir/$maybe_subdir/foo.src" || return

    cat <<END > "$srcdir/$maybe_subdir/Makefile.am" || return
# bogus
all:
	cat "@SRCDIR@/foo.src" > "@OUTDIR@/foo"

install:
	cp "@OUTDIR@/foo" \$(DESTDIR)/foo
END

    cat <<END > "$srcdir/$maybe_subdir/configure.ac" || return
dnl bogus
END

    cat <<END > "$srcdir/$maybe_subdir/autogen.sh" || return
#!/bin/bash
autoreconf
END
    chmod +x "$srcdir/$maybe_subdir/autogen.sh" || return

    find -ls >&2

    (
        cd "$builddir" || return

        (
            echo "--- Running build" >&2
            set -x
            "$SELF" build ${maybe_srcdir_on_cmdln:+"$maybe_srcdir_on_cmdln"} || return
        ) || return

        (
            echo "--- Running build-shell-make/package" >&2
            set -x
            "$SELF" build-shell make ${maybe_subdir:+-C "$maybe_subdir"} >&2 || return
            "$SELF" package || return
        ) || return
    )

    if [[ $? -ne 0 ]]; then
        cat <<END
Test case failed: $TC_NAME
END
        return 1
    fi

    return 0
}

special_packaging_autotools_tc_tear_down() {
    rm -rf "$buildroot" || return
    rm -rf ./test ./test-build || return
}

#   SUBDIR  SHADOW
#           BUILD

set_up_ts special_packaging_autotools "Compatibility / Autotools"
run_tc special_packaging_autotools "Flat package" \
    N       N
run_tc special_packaging_autotools "Flat package (shadow)" \
    N       Y
run_tc special_packaging_autotools "Subtree package" \
    Y       N
run_tc special_packaging_autotools "Subtree package (shadow)" \
    Y       Y
tear_down_ts special_packaging_autotools

################################################################################
# Test the match_multi function

match_multi_ts_set_up() {
    :
}

match_multi_ts_tear_down() {
    :
}

match_multi_tc() {
    local match_name=$1 no_match_name=$2 patterns=("${@:3}")

    local rc=0 problems=()

    if [[ $match_name ]] && ! match_multi "$match_name" ${patterns:+"${patterns[@]}"}; then
        rc=1
        problems+=("Not matched while it should")
    fi

    if [[ $no_match_name ]] && match_multi "$no_match_name" ${patterns:+"${patterns[@]}"}; then
        rc=1
        problems+=("Matched while it should not")
    fi

    if [[ $rc != 0 ]]; then
        cat <<END
Test case failed: $TC_NAME
END
        printf '    %s\n' "${problems[@]}"
    fi

    return $rc
}

set_up_ts match_multi "Test match_multi"
run_tc match_multi "No filter" foobar ""
run_tc match_multi "Implicit inclusion only" foobar doobar "foo*"
run_tc match_multi "Explicit inclusion only" foobar doobar "+foo*"
run_tc match_multi "Explicit exclusion only" foobar doobar "-doo*"
run_tc match_multi "Override exclusion" foobar doobar "-*bar" "foo*"
run_tc match_multi "Override inclusion" foobar doobar "*bar" "-doo*"
run_tc match_multi "Override exclusion later" foobar doobar "-*bar" "zoo*" "foo*"
run_tc match_multi "Override inclusion later" foobar doobar "*bar" "zoo*" "-doo*"
run_tc match_multi "Extglob" foobar doobar "foo@(bar|baz)"
tear_down_ts match_multi

################################################################################
# Test find_latest_rpms

make_test_package() {
    local name=$1 version=$2 release=$3

    # Create a minimal spec file
    mkdir -p rpm || return
    cat >rpm/test.spec <<END || return
Name:       ${name}

# This is to not require meego-rpm-config installed for self-test execution
%global __os_install_post %{nil}

Summary:    Test
Version:    ${version}
Release:    ${release}
Group:      Qt/Qt
License:    LICENSE
URL:        http://example.org/
Source0:    %{name}-%{version}.tar.bz2

%description
Test

%build

%install
mkdir -p %{buildroot}
touch %{buildroot}/foo

%files
%defattr(-,root,root,-)
/foo
END
    # Set output-dir explicitly to prevent removal of previously built packages
    mkdir -p RPMS || return
    "$SELF" --output-dir RPMS build || return
}

find_latest_rpms_tc() {
    sb2_stub_create || return

    make_test_package "test1" "1.2.3" "1" || return
    make_test_package "test1" "1.2.3+jb12345.20200202202020.deadbeef" "1" || return
    make_test_package "test1" "1.2.3+jb12345.20200222222222.beefbabe" "1" || return
    make_test_package "test2" "3.2.1" "1" || return
    make_test_package "test2" "3.3" "1" || return

    local expected=$(cat <<END
RPMS/test1-1.2.3+jb12345.20200222222222.beefbabe-1.i486.rpm
RPMS/test2-3.3-1.i486.rpm
END
)
    local actual=
    actual=$(set +o nounset; find_latest_rpms "RPMS") || return

    if [[ $actual != "$expected" ]]; then
        cat <<END
Test case failed: $TC_NAME
  ** Expected   ** [[
$expected
]]
  ** Actual     ** [[
$actual
]]
END
        return 1
    fi

    return 0
}

find_latest_rpms_tc_tear_down() {
    sb2_stub_remove || return
    rm -f rpm/test.spec || return
    rmdir rpm || return
    rm -f RPMS/test1-1.2.3-1.i486.rpm || return
    rm -f RPMS/test1-1.2.3+jb12345.20200202202020.deadbeef-1.i486.rpm || return
    rm -f RPMS/test1-1.2.3+jb12345.20200222222222.beefbabe-1.i486.rpm || return
    rm -f RPMS/test2-3.2.1-1.i486.rpm || return
    rm -f RPMS/test2-3.3-1.i486.rpm || return
    ! [[ -d RPMS ]] || rmdir RPMS || return
    rm -f "$buildroot/foo" || return
}

run_tc find_latest_rpms "Test find_latest_rpms"

################################################################################

if [[ $tc_failed_num -eq 0 ]]; then
    echo "*** All $tc_num tests passed"
else
    echo "*** $tc_failed_num out of $tc_num failed"
fi

# For Emacs:
# Local Variables:
# indent-tabs-mode:nil
# tab-width:4
# mode: sh
# End:
# For VIM:
# vim:set softtabstop=4 shiftwidth=4 tabstop=4 expandtab:
