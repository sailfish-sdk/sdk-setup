#!/bin/bash
#
# Copyright (C) 2013 - 2016 Jolla Ltd.
# Contact: David Greaves <david.greaves@jollamobile.com>
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
#
# - Redistributions of source code must retain the above copyright
#   notice, this list of conditions and the following disclaimer.
# - Redistributions in binary form must reproduce the above copyright
#   notice, this list of conditions and the following disclaimer in
#   the documentation and/or other materials provided with the
#   distribution.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.

synopsis() {
    cat <<EOF
usage: $ME [-t <target>] [-s <specfile>] [-d <device>] [-o <outputdir>] [-p <projectdir>]
           [-f <folder>] [-i] [-P] [-x[=<tag>] | -X] [-c[=<args>]]
           build [-p] [-d] [-j <n>] [<args>] | qmake [<args>] | make [<args>] | ssh <args>
           install [<args>] | installdeps <args> | rpm [<args>] | deploy <args>
           prep | apply [-R] | run <args>
       $ME --version
EOF
}

short_usage() {
    synopsis
    cat <<EOF

Try '$ME --help' for more information.
EOF
    # exit if any argument is given
    [[ -n "$1" ]] && exit 1
}

usage() {
    synopsis
    cat <<EOF

  Executes a subset of build commands in the context of an rpmbuild.
  Typically called from QtCreator to perform qmake/make phases of a project.
  Note that any other build steps in the .spec file will also be run.

  <specfile> will be looked for in the current rpm/ dir. If there is
  more than one it must be provided.

  CWD is used as a base dir for installroot/ and RPMS/ to allow for
  shadowbuilds

  $ME is aware of spectacle and will update the spec file if there is
  an obvious yaml file which is newer.

  If a file exists with '.changes' extension, otherwise matching the
  spec file name, the effect will be the same as having a %changelog
  section in the spec file.  If a file with '.changes.run' extension is
  found instead, this file will be executed and its output treated as
  the actual changelog.

  $ME prep           : runs rpmbuild for %prep phase of the spec file.

  $ME build [-p|--doprep] [-d|--enable-debug] [-j <n>] [<args>]
                     : runs rpmbuild for the given spec file in the
                       given sb2 target. Produces an rpm package.
                     : -p     run %prep phase as well when building
                     : -d     enable debug build
                     : -j <n> use only 'n' CPUs to build
                     : can use -s -t -p -i -x -X -c

  $ME qmake [<args>] : runs qmake in the 'build' phase
                       Note that this also verifies target
                       build dependencies are up to date
                     : can use -s -t -p  

  $ME make [<args>]  : run make in the 'build' phase
                     : can use -s -t -p

  $ME deploy --zypper|--pkcon|--rsync|--sdk
                     : runs the install or rpm-creation phase and then
                       copies/installs the relevant files to the device
                     : can use -s -t -p -d -i -f -x -X -c

  $ME run|ssh [<args>] : runs a command (on device if --device given);
                         intended for running gdb and a gdb server
                     : can use -s -t -p -d

  $ME install [<args>] : runs the 'install' phase to install to $buildroot
                     : can use -s -t -p

  $ME installdeps [<args>] : refresh the zypper cache of the given target and
                             if required installs build-dependencies
                     : can use -s -t -p

  $ME rpm [<args>]   : runs the install & rpm-creation phases
                     : can use -s -t -p -i -x -X -c

  $ME apply [-R]     : applies all patches defined in spec from rpm directory
                     : to the source tree, or if detected, submodule
                     : source tree
                     : -R    reverse apply patches (patch -R)
                     : can use -m

  -i | --increment     : increment release number in spec file
  -t | --target        : specify the sb2 target to use
  -d | --device        : specify the device
  -o | --outputdir     : where to place produced RPM files. Defaults to ./RPMS directory
  -p | --projectdir    : when running shadow build/deploy from another dir
  -s | --specfile      : if the specfile is not in rpm/*.spec and cannot be found using -p
  -f | --shared-folder : the folder where QtCreator shares devices.xml and ssh keys
                         this option is useful if deploy option is used outside of virtual
                         machine
  -P | --pedantic      : do extra checks
  -x[=<tag>] | --fix-version[=<tag>]
                       : this option is implied when used inside a Git working
                         tree (use -X to override). Within Application SDK it is
                         only implied if the version recorded in the spec file
                         is exactly "0".
                         Use the latest tag from the current git branch as
                         package version or the given <tag>.  If the current
                         HEAD, index or working tree differs from the tree
                         denoted by the tag, a suffix composed from the current
                         branch name, time stamp and a commit SHA1 will be added
                         to the package version.  If git-state is not clean
                         a git-stash will be created and its SHA1 will be used
                         instead of HEAD.
  -X | --no-fix-version
                       : override --fix-version option.
  -c[=<args>] | --git-change-log[=<args>]
                       : include change log generated from Git history with
                         'git-change-log' command, forwarding any <args>.
                         This option is not intended for regular use - create a
                         script file named after the spec file but with
                         '.changes.run' extension to instruct $ME to generate
                         changelog with 'git-change-log <args>' instead.
  -m | --submodule     : use specified directory as submodule when applying patches

EOF
}

notice() {
    echo "NOTICE: $*" >&2
}

fatal() {
    echo "Fatal: $*" >&2
    exit 1
}

# readarray is a bash >= 4.0 feature
if ! type readarray &>/dev/null; then
    readarray() {
        if ! [[ $# -eq 2 && $1 == -t && $(declare -p "$2" 2>/dev/null) == "declare -a "* ]]; then
            fatal "Internal error: readarray: unimplemented case"
        fi

        local line=
        eval $2=\(\)
        while IFS= read -r line; do
            eval $2=\(\${$2[@]:+\"\${$2[@]}\"} \"\$line\"\)
        done
    }
fi

git_() (
    # Cannot use the '-C' option - it requires newer Git.
    # Cannot use '--git-dir' + '--work-tree' options - they break at least git-stash.
    if [[ $OPT_PROJDIR ]]; then
        cd "$OPT_PROJDIR" || return
    fi
    # At least git-stash requires an explicitly set user identity. Setting environment
    # variables compared to passing options with '-c' works also for subprocesses invoked via
    # `git-submodule foreach`
    if inside_build_engine; then
        export GIT_AUTHOR_NAME='mersdk' GIT_AUTHOR_EMAIL='mersdk@mersdk'
        export GIT_COMMITTER_NAME='mersdk' GIT_COMMITTER_EMAIL='mersdk@mersdk'
    fi

    git "$@"
)

check_spec_supports_qtc_silent() {
    grep "define qtc_qmake" "$OPT_SPEC" >/dev/null 2>&1
}

check_spec_supports_qtc() {
    if ! check_spec_supports_qtc_silent; then
        notice "This specfile does not have the qtc_* macros defined"
    fi
}

try_to_make_spec() { # Tries to create a missing spec
    [[ -f "$1" ]] && return # It's not missing
    local yaml="${1%.spec}.yaml"
    [[ -f "$yaml" ]] || return # No yaml
    ANSI_COLORS_DISABLED=1 specify -n -N "$yaml" || fatal "unable to convert yaml to spec"
}

try_to_make_spec_from_yaml() {
    # Tries to create a missing spec from a given yaml
    try_to_make_spec "${1%.yaml}.spec"
}

sanitize_changelog() {
    sed 's/%/%%/g'
}

try_to_make_changelog() {
    local changes_file=${OPT_SPEC%.spec}.changes
    local changes_run_file=${OPT_SPEC%.spec}.changes.run

    if [[ $OPT_GIT_CHANGE_LOG ]]; then
        notice "Auto generating changelog from Git history ..."
        echo "%changelog"
        git-change-log $OPT_GIT_CHANGE_LOG_ARGS |sanitize_changelog
    elif [[ -f $changes_file ]]; then
        notice "Appending changelog entries to spec ..."
        echo "%changelog"
        cat $changes_file |sanitize_changelog
    elif [[ -f $changes_run_file ]]; then
        notice "Generating changelog entries with $changes_run_file ..."
        local runner=
        # In build VM the shared filesystem is noexec
        if ! [[ -x $changes_run_file ]]; then
            if [[ $(head -c 3 <$changes_run_file |cat -v) == '#!/' ]]; then
                runner=$(sed -n '1s/^#!//p' $changes_run_file)
            else
                fatal "Not executable: $changes_run_file"
            fi
        fi
        echo "%changelog"
        $runner $changes_run_file |sanitize_changelog
        [[ ${PIPESTATUS[0]} -eq 0 ]] || fatal "unable to generate changelog entries"
    fi
}

ensure_spec_newer_than_yaml() {
    local yaml="${OPT_SPEC%.spec}.yaml"
    if [[ -f "$yaml" ]] && [[ "$yaml" -nt "$OPT_SPEC" ]]; then # -nt is newer than
        ANSI_COLORS_DISABLED=1 specify -n -N "$yaml" || fatal "unable to convert yaml to spec"
    fi

    # it's ok also not to have a yaml
}

verify_target_dependencies() {
    local deps=()
    readarray -t deps < <(sb2 -t "$OPT_TARGET" rpmspec --query --buildrequires "$OPT_SPEC" |sed 's/\s*$//')
    if [[ $deps ]]; then
        sb2 -t "$OPT_TARGET" -m sdk-install -R zypper --quiet --non-interactive in "${deps[@]}"
    fi
}

get_spec_tag() {
    rpmspec --query --srpm --queryformat="$1" "$OPT_SPEC"
}

fix_package_version() {
    local spec_file=$1

    local version_in_spec=$(sed -n 's/^Version:[[:space:]]*//p' "$spec_file")

    if [[ $OPT_NO_FIX_VERSION ]]; then
        return
    elif [[ ! $OPT_FIX_VERSION ]]; then
        # When used inside a build engine VM, fixing version is enabled implicitly only if the
        # version in spec file is exactly "0" - this is because there is no UI in Qt Creator
        # that would allow to override this.
        if inside_build_engine && [[ $version_in_spec != 0 ]]; then
            return
        fi
    fi

    if ! inside_git_worktree; then
        if [[ $OPT_FIX_VERSION || $version_in_spec == 0 ]]; then
            notice "Not inside a Git working tree, will not fix package version."
        fi
        return
    fi

    local tag
    if [[ $OPT_FIX_VERSION_HINT ]]; then
        tag=$OPT_FIX_VERSION_HINT
    else
        if ! tag=$(git_ describe --tags --abbrev=0 2>/dev/null); then
            notice "No tags describe the HEAD, will not fix package version."
            return
        fi
    fi

    local version=$tag
    version=${version#*/}   # allow tags to have a prefix to allow vendor marking
    version=${version#v}    # some people like to prefix versions with a v

    local stash=$(git_ stash create)
    local head=${stash:-$(git_ rev-parse HEAD)}

    local modified_submodules=$(
        describe_if_modified()
        {
            local stash=$(git stash create)
            local head=${stash:-$(git rev-parse HEAD)}
            if [[ $head != $sha1 ]]; then
                local short=$(git rev-list --max-count=1 --abbrev-commit "$head")
                echo -n "+$name.$short"
            fi
        }
        git_ submodule --quiet foreach --recursive \
            "$(declare -f describe_if_modified); describe_if_modified")

    if [[ $(git_ rev-parse "$tag^{}") != "$head" || $modified_submodules ]]; then
        local branch=$(git_ rev-parse --abbrev-ref HEAD)
        local timestamp=$(TZ=UTC date --date=@$(git_ log --max-count=1 --pretty=%ct "$head") +%Y%m%d%H%M%S)
        local sha1sum=$(git_ rev-list --max-count=1 --abbrev-commit "$head")
        version=$version+$branch.$timestamp.$sha1sum$modified_submodules
    fi

    version=${version//-/+} # '-' is not an allowed character in the version field

    echo "Setting version: ${version}"
    sed -i "s,^Version:.*,Version: ${version}," "$spec_file"
}

# Helper to read XML
read_dom () {
    local IFS=\>
    read -d \< ENTITY CONTENT
    local RET=$?
    TAG_NAME=${ENTITY%% *}
    ATTRIBUTES=${ENTITY#* }
    return $RET
}

# This slurps the XML and converts tags like <subnet> to $device_subnet
# Also sets device_name and device_type from the attributes
get_device() {
    local FOUND_DEVICE=
    local IN_DEVICE=
    local maintag=
    while read_dom; do
        case $TAG_NAME in
            device )
                maintag=$TAG_NAME
                eval local $ATTRIBUTES
                if [[ "$name" == "$1" ]] ; then
                    FOUND_DEVICE=1
                    IN_DEVICE=1
                    device_name="$name"
                    device_type="$type"
                else
                    IN_DEVICE=
                fi
                ;;
            engine )
                maintag=$TAG_NAME
                eval local $ATTRIBUTES
                ;;
            mac|index|subnet|ip|sshkeypath )
                # Don't process and store nested tags if we're in
                # device with wrong name
                if [[ "$maintag" == "device" ]] && [[ $IN_DEVICE != 1 ]]; then
                    continue
                fi
                eval ${maintag}_$TAG_NAME=\"$CONTENT\"
                ;;
        esac
    done
    # Set this up as it's useful
    if [[ "$device_subnet" ]]; then
        device_ip="$device_subnet".$device_index
    fi
    if [[ "$FOUND_DEVICE" == 1 ]]; then return 0; else return 1; fi
}

rsync_as() {
    local user="$1";shift
    local key=$(get_shared_dir)/${device_sshkeypath}/$user
    [[ -f "$key" ]] || fatal "No key for user $user on $device_name given in devices.xml (rsync $key)"
    RSYNC_RSH="ssh -F /etc/ssh/ssh_config.sdk -l $user -i \"$key\"" rsync "$@"
}

ssh_as() {
    local user="$1";shift
    local key=$(get_shared_dir)/${device_sshkeypath}/$user
    [[ -f "$key" ]] || fatal "No key for user $user on $device_name given in devices.xml ($key)"
    ssh -F /etc/ssh/ssh_config.sdk -i "$key" -l $user $device_ip "$(quote "$@")"
}

cd_to_spec_setup_dir() {
    _basedir="$PWD"

    # avoid spawning another process for | cut -s -f2 -d '/'
    local setup_dir=$(grep -Po '%setup.*-n[[:space:]]+[^[:space:]]+' "$OPT_SPEC")
    # if setup_dir has '/' return the part after it
    setup_dir=${setup_dir/#*\//}
    # if it did not have a '/' then we got the original match => erase it
    setup_dir=${setup_dir/#%setup*/}

    if [[ -n "$setup_dir" ]]; then
    # in case we got a spec %{tag} out of this, try to expand it
    setup_dir=$(get_spec_tag "$setup_dir")
    cd "$setup_dir"
    fi
}

# handle release tags with format "x" or "x.y", where x and y are
# numbers, leave others untouched
#  get tag
#  check if it has x.y
#  if it is x.y get y and check if y is number
#  if y is number => increment
#  if it only is x check if x is number
#  if x is number => increment
#  else leave untouched
increment_build_number() {
    [[ $OPT_INC_BUILD_NUMBER -eq 0 ]] && return

    local release=$(get_spec_tag "%{release}")
    local x=$(echo $release | cut -f 1 -d .)
    local y=$(echo $release | cut -s -f 2 -d .)
    local z=$(echo $release | cut -s -f 3- -d .)

    # more than one dot found => don't touch
    [[ -n "$z" ]] && return

    if [[ -n "$y" ]]; then
        if [[ $y =~ ^-?[0-9]+$ ]]; then
            let new_release=$y+1
            echo "Incrementing release: $x.$y -> $x.$new_release"
            sed -i "s/^Release:.*/Release: $x.$new_release/" "$OPT_SPEC"
            return
        else
            # non-numeric after dot => don't touch
            return
        fi
    fi

    if [[ -n "$x" ]]; then
        if [[ $x =~ ^-?[0-9]+$ ]]; then
            let new_release=$x+1
            echo "Incrementing release: $x -> $new_release"
            sed -i "s/^Release:.*/Release: $new_release/" "$OPT_SPEC"
            return
        fi
    fi
}

quote() {
    [[ $# -gt 0 ]] && printf "%q " "$@" |sed 's/ $//'
}

rpm_quote() {
    quote "$@" |sed 's/\\/&&/g'
}

run_installdeps() {
    # Refresh repos before installing dependencies
    sb2 -t "$target" -m sdk-install -R zypper --non-interactive ref
    verify_target_dependencies
}

run_apply() {
    rpm_dir="$(dirname "$OPT_SPEC")"
    submodule=""
    if [ ! -z "$OPT_SUBMODULE" ]; then
        submodule="$OPT_SUBMODULE"
    else
        # try to detect submodule
        submodule="$(git submodule | awk '{print $2}')"
    fi

    if [ ! -z "$submodule" ]; then
        if [ ! -d "$submodule" ]; then
            echo "Submodule with directory $submodule not found. Define with -m"
            exit 1
        fi
        pushd "$submodule" >/dev/null
    fi

    reverse="cat"
    if [ "$APPLY_REVERSE" -eq 1 ]; then
        reverse="tac"
    fi
    for p in $(sed -e '/^%patch/!d' -e 's/^%patch\([0-9]*\).*/\1/' "$OPT_SPEC" | $reverse); do
        op="$(grep "^%patch${p}" "$OPT_SPEC" | awk '{print $2}')"
        patch_file="$(grep "^Patch$p:" "$OPT_SPEC" | awk '{print $2}')"
        if [ "$APPLY_REVERSE" -eq 1 ]; then
            echo "Reversing $patch_file"
            patch -R $op < "$rpm_dir/$patch_file"
        else
            echo "Applying $patch_file"
            patch $op < "$rpm_dir/$patch_file"
        fi
    done

    if [ ! -z "$submodule" ]; then
        popd >/dev/null
    fi
}

run_build() {
    # intended to provide mb build behaviour
    verify_target_dependencies

    increment_build_number;
    local tmp_spec="$OPT_SPEC.$$"
    if [[ $BUILD_NOPREP ]]; then
        sed -e '/^%patch/d' "$OPT_SPEC" > "$tmp_spec"
    else
        cp "$OPT_SPEC" "$tmp_spec"
    fi

    try_to_make_changelog >> "$tmp_spec"

    # get rid of potential windows linefeeds
    sed -i "s/\x0D$//g" "$tmp_spec"

    fix_package_version "$tmp_spec"

    local build_tgt=$(sb2 -t $OPT_TARGET gcc -dumpmachine)
    build_tgt=${build_tgt%-gnueabi}
    (
        cd_to_spec_setup_dir;
        rm -f "$OPT_OUTPUTDIR/"*.rpm;
        sb2 -t $OPT_TARGET rpmbuild --build-in-place --target=$build_tgt \
            "${BUILD_DEBUG[@]}" \
            --define "_smp_mflags -j$(rpm_quote "$BUILD_JOBS")" \
            --define "_rpmdir $OPT_OUTPUTDIR" \
            --define "_sourcedir $_basedir/rpm" \
            --define "_rpmfilename %%{name}-%%{version}-%%{release}.%%{arch}.rpm" \
            --buildroot="$buildroot" \
            "${BUILD_NOPREP[@]}" \
            -bb \
            "$tmp_spec" \
            "$@"
    )
    local rc=$?
    rm -f "$tmp_spec"
    return $rc
}

run_prep() {
    verify_target_dependencies

    increment_build_number;
    local tmp_spec="$OPT_SPEC.$$"
    # TODO maybe add toggle here for disabling patch applying?
    cp "$OPT_SPEC" "$tmp_spec"

    # get rid of potential windows linefeeds
    sed -i "s/\x0D$//g" "$tmp_spec"

    fix_package_version "$tmp_spec"

    local build_tgt=$(sb2 -t $OPT_TARGET gcc -dumpmachine)
    build_tgt=${build_tgt%-gnueabi}
    (
        cd_to_spec_setup_dir;
        rm -f "$OPT_OUTPUTDIR/"*.rpm;
        sb2 -t $OPT_TARGET rpmbuild --build-in-place --target=$build_tgt \
            "${BUILD_DEBUG[@]}" \
            --define "_smp_mflags -j$BUILD_JOBS" \
            --define "_rpmdir $OPT_OUTPUTDIR" \
            --define "_sourcedir $_basedir/rpm" \
            --define "_rpmfilename %%{name}-%%{version}-%%{release}.%%{arch}.rpm" \
            --buildroot="$buildroot" \
            -bp --short-circuit \
            "$tmp_spec"
    )
    local rc=$?
    rm -f "$tmp_spec"
    return $rc
}

run_qmake() {
    if [[ "$OPT_SPEC" ]] && check_spec_supports_qtc_silent; then
        local build_tgt=$(sb2 -t $OPT_TARGET gcc -dumpmachine)
        build_tgt=${build_tgt%-gnueabi}

        local tmp_spec="$OPT_SPEC.$$"
        cp -a "$OPT_SPEC" "$tmp_spec"

        # get rid of potential windows linefeeds
        sed -i "s/\x0D$//g" "$tmp_spec"

        fix_package_version "$tmp_spec"

        # This is a good time to verify the target dependencies as per mb
        verify_target_dependencies
        (
            cd_to_spec_setup_dir;
            sb2 -t $OPT_TARGET rpmbuild --build-in-place --target=$build_tgt \
                --define "noecho 1" \
                --define "qtc_builddir $_basedir" \
                --define "qtc_make true ignoring make" \
                --define "qtc_qmake5 %qmake5 $(rpm_quote "$@")" \
                --define "qtc_qmake %qmake $(rpm_quote "$@")" \
                -bc --short-circuit \
                "$tmp_spec"
        )
        local rc=$?
        rm -f "$tmp_spec"
        return $rc
    else
        sb2 -t $OPT_TARGET qmake "$@"
    fi
}

run_make() {
    if [[ "$OPT_SPEC" ]] && check_spec_supports_qtc_silent; then

        local tmp_spec="$OPT_SPEC.$$"
        cp -a "$OPT_SPEC" "$tmp_spec"

        # get rid of potential windows linefeeds
        sed -i "s/\x0D$//g" "$tmp_spec"

        fix_package_version "$tmp_spec"

        local build_tgt=$(sb2 -t $OPT_TARGET gcc -dumpmachine)
        build_tgt=${build_tgt%-gnueabi}
        (
            cd_to_spec_setup_dir;
            sb2 -t $OPT_TARGET rpmbuild --build-in-place --target=$build_tgt \
                --define "noecho 1" \
                --define "qtc_builddir $_basedir" \
                --define "qtc_qmake5 true ignoring qmake" \
                --define "qtc_qmake true ignoring qmake" \
                --define "qtc_make make %{?_smp_mflags} $(rpm_quote "$@")" \
                -bc --short-circuit \
                "$tmp_spec"
        )
        local rc=$?
        rm -f "$tmp_spec"
        return $rc
    else
        sb2 -t $OPT_TARGET make "$@"
    fi
}

run_install() {
    local build_tgt=$(sb2 -t $OPT_TARGET gcc -dumpmachine)
    build_tgt=${build_tgt%-gnueabi}

    local tmp_spec="$OPT_SPEC.$$"
    cp -a "$OPT_SPEC" "$tmp_spec"

    # get rid of potential windows linefeeds
    sed -i "s/\x0D$//g" "$tmp_spec"

    fix_package_version "$tmp_spec"

    # Install to buildroot which should be rsync'ed to /opt/sdk/$package on device
    (
        cd_to_spec_setup_dir;
        sb2 -t $OPT_TARGET rpmbuild --build-in-place --target=$build_tgt \
            --define "noecho 1" \
            --define "qtc_builddir $_basedir" \
            --define "_sourcedir $_basedir/rpm" \
            --define "_skip_install_processing 1" \
            --buildroot="$buildroot" \
            -bi --short-circuit --nocheck \
            "$tmp_spec"
    )
    local rc=$?
    rm -f "$tmp_spec"
    return $rc
}

run_rpm() {
    local build_tgt=$(sb2 -t $OPT_TARGET gcc -dumpmachine)
    build_tgt=${build_tgt%-gnueabi}

    local tmp_spec="$OPT_SPEC.$$"
    cp -a "$OPT_SPEC" "$tmp_spec"

    try_to_make_changelog >> "$tmp_spec"

    # get rid of potential windows linefeeds
    sed -i "s/\x0D$//g" "$tmp_spec"

    fix_package_version "$tmp_spec"

    (
        increment_build_number;
        cd_to_spec_setup_dir;
        rm -f "$OPT_OUTPUTDIR/"*.rpm;
        sb2 -t $OPT_TARGET rpmbuild --build-in-place --target=$build_tgt \
            --define "noecho 1" \
            --define "qtc_builddir $_basedir" \
            --define "_rpmdir $OPT_OUTPUTDIR" \
            --define "_sourcedir $_basedir/rpm" \
            --define "_rpmfilename %%{name}-%%{version}-%%{release}.%%{arch}.rpm" \
            --buildroot="$buildroot" \
            -bb --noprep --nobuildstage --noclean \
            "$tmp_spec"
    )
    local rc=$?
    rm -f "$tmp_spec"
    return $rc
}

run_deploy() {
    [[ "$device_type" ]] || fatal "deploy must have a valid --device"
    local fail_text="deploy must use one of --pkcon, --rsync , --sdk or --zypper"
    [[ -z ${1:-} ]] && fatal $fail_text

    local retcode=0

    while [[ $1 ]]; do
        case "$1" in
            "--sdk" | "--pkcon" )
                local method;
                if [[ "$1" == "--sdk" ]]; then
                    method="sdk-deploy-rpm"
                else
                    method="pkcon --plain --noninteractive install-local"
                fi
                shift
                run_rpm
                [[ $? -ne 0 ]] && return 1
                rpms=$(find $OPT_OUTPUTDIR -name '*.rpm' -a ! -name '*-debug*.rpm')
                rsync_as $deviceuser -av ${rpms} $device_ip:/home/$deviceuser/RPMS/
                [[ $? -ne 0 ]] && return 1
                ssh_as $deviceuser $method ${rpms}
                retcode=$?
                ssh_as $deviceuser rm -f ${rpms}
                ;;
            "--zypper" ) shift
                run_rpm
                [[ $? -ne 0 ]] && return 1
                rpms=$(find $OPT_OUTPUTDIR -name '*.rpm' -a ! -name '*-debug*.rpm')
                rsync_as root -av ${rpms} $device_ip:/root/RPMS/
                [[ $? -ne 0 ]] && return 1
                ssh_as root zypper --non-interactive --quiet in -f ${rpms}
                retcode=$?
                ssh_as root rm -f ${rpms}
                ;;
            "--rsync" ) shift
                run_install
                [[ $? -ne 0 ]] && return 1
                name=$(get_spec_tag "%{name}")
                rsync_as $deviceuser -av ${buildroot}/. $device_ip:/opt/sdk/$name
                retcode=$?
                ;;
            *)
                fatal $fail_text ;;
        esac
    done

    [[ $retcode -eq 0 ]] || { echo "Deploy failed"; return 1; }
}

get_shared_dir() {
    echo "$OPT_SHARED_DIR"
}

inside_build_engine() [[ -f /etc/mer-sdk-vbox ]]
inside_git_worktree() { git_ status &>/dev/null; }

# this is same as basename $0
ME=${0/#*\//}

################################################################################
if [[ $1 != --self-test ]]; then  ###  M A I N  EXECUTION BEGINS HERE  #########
################################################################################

# option variables
OPT_SPEC=
OPT_TARGET=
OPT_DEVICE=
OPT_OUTPUTDIR=$(readlink -f ./RPMS)
OPT_PKGDIR="./rpm"
OPT_PROJDIR=
OPT_NEEDSPEC=
OPT_PEDANTIC=0
OPT_FIX_VERSION=
OPT_FIX_VERSION_HINT=
OPT_NO_FIX_VERSION=
OPT_GIT_CHANGE_LOG=
OPT_GIT_CHANGE_LOG_ARGS=
OPT_SHARED_DIR=/etc/mersdk/share
OPT_INC_BUILD_NUMBER=0
OPT_SUBMODULE=""
deviceuser=nemo

# Virtualbox environment will install in this hardcoded location
if inside_build_engine; then
    buildroot=/home/deploy/installroot
else
    buildroot="$PWD/installroot"
fi

while [[ "$1" ]]; do
    # only set variables in this loop
    case "$1" in
        "-t" | "--target") shift
            OPT_TARGET="$1"; shift
            ;;
        "-f" | "--shared-folder") shift
            OPT_SHARED_DIR="$1"; shift
            ;;
        "-d" | "--device") shift
            OPT_DEVICE="$1"; shift
            ;;
        "-o" | "--outputdir") shift
            OPT_OUTPUTDIR="$1"; shift
            [[ -d "$OPT_OUTPUTDIR" ]] || fatal "'$OPT_OUTPUTDIR' is not a directory"
            ;;
        "-p" | "--projectdir") shift
            OPT_PROJDIR="$1"; shift
            OPT_PKGDIR="$OPT_PROJDIR"/rpm
            [[ -d "$OPT_PROJDIR" ]] || fatal "'$OPT_PROJDIR' is not a directory"
            ;;
        "-s" | "--specfile" ) shift
            OPT_SPEC="$1"; shift
            ;;
        "-i" | "--increment" ) shift
            OPT_INC_BUILD_NUMBER=1
            ;;
        "-P" | "--pedantic" ) shift
            OPT_PEDANTIC=1
            ;;
        "-x" | "--fix-version" ) shift
            OPT_FIX_VERSION=1
            OPT_FIX_VERSION_HINT=
            OPT_NO_FIX_VERSION=
            ;;
        "-x="* | "--fix-version="* )
            OPT_FIX_VERSION=1
            OPT_FIX_VERSION_HINT=${1#*=}
            OPT_NO_FIX_VERSION=
            shift
            ;;
        "-X" | "--no-fix-version" ) shift
            OPT_FIX_VERSION=
            OPT_FIX_VERSION_HINT=
            OPT_NO_FIX_VERSION=1
            ;;
        "-c" | "--git-change-log" ) shift
            OPT_GIT_CHANGE_LOG=1
            ;;
        "-c="* | "--git-change-log="* )
            OPT_GIT_CHANGE_LOG=1
            OPT_GIT_CHANGE_LOG_ARGS="${1#*=}"
            shift
            ;;
        "-m" | "--submodule" ) shift
            OPT_SUBMODULE="$1"; shift
            ;;
        install | rpm | deploy | build | installdeps | apply | prep )
            OPT_NEEDSPEC=1;
            break
            ;;
        qmake | make | run | ssh )
            break
            ;;
        --version )
            echo "$ME, version VERSION_FROM_SPEC"
            exit 0
            ;;
        --help )
            usage
            exit 0
            ;;
        *)
            short_usage quit
            ;;
    esac
done

if [[ -n "$OPT_SPEC" ]]; then
    try_to_make_spec "$OPT_SPEC"
    [[ -f "$OPT_SPEC" ]] || fatal "'$OPT_SPEC' doesn't exist (and could not be made from a yaml)"
fi

if [[ -n "$OPT_DEVICE" ]]; then
    [[ -f $(get_shared_dir)/devices.xml ]] || fatal "Unable to open $(get_shared_dir)/devices.xml"
    get_device "$OPT_DEVICE" < $(get_shared_dir)/devices.xml || fatal "'$OPT_DEVICE' not found in devices.xml"
fi

if [[ ! "$OPT_TARGET" ]]; then
    if [[ -f ~/.scratchbox2/config ]]; then
        . ~/.scratchbox2/config
        OPT_TARGET=$DEFAULT_TARGET
    fi
    [[ "$OPT_TARGET" ]] || fatal "You must specify an sb2 target or have a default configured"
fi

[[ -d ~/.scratchbox2/$OPT_TARGET ]] || fatal "$OPT_TARGET is an invalid sb2 target"

if [[ $OPT_FIX_VERSION_HINT && ! $(git_ tag --list "$OPT_FIX_VERSION_HINT") ]]; then
    fatal "'$OPT_FIX_VERSION_HINT' no such Git tag"
fi

# spec rules are complex:
#  a .spec is required for some but not all operations
#  if -s is given then
#    if it does not exist then specify tries to make it
#    if it exists it will be used
#  if there is a rpm/*.spec then that is used
#  if there is a rpm/*.yaml then a spec is made and used

if [[ ! "$OPT_SPEC" ]]; then
    # set nullglob on so that the shell glob expansions will return
    # empty if files are not found
    shopt -s nullglob
    spec_files=("$OPT_PKGDIR"/*.spec)
    numspec=${#spec_files[@]}
    if [[ $numspec -gt 1 ]]; then
        [[ $OPT_NEEDSPEC ]] && fatal "Too many spec files - please use -s to identify which one to use"
        echo "Too many spec files - not using any. Use -s to identify a specific one"
        # OPT_SPEC is not set
    fi

    if [[ $numspec -eq 0 ]]; then
        # No spec, try to find a yaml
        yaml_files=("$OPT_PKGDIR"/*.yaml)
        numyaml=${#yaml_files[@]}
        if [[ $numyaml -eq 1 ]]; then
            theyaml=("$OPT_PKGDIR"/*.yaml)
            try_to_make_spec_from_yaml "${theyaml[0]}"
            spec_files=("$OPT_PKGDIR"/*.spec)
            numspec=${#spec_files[@]}
        else
            [[ $OPT_NEEDSPEC ]] && fatal "No spec file found in '$OPT_PKGDIR/' and couldn't make one from a yaml #1"
        fi
    fi

    if [[ $numspec -eq 1 ]]; then
        thespec=("$OPT_PKGDIR"/*.spec)
        OPT_SPEC="${thespec[0]}"
    else
        # this is because we did try_to_make_spec_from_yaml and failed
        [[ $OPT_NEEDSPEC ]] && fatal "No spec file found in '$OPT_PKGDIR/' and couldn't make one from a yaml #2"
    fi

    # unset nullglob so that any further globbing works normally
    shopt -u nullglob
fi

# Now if there is a spec given, make sure it is up-to-date
if [[ "$OPT_SPEC" ]]; then
    # turn 'OPT_SPEC' into an absolute path
    OPT_SPEC=$(readlink -f "$OPT_SPEC")
    ensure_spec_newer_than_yaml
fi

case "$1" in
    qmake | make | install | rpm | deploy | prep )
        cmd=run_$1
        if [[ "$OPT_PEDANTIC" -eq 1 && "$OPT_SPEC" ]]; then
            check_spec_supports_qtc
        fi
        shift
        ;;
    apply )
        cmd=run_$1; shift
        APPLY_REVERSE=0
        while [[ "$1" ]]; do
            case "$1" in
                -R) shift
                    APPLY_REVERSE=1 ;;
                *)
                    short_usage quit
                    ;;
            esac
        done
        ;;
    build | installdeps )
        cmd=run_$1; shift
        BUILD_DEBUG=(--define "debug_package %{nil}")
        BUILD_JOBS=
        BUILD_NOPREP=(--noprep)
        while [[ "$1" ]]; do
            case "$1" in
                -d|--enable-debug) shift
                    BUILD_DEBUG=() ;;
                -j*)
                    # support giving -j with and without space between
                    # it and the 'n'
                    if [[ ${#1} -gt 2 ]]; then
                        BUILD_JOBS=${1:2}; shift
                    else
                        [[ -z "$2" ]] && short_usage quit
                        BUILD_JOBS="$2"; shift 2;
                    fi
                    ;;
                -p|--doprep) shift
                    BUILD_NOPREP=()
                    ;;
                *)
                    break
                    ;;
            esac
        done
        [[ $BUILD_JOBS ]] || BUILD_JOBS=$(getconf _NPROCESSORS_ONLN)
        ;;
    run | ssh ) shift
        if [[ "$OPT_DEVICE" ]]; then
            cmd="ssh_as $deviceuser"
        else
            cmd=""
        fi
        ;;
    *)
        short_usage quit
        ;;
esac

$cmd "$@"

##############################################################################
exit; fi ###  S E L F - T E S T  EXECUTION BEGINS HERE #######################
##############################################################################

set -o nounset

SELF=$(readlink -f "$0")

: ${MB2_SELF_TEST_VERBOSE:=}

temp=$(mktemp -d) || exit
trap "rm -rf '$temp'" EXIT
cd "$temp" || exit

mkdir stubs || exit
STUBS_DIR=$(readlink -f stubs)
export PATH="$STUBS_DIR:$PATH"

################################################################################
# Test utils

tc_num=0
tc_failed_num=0

set_up_ts() {
    local ts=$1
    TS_NAME=$2
    ${ts}_ts_set_up "${@:3}"
    if [[ $? -ne 0 ]]; then
        fatal "Test suite set-up failed: $ts"
    fi
}

tear_down_ts() {
    local ts=$1
    ${ts}_ts_tear_down
    if [[ $? -ne 0 ]]; then
        fatal "Test suite tear-down failed: $ts"
    fi
    TS_NAME=
}

KNOWN_ISSUES=()
KNOWN_ISSUE() {
    KNOWN_ISSUES=(${KNOWN_ISSUES[@]:+"${KNOWN_ISSUES[@]}"} "$1")
}

run_tc() {
    local tc=$1
    TC_NAME=$2
    local args=("${@:3}")

    let tc_num++
    echo "*** Executing test case: ${TS_NAME:+$TS_NAME - }$TC_NAME"

    local known_issue
    for known_issue in ${KNOWN_ISSUES[@]:+"${KNOWN_ISSUES[@]}"}; do
        echo "    Known issue: $known_issue"
    done
    KNOWN_ISSUES=()

    local stderr=
    { stderr=$(${tc}_tc ${args[@]:+"${args[@]}"} 3>&1 1>&2 2>&3 3>&-); } 2>&1
    local rc=$?

    if [[ $rc -ne 0 ]]; then
        let tc_failed_num++
    fi

    if [[ $rc -ne 0 || $MB2_SELF_TEST_VERBOSE ]]; then
        cat <<END
  ** Stderr     ** [[
$stderr
]]
END
    fi

    return $rc
}

arg_pass_stub_create() {
    while [[ ${1:-} ]]; do
        local stub=$STUBS_DIR/$1
        local results=$STUBS_DIR/$1.args

        touch "$results" || return
        cat >"$stub" <<END || return
#!/bin/bash
echo "stub invoked: \$0 \$(printf "%q " "\$@")" >&2
{ [[ \$# -ne 0 ]] && printf "%q\\n" "\$@"; } >"$results"
exit 0
END
        chmod +x "$stub" || return
        shift
    done
}

arg_pass_stub_remove() {
    while [[ ${1:-} ]]; do
        local stub=$STUBS_DIR/$1
        local results=$STUBS_DIR/$1.args
        rm -f "$stub" || return
        rm -f "$results" || return
        shift
    done
}

arg_pass_stub_results() {
    local results=$STUBS_DIR/$1.args
    [[ -e $results ]] && cat "$results"
}

arg_pass_stub_clear() {
    while [[ ${1:-} ]]; do
        local results=$STUBS_DIR/$1.args
        rm -f "$results" || return
        shift
    done
}

expect_args() {
    [[ $# -ne 0 ]] && printf "%q\n" "$@" || true
}

DEFAULT_TARGET=$(. ~/.scratchbox2/config; echo "$DEFAULT_TARGET")
DEFAULT_JOBS=$(getconf _NPROCESSORS_ONLN)

if inside_build_engine; then
    DEFAULT_DEVICE="Sailfish OS Emulator"
else
    echo "Note: Skipping test cases involving device connection - not inside a Sailfish OS build engine" >&2
    DEFAULT_DEVICE=
fi

################################################################################
# Test the rpm_quote function

rpm_quote_tc() {
    arg_pass_stub_create make || return

    # Create an minimal spec file
    mkdir rpm || return
    cat >rpm/test.spec <<END || return
Name: test
Version: 1.0
Release: 0
Summary: Test
License: BSD

# This would normally come from the environment
%{!?make:%define make make}

%description
Test

%build
%make "x  y"
END

    rpmbuild -bc --short-circuit --noprep --build-in-place --define "_sourcedir $(readlink -f rpm)" rpm/test.spec \
        --define "make make $(rpm_quote "a b" "c  d" e f)" >&2 || return
    local rc=0 expected= actual= diff=
    expected=$(expect_args "a b" "c  d" e f "x  y")
    actual=$(arg_pass_stub_results make) || return
    if ! diff=$(diff <(cat <<<"$expected") <(cat <<<"$actual")); then
        rc=1
        cat <<END
Test case failed: $TC_NAME
  ** Mismatch   ** [[
$diff
]]
  ** Expected   ** [[
$expected
]]
  ** Actual     ** [[
$actual
]]
END
    fi

    arg_pass_stub_remove make || return
    rm -f rpm/test.spec || return
    rmdir rpm || return

    return $rc
}

run_tc rpm_quote "Test RPM macro escaping"

################################################################################
# Test sb2 argument passing

sb2_arg_pass_ts_set_up() {
    arg_pass_stub_create sb2 || return

    # Create an empty spec file
    mkdir rpm || return
    cat >rpm/test.spec <<END || return
# Just say 'define qtc_qmake' to make check_spec_supports_qtc_silent happy
END
}

sb2_arg_pass_ts_tear_down() {
    arg_pass_stub_remove sb2 || return
    rm -f rpm/test.spec || return
    rmdir rpm || return
}

sb2_arg_pass_tc() {
    local expected=$1
    local args=("${@:2}")

    arg_pass_stub_clear sb2 || return
    "$SELF" "${args[@]}" || return
    local actual_raw= actual= diff=
    actual_raw=$(arg_pass_stub_results sb2) || return
    actual=$(sed -e 's,/tmp\.[^/]\+,/@TMPDIR@,' \
                 -e "s,/home/deploy,/tmp/@TMPDIR@," \
                 -e 's,/test\.spec\.[^/]\+,/@TEST_SPEC@,' <<<"$actual_raw")
    if ! diff=$(diff <(cat <<<"$expected") <(cat <<<"$actual")); then
        cat <<END
Test case failed: $TC_NAME
  ** Command    ** $ME $(quote "${args[@]}")
  ** Mismatch   ** [[
$diff
]]
  ** Expected   ** [[
$expected
]]
  ** Actual     ** [[
$actual
]]
  ** Actual RAW ** [[
$actual_raw
]]
END
        return 1
    fi
}

set_up_ts sb2_arg_pass "Passing arguments to sb2"

KNOWN_ISSUE "Does not disable debug by default (ignores --enable-debug)"
KNOWN_ISSUE "Passes -j without argument"
KNOWN_ISSUE "Silently ignores extra arguments"
run_tc sb2_arg_pass "prep" \
    "$(expect_args \
        -t "$DEFAULT_TARGET" rpmbuild --build-in-place --target= \
        --define '_smp_mflags -j' \
        --define '_rpmdir /tmp/@TMPDIR@/RPMS' \
        --define '_sourcedir /tmp/@TMPDIR@/rpm' \
        --define '_rpmfilename %%{name}-%%{version}-%%{release}.%%{arch}.rpm' \
        --buildroot=/tmp/@TMPDIR@/installroot \
        -bp --short-circuit \
        /tmp/@TMPDIR@/rpm/@TEST_SPEC@)" \
    prep "a b" "c  d" e f

run_tc sb2_arg_pass "build" \
    "$(expect_args \
        -t "$DEFAULT_TARGET" rpmbuild --build-in-place --target= \
        --define 'debug_package %{nil}' \
        --define "_smp_mflags -j$(rpm_quote "bad  1")" \
        --define '_rpmdir /tmp/@TMPDIR@/RPMS' \
        --define '_sourcedir /tmp/@TMPDIR@/rpm' \
        --define '_rpmfilename %%{name}-%%{version}-%%{release}.%%{arch}.rpm' \
        --buildroot=/tmp/@TMPDIR@/installroot \
        -bb \
        /tmp/@TMPDIR@/rpm/@TEST_SPEC@ \
        "a b" "c  d" e f)" \
    build --doprep -j "bad  1" "a b" "c  d" e f

run_tc sb2_arg_pass "build with debug" \
    "$(expect_args \
        -t "$DEFAULT_TARGET" rpmbuild --build-in-place --target= \
        --define "_smp_mflags -j$(rpm_quote "bad  1")" \
        --define '_rpmdir /tmp/@TMPDIR@/RPMS' \
        --define '_sourcedir /tmp/@TMPDIR@/rpm' \
        --define '_rpmfilename %%{name}-%%{version}-%%{release}.%%{arch}.rpm' \
        --buildroot=/tmp/@TMPDIR@/installroot \
        -bb \
        /tmp/@TMPDIR@/rpm/@TEST_SPEC@ \
        "a b" "c  d" e f)" \
    build --doprep --enable-debug -j "bad  1" "a b" "c  d" e f

run_tc sb2_arg_pass "qmake" \
    "$(expect_args \
        -t "$DEFAULT_TARGET" rpmbuild --build-in-place --target= \
        --define 'noecho 1' \
        --define 'qtc_builddir /tmp/@TMPDIR@' \
        --define 'qtc_make true ignoring make' \
        --define "qtc_qmake5 %qmake5 $(rpm_quote "a b" "c  d" e f)" \
        --define "qtc_qmake %qmake $(rpm_quote "a b" "c  d" e f)" \
        -bc --short-circuit \
        /tmp/@TMPDIR@/rpm/@TEST_SPEC@)" \
    qmake "a b" "c  d" e f

run_tc sb2_arg_pass "make" \
    "$(expect_args \
        -t "$DEFAULT_TARGET" rpmbuild --build-in-place --target= \
        --define 'noecho 1' \
        --define 'qtc_builddir /tmp/@TMPDIR@' \
        --define 'qtc_qmake5 true ignoring qmake' \
        --define 'qtc_qmake true ignoring qmake' \
        --define "qtc_make make %{?_smp_mflags} $(rpm_quote "a b" "c  d" e f)" \
        -bc --short-circuit \
        /tmp/@TMPDIR@/rpm/@TEST_SPEC@)" \
    make "a b" "c  d" e f

KNOWN_ISSUE "Silently ignores extra arguments"
run_tc sb2_arg_pass "install" \
    "$(expect_args \
        -t "$DEFAULT_TARGET" rpmbuild --build-in-place --target= \
        --define 'noecho 1' \
        --define 'qtc_builddir /tmp/@TMPDIR@' \
        --define '_sourcedir /tmp/@TMPDIR@/rpm' \
        --define '_skip_install_processing 1' \
        --buildroot='/tmp/@TMPDIR@/installroot' \
        -bi --short-circuit --nocheck \
        /tmp/@TMPDIR@/rpm/@TEST_SPEC@)" \
    install "a b" "c  d" e f

KNOWN_ISSUE "Silently ignores extra arguments"
run_tc sb2_arg_pass "rpm" \
    "$(expect_args \
        -t "$DEFAULT_TARGET" rpmbuild --build-in-place --target= \
        --define 'noecho 1' \
        --define 'qtc_builddir /tmp/@TMPDIR@' \
        --define '_rpmdir /tmp/@TMPDIR@/RPMS' \
        --define '_sourcedir /tmp/@TMPDIR@/rpm' \
        --define '_rpmfilename %%{name}-%%{version}-%%{release}.%%{arch}.rpm' \
        --buildroot='/tmp/@TMPDIR@/installroot' \
        -bb --noprep --nobuildstage --noclean \
        /tmp/@TMPDIR@/rpm/@TEST_SPEC@)" \
    rpm "a b" "c  d" e f

tear_down_ts sb2_arg_pass

################################################################################
# Test arguments passing to commands invoked by rpmbuild

rpmbuild_arg_pass_sb2_stub() {
    echo "stub invoked: $0 $(printf "%q " "$@")" >&2

    local args=("$@")
    bad_args() {
        echo "stub $0: unexpected arguments: $(printf "%q " "${args[@]}")" >&2
    }

    if ! [[ $1 == -t && $3 != -* ]]; then
        bad_args
        return 1
    fi

    shift 2

    case $1 in
        gcc)
            case $2 in
                -dumpmachine)
                    echo "i486-meego-linux"
                    ;;
                *)
                    bad_args
                    return 1
                    ;;
            esac
            ;;
        rpmbuild)
            # rpmbuild writes some progress messages to stdout
            exec "$@" >&2
            ;;
        rpmspec)
            exec "$@"
            ;;
        *)
            bad_args
            return 1
            ;;
    esac
}

rpmbuild_arg_pass_ts_set_up() {
    RPMBUILD_STUBS=(qmake make)
    arg_pass_stub_create "${RPMBUILD_STUBS[@]}"

    # Create an sb2 stub
    cat >"$STUBS_DIR/sb2" <<END || return
#!/bin/bash
$(declare -f rpmbuild_arg_pass_sb2_stub)
rpmbuild_arg_pass_sb2_stub "\$@"
END
    chmod +x "$STUBS_DIR/sb2" || return

    # Create a minimal spec file
    mkdir rpm || return
    cat >rpm/test.spec <<END || return
Name:       test

# These would normally come from the environment
%{!?qmake:%define qmake qmake}
%{!?qmake5:%define qmake5 qmake}

# This is to not require meego-rpm-config installed for self-test execution
%global __os_install_post %{nil}

%{!?qtc_qmake:%define qtc_qmake %qmake}
%{!?qtc_qmake5:%define qtc_qmake5 %qmake5}
%{!?qtc_make:%define qtc_make make}
%{?qtc_builddir:%define _builddir %qtc_builddir}
Summary:    Test
Version:    0.1
Release:    1
Group:      Qt/Qt
License:    LICENSE
URL:        http://example.org/
Source0:    %{name}-%{version}.tar.bz2

%description
Test

%prep
%setup -q -n %{name}-%{version}

%build
%qtc_qmake5 
%qtc_make %{?_smp_mflags}

%install
mkdir -p %{buildroot}

%files
%defattr(-,root,root,-)
END
}

rpmbuild_arg_pass_ts_tear_down() {
    arg_pass_stub_remove "${RPMBUILD_STUBS[@]}" || return
    rm -f "$STUBS_DIR/sb2" || return
    rm -f rpm/test.spec || return
    rmdir rpm || return
}

rpmbuild_arg_pass_tc() {
    local all_expected=("${@:1:${#RPMBUILD_STUBS[*]}}")
    local args=("${@:1+${#RPMBUILD_STUBS[*]}}")

    local rc=0

    arg_pass_stub_clear "${RPMBUILD_STUBS[@]}"
    "$SELF" "${args[@]}" || return
    local i=
    for ((i=0; i<${#RPMBUILD_STUBS[@]}; i++)); do
        local stub= expected= actual= diff=
        stub=${RPMBUILD_STUBS[i]}
        expected=${all_expected[i]}
        actual=$(arg_pass_stub_results "$stub")
        if ! diff=$(diff <(cat <<<"$expected") <(cat <<<"$actual")); then
            rc=1
            cat <<END
Test case failed: $TC_NAME/$i
  ** Command    ** $ME $(printf "%q " "${args[@]}")
  ** Failed for ** $stub
  ** Mismatch   ** [[
$diff
]]
  ** Expected   ** [[
$expected
]]
  ** Actual     ** [[
$actual
]]
END
        fi
    done

    return $rc
}

set_up_ts rpmbuild_arg_pass "Passing arguments to commands invoked by rpmbuild"

run_tc rpmbuild_arg_pass "build" \
    "$(expect_args )" \
    "$(expect_args -j"$DEFAULT_JOBS")" \
    build

run_tc rpmbuild_arg_pass "qmake" \
    "$(expect_args "a b" "c  d" e f)" \
    "$(expect_args )" \
    qmake "a b" "c  d" e f

KNOWN_ISSUE "Passes extra -j to make"
if [[ $DEFAULT_JOBS -ne 1 ]]; then
    run_tc rpmbuild_arg_pass "make" \
        "$(expect_args )" \
        "$(expect_args -j"$DEFAULT_JOBS" "a b" "c  d" e f -j"$DEFAULT_JOBS")" \
        make "a b" "c  d" e f
else
    run_tc rpmbuild_arg_pass "make" \
        "$(expect_args )" \
        "$(expect_args "a b" "c  d" e f)" \
        make "a b" "c  d" e f
fi

tear_down_ts rpmbuild_arg_pass

################################################################################
# Test arguments passing to commands invoked using run|ssh subcommand

ssh_arg_pass_ts_set_up() {
    :
}

ssh_arg_pass_ts_tear_down() {
    :
}

ssh_arg_pass_tc() {
    local expected=$1
    local args=("${@:2}")

    local actual= diff=
    actual=$("$SELF" "${args[@]}")
    if ! diff=$(diff <(cat <<<"$expected") <(cat <<<"$actual")); then
        cat <<END
Test case failed: $TC_NAME
  ** Command    ** $ME $(quote "${args[@]}")
  ** Mismatch   ** [[
$diff
]]
  ** Expected   ** [[
$expected
]]
  ** Actual     ** [[
$actual
]]
END
        return 1
    fi
}

set_up_ts ssh_arg_pass "Passing arguments using run|ssh subcommand"

run_tc ssh_arg_pass "local - just spaces" \
    "$(printf '%q ' 'a b' 'c  d' e f)" \
    run printf '%q ' 'a b' 'c  d' e f

run_tc ssh_arg_pass "local - spaces and newlines" \
    "$(printf '%q'$'\n' 'echo b' 'c  d' e f)" \
    run printf '%q'$'\n' 'echo b' 'c  d' e f

run_tc ssh_arg_pass "local - spaces and backslashes" \
    "$(printf '%q\n' 'a\ b' 'c  d' e f)" \
    run printf '%q\n' 'a\ b' 'c  d' e f

if [[ $DEFAULT_DEVICE ]]; then
    run_tc ssh_arg_pass "remote - just spaces" \
        "$(printf '%q ' 'a b' 'c  d' e f)" \
        --device "$DEFAULT_DEVICE" run printf '%q ' 'a b' 'c  d' e f

    run_tc ssh_arg_pass "remote - spaces and newlines" \
        "$(printf '%q'$'\n' 'echo b' 'c  d' e f)" \
        --device "$DEFAULT_DEVICE" run printf '%q'$'\n' 'echo b' 'c  d' e f

    run_tc ssh_arg_pass "remote - spaces and backslashes" \
        "$(printf '%q\n' 'a\ b' 'c  d' e f)" \
        --device "$DEFAULT_DEVICE" run printf '%q\n' 'a\ b' 'c  d' e f
fi

tear_down_ts ssh_arg_pass

################################################################################
# Test --fix-version behavior

fix_version_ts_set_up() {
    COMMITS_U=()
    COMMITS_D=()

    get_commit() {
        eval echo \${COMMITS_${1:0:1}[${1:1}]} |grep .
    }

    local i= commit= tag_name= tag_object=

    git init . --quiet || return
    git config user.email "john@doe.com" || return
    git config user.name "John Doe" || return

    git checkout -b upstream --quiet
    for ((i=0; i<=30; i++)); do
        printf "U%02d\n" "$i" > U
        git add U || return
        date="@$(TZ=UTC date --date="2000-01-01 00:00:00 UTC +$i days" +%s) +0000"
        GIT_AUTHOR_DATE=$date GIT_COMMITTER_DATE=$date \
            git commit --message "$(<U)" --quiet || return
        commit=$(git rev-list --max-count=1 --abbrev-commit HEAD) || return
        COMMITS_U=(${COMMITS_U[*]:-} $commit)
    done

    git checkout -b downstream "${COMMITS_U[10]}" --quiet || return
    for ((i=0; i<=20; i++)); do
        if [[ $i -eq 10 ]]; then
            git merge --no-commit "${COMMITS_U[20]}" --quiet 2>/dev/null || return
        fi
        printf "D%02d\n" "$i" > D
        git add D || return
        date="@$(TZ=UTC date --date="2000-01-01 00:00:00 UTC +$((i+10)) days +12 hours" +%s) +0000"
        GIT_AUTHOR_DATE=$date GIT_COMMITTER_DATE=$date \
            git commit --message "$(<D)" --quiet || return
        commit=$(git rev-list --max-count=1 --abbrev-commit HEAD) || return
        COMMITS_D=(${COMMITS_D[*]:-} $commit)
    done

    while [[ ${1:-} ]]; do
        case $1 in
            --tag)
                tag_name=$2
                tag_object=$(get_commit $3) || return
                git tag "$tag_name" "$tag_object" || return
                shift 2
                ;;
            --tag-a)
                tag_name=$2
                tag_object=$(get_commit $3) || return
                tag_annotation="$3"
                git tag -a -m "$tag_annotation" "$tag_name" "$tag_object" || return
                shift 2
                ;;
            *)
                return 1
                ;;
        esac
        shift
    done
}

fix_version_ts_tear_down() {
    unset COMMITS_U COMMITS_D
    unset -f get_commit
    rm -rf .git || return
    rm -f U D dirty || return
}

fix_version_tc() {
    local dirty=$1 head=$2 expected_raw=$3 hint=${4:-}

    head=$(get_commit "$head") || return

    git reset --hard --quiet || return
    git checkout -B downstream "$head" --quiet || return
    if [[ $dirty == dirty ]]; then
        echo dirty >> D
    fi

    local version_file=version
    local last_stash_file=last_stash

    echo "Version:" > $version_file

    (
        git() (
            echo "stub invoked: git" >&2
            if [[ $1 == stash && $2 == create ]]; then
                date="@$(TZ=UTC date --date="2000-12-31 18:00:00 UTC" +%s) +0000"
                GIT_AUTHOR_DATE=$date GIT_COMMITTER_DATE=$date \
                    command git stash create |tee $last_stash_file
            else
                command git "$@"
            fi
        )

        OPT_FIX_VERSION=1
        OPT_FIX_VERSION_HINT=$hint
        OPT_NO_FIX_VERSION=
        fix_package_version $version_file >&2
    ) || return

    local actual=$(sed 's/^Version: //' $version_file)

    local stash_sha1=
    if [[ -e $last_stash_file ]]; then
        stash_sha1=$(git rev-list --max-count=1 --abbrev-commit "$(<$last_stash_file)")
    fi

    local expected=$expected_raw i=
    for ((i=0; i<=30; i++)); do
        expected=${expected//@U$i@/${COMMITS_U[$i]}}
    done
    for ((i=0; i<=20; i++)); do
        expected=${expected//@D$i@/${COMMITS_D[$i]}}
    done
    expected=${expected//@STASH@/${stash_sha1:-<none>}}

    if [[ $actual != "$expected" ]]; then
        cat <<END
Test case failed: $TC_NAME
  ** Arguments    ** $(printf "%q " "$@")
  ** Expected     ** '$expected'
  ** Actual       ** '$actual'
  ** Expected RAW ** '$expected_raw'
  ** Git-status   ** [[
$(git status)
]]
  ** Git-log      ** [[
$(git log --graph --decorate --pretty=fuller --all ${stash_sha1:-})
]]
END
        return 1
    fi
}

# Works with Git history like this
#
# U00---...---U10---U11---...---U20---U21---...---U30 <-- upstream
#               \                 \
#                D00---D01---...---D10---D11---...---D20 <-- downstream
#
# Upstream commit dates are 2000-01-01 + <num> days 00:00 UTC, downstream commit dates are
# 2000-01-01 + <num+10> days 12:00 UTC, stashes are 2000-12-31 18:00 UTC.

set_up_ts fix_version "Test --fix-version behavior" \
    --tag v0.1 U5 \
    --tag v0.2 U10 \
    --tag v0.3 U15 \
    --tag v0.4 U20 \
    --tag v0.5 U25 \
    --tag mer/v0.2+git1 D5 \
    --tag mer/v0.4+git1 D11 \
    --tag-a mer/v0.4+git2 D15 \
    --tag mer/v0.4+git3 D20

run_tc fix_version "on tag, clean D5"               clean D5  0.2+git1
run_tc fix_version "ahead tag, clean D7"            clean D7  0.2+git1+downstream.2000''01''18''12''00''00.@D7@
run_tc fix_version "ahead tag, dirty D7"            dirty D7  0.2+git1+downstream.2000''12''31''18''00''00.@STASH@
run_tc fix_version "ahead upstream tag, clean D10"  clean D10 0.4+downstream.2000''01''21''12''00''00.@D10@
run_tc fix_version "on tag, clean D11"              clean D11 0.4+git1
run_tc fix_version "on tag, dirty D11"              dirty D11 0.4+git1+downstream.2000''12''31''18''00''00.@STASH@
run_tc fix_version "ahead tag, clean D12"           clean D12 0.4+git1+downstream.2000''01''23''12''00''00.@D12@
run_tc fix_version "ahead tag, dirty D12"           dirty D12 0.4+git1+downstream.2000''12''31''18''00''00.@STASH@
run_tc fix_version "on annotated, clean D15"        clean D15 0.4+git2
run_tc fix_version "ahead annotated, clean D16"     clean D16 0.4+git2+downstream.2000''01''27''12''00''00.@D16@
run_tc fix_version "ahead annotated, dirty D16"     dirty D16 0.4+git2+downstream.2000''12''31''18''00''00.@STASH@
run_tc fix_version "on tag, clean D15 + hint"       clean D15 0.4+git1+downstream.2000''01''26''12''00''00.@D15@    mer/v0.4+git1
run_tc fix_version "on tag, dirty D15 + hint"       dirty D15 0.4+git1+downstream.2000''12''31''18''00''00.@STASH@  mer/v0.4+git1
run_tc fix_version "ahead tag, clean D16 + hint"    clean D16 0.4+git1+downstream.2000''01''27''12''00''00.@D16@    mer/v0.4+git1
run_tc fix_version "ahead tag, dirty D16 + hint"    dirty D16 0.4+git1+downstream.2000''12''31''18''00''00.@STASH@  mer/v0.4+git1

tear_down_ts fix_version

################################################################################
# Test the readarray behavior - simplified version implemented as a shell
# function for compatibility with older BASH

readarray_tc() {
    local expected=('  abc *  def  ' '  g  h  i  ')
    local actual=()
    echo "Note: readarray is a $(type -t readarray)" >&2
    readarray -t actual < <(printf "%s\n" "${expected[@]}")
    if ! (
        [[ ${#expected[*]} -eq ${#actual[*]} ]] || exit
        for ((i=0; i<${#expected[*]}; i++)); do
            [[ ${actual[$i]} == "${expected[$i]}" ]] || exit
        done
        ); then
        cat <<END
Test case failed: $TC_NAME
  ** Expected   ** [[
$(declare -p expected)
]]
  ** Actual     ** [[
$(declare -p actual)
]]
END
        return 1
    fi
}

run_tc readarray "Test readarray behavior"

################################################################################
# Test build phases separation

rpmbuild_phases_sb2_stub() {
    echo "stub invoked: $0 $(printf "%q " "$@")" >&2

    local args=("$@")
    bad_args() {
        echo "stub $0: unexpected arguments: $(printf "%q " "${args[@]}")" >&2
    }

    if ! [[ $1 == -t && $3 != -* ]]; then
        bad_args
        return 1
    fi

    shift 2

    case $1 in
        gcc)
            case $2 in
                -dumpmachine)
                    echo "i486-meego-linux"
                    ;;
                *)
                    bad_args
                    return 1
                    ;;
            esac
            ;;
        rpmbuild)
            # rpmbuild writes some progress messages to stdout
            exec "$@" >&2
            ;;
        rpmspec)
            exec "$@"
            ;;
        *)
            bad_args
            return 1
            ;;
    esac
}

rpmbuild_phases_ts_set_up() {
    RPMBUILD_STUBS=(my_setup qmake make my_install my_check)
    arg_pass_stub_create "${RPMBUILD_STUBS[@]}"

    # Create an sb2 stub
    cat >"$STUBS_DIR/sb2" <<END || return
#!/bin/bash
$(declare -f rpmbuild_phases_sb2_stub)
rpmbuild_phases_sb2_stub "\$@"
END
    chmod +x "$STUBS_DIR/sb2" || return

    # Create a minimal spec file
    mkdir rpm || return
    cat >rpm/test.spec <<END || return
Name:       test

# These would normally come from the environment
%{!?qmake:%define qmake qmake}
%{!?qmake5:%define qmake5 qmake}

# This is to not require meego-rpm-config installed for self-test execution
%global __os_install_post %{nil}

%{!?qtc_qmake:%define qtc_qmake %qmake}
%{!?qtc_qmake5:%define qtc_qmake5 %qmake5}
%{!?qtc_make:%define qtc_make make}
%{?qtc_builddir:%define _builddir %qtc_builddir}
Summary:    Test
Version:    0.1
Release:    1
Group:      Qt/Qt
License:    LICENSE
URL:        http://example.org/
Source0:    %{name}-%{version}.tar.bz2

%description
Test

%prep
my_setup

%build
%qtc_qmake5
%qtc_make %{?_smp_mflags}

%install
mkdir -p %{buildroot}
my_install

# Verifies that --noclean is used
touch %{buildroot}/foo

%check
my_check

%files
%defattr(-,root,root,-)
/foo
END
}

rpmbuild_phases_ts_tear_down() {
    arg_pass_stub_remove "${RPMBUILD_STUBS[@]}" || return
    rm -f "$STUBS_DIR/sb2" || return
    rm -f rpm/test.spec || return
    rmdir rpm || return
    rm -f RPMS/test-0.1-1.i486.rpm || return
    ! [[ -d RPMS ]] || rmdir RPMS || return
}

rpmbuild_phases_tc() {
    local expected=$1
    local args=("${@:2}")

    arg_pass_stub_clear "${RPMBUILD_STUBS[@]}" || return
    rm -f RPMS/test-0.1-1.i486.rpm || return

    "$SELF" "${args[@]}" || return

    local actual=
    if arg_pass_stub_results my_setup &>/dev/null; then
        actual="+prep"
    else
        actual="-prep"
    fi

    if arg_pass_stub_results qmake &>/dev/null; then
        actual="$actual +qmake"
    else
        actual="$actual -qmake"
    fi

    if arg_pass_stub_results make &>/dev/null; then
        actual="$actual +make"
    else
        actual="$actual -make"
    fi

    if arg_pass_stub_results my_install &>/dev/null; then
        actual="$actual +install"
    else
        actual="$actual -install"
    fi

    if arg_pass_stub_results my_check &>/dev/null; then
        actual="$actual +check"
    else
        actual="$actual -check"
    fi

    if [[ -e RPMS/test-0.1-1.i486.rpm ]]; then
        if rpm -q --requires -p RPMS/test-0.1-1.i486.rpm |grep -q '^rpmlib(ShortCircuited)'; then
            actual="$actual +rpm (short-circuited)"
        else
            actual="$actual +rpm"
        fi
    else
        actual="$actual -rpm"
    fi

    if [[ $actual != "$expected" ]]; then
        cat <<END
Test case failed: $TC_NAME
  ** Command    ** $ME $(printf "%q " "${args[@]}")
  ** Expected   ** $expected
  ** Actual     ** $actual
END
        return 1
    fi

    return 0
}

set_up_ts rpmbuild_phases "Separating build phases"

run_tc rpmbuild_phases "prep" \
    "+prep -qmake -make -install -check -rpm" prep
run_tc rpmbuild_phases "build" \
    "-prep +qmake +make +install +check +rpm" build
run_tc rpmbuild_phases "build --doprep" \
    "+prep +qmake +make +install +check +rpm" build --doprep
run_tc rpmbuild_phases "qmake" \
    "-prep +qmake -make -install -check -rpm" qmake
run_tc rpmbuild_phases "make" \
    "-prep -qmake +make -install -check -rpm" make
run_tc rpmbuild_phases "install" \
    "-prep -qmake -make +install -check -rpm" install
run_tc rpmbuild_phases "rpm" \
    "-prep -qmake -make +install +check +rpm" rpm

tear_down_ts rpmbuild_phases


################################################################################

if [[ $tc_failed_num -eq 0 ]]; then
    echo "*** All $tc_num tests passed"
else
    echo "*** $tc_failed_num out of $tc_num failed"
fi

# For Emacs:
# Local Variables:
# indent-tabs-mode:nil
# tab-width:4
# mode: sh
# End:
# For VIM:
# vim:set softtabstop=4 shiftwidth=4 tabstop=4 expandtab:
