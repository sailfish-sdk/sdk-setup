#!/bin/bash
#
# Copyright (C) 2013 - 2016 Jolla Ltd.
# Contact: David Greaves <david.greaves@jollamobile.com>
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
#
# - Redistributions of source code must retain the above copyright
#   notice, this list of conditions and the following disclaimer.
# - Redistributions in binary form must reproduce the above copyright
#   notice, this list of conditions and the following disclaimer in
#   the documentation and/or other materials provided with the
#   distribution.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.

synopsis() {
    cat <<EOF
usage: $ME [global-opts] <command> [command-opts]
       $ME --version
EOF
}

short_usage() {
    synopsis
    cat <<EOF

Try '$ME --help' for more information.
EOF
    # exit if any argument is given
    [[ -n "$1" ]] && exit 1
}

usage() {
    less --quit-if-one-screen <<EOF
$(synopsis)

Executes a subset of build commands in the context of an rpmbuild.
Typically called from QtCreator to perform qmake/make phases of a project.
Note that any other build steps in the .spec file will also be run.

<specfile> will be looked for in the current rpm/ dir. If there is more than
one it must be provided.  $ME is aware of spectacle and will update the spec
file if there is an obvious yaml file which is newer.

CWD is used as a base dir for installroot/ and RPMS/ to allow for shadow
builds. Shadow builds can be done by passing project file or directory path to
the "build" or "qmake" command:

    $ mkdir build && cd build
    $ mb2 build ../path/to/sources

    Or manually invoking each step:

    $ mkdir build && cd build
    $ mb2 qmake ../path/to/sources
    $ mb2 make
    $ mb2 rpm

Limitations related to shadow builds:

    1. Shadow build is only available for packages that use qmake.
    2. The "--doprep" option to the "build" command cannot be used with shadow
       builds.
    3. If "prep" or "apply" is needed, it must be used directly on the source
       tree prior to starting a shadow build (shadow builds for multiple
       targets are still possible provided that the %prep section is
       target-independent).

If a file exists with '.changes' extension, otherwise matching the
spec file name, the effect will be the same as having a %changelog
section in the spec file.  If a file with '.changes.run' extension is
found instead, this file will be executed and its output treated as
the actual changelog.

COMMANDS
    installdeps
        Install the missing build-time dependencies as is done implicitly by
        the "prep", "build" and "qmake" commands but refresh the package cache
        first.
        Compatible global options: -s -t

    prep
        Run rpmbuild. Execute just the %prep section of the .spec file.
        Compatible global options: -n.

    apply [-R]
        Apply all patches defined in the .spec file to the source tree.
        -R    reverse apply patches (patch -R)

    build [-p|--doprep] [-d|--enable-debug] [-j <n>] [<project-dir-or-file>]
          [[--] <rpmbuild-extra-args>]
        Run rpmbuild. Execute all sections of the .spec file except for %prep
        unless told otherwise. If path to a <project-dir-or-file> is passed,
        shadow build will be done. Otherwise the current working directory is
        treated as the project directory. (The file name part is ignored -
        project file selection is done by qmake call inside the .spec file.)
        -p    run %prep phase as well
        -d    enable debug build
        -j <n> use only 'n' CPUs to build
        Compatible global options: -s -t -i -x -X -c -n

    qmake [<project-dir-or-file>] [[--] <qmake-extra-args>]
        Run rpmbuild. Execute just the %build section of the .spec file,
        suppressing any "make" invocation figuring in that section. If path to
        a <project-dir-or-file> is passed, shadow build will be done. Otherwise
        the current working directory is treated as the project directory. (The
        file name part is ignored - project file selection is done by qmake call
        inside the .spec file.)
        Compatible global options: -s -t -n

    make [<make-extra-args>]
        Run rpmbuild. Execute just the %build section of the .spec file,
        suppressing any "qmake" invocation figuring in that section.
        Compatible global options: -s -t

    install
        Run rpmbuild. Execute just the %install section of the .spec file.
        Compatible global options: -s -t

    rpm
        Run rpmbuild. Execute just the %install section of the .spec file, then
        build binary packages.
        Compatible global options: -s -t -i -x -X -c

    deploy --zypper|--pkcon|--rsync|--sdk
        Deploy build results to a device. This implies also the "install" step
        and except for the --rsync method it will include also the "rpm" step.
        Compatible global options: -s -t -d -i -f -x -X -c

    run [<command> [<args>]]
        Run the given command (on device if --device given).  Can be used for
        running gdb and a gdb server.
        Compatible global options: -s -t -d

GLOBAL OPTIONS
    -i, --increment
        Increment release number in .spec file

    -t, --target <name>
        Specify the sb2 target to use

    -d, --device <name>
        Specify the device

    -o, --outputdir <dir>
        Where to place produced RPM files. Defaults to ./RPMS directory.  With
        this option existing files in the output directory are preserved

    -s, --specfile <file>
        Specify the .spec file

    -f, --shared-folder <dir>
        The folder where QtCreator shares devices.xml and ssh keys this option
        is useful if deploy option is used outside of virtual machine

    -x, --fix-version[=<tag>]
        This option is implied when used inside a Git working tree (use -X to
        override). Within Application SDK it is only implied if the version
        recorded in the .spec file is exactly "0".
        Use the latest tag from the current git branch as package version or
        the given <tag>.  If the current HEAD, index or working tree differs
        from the tree denoted by the tag, a suffix composed from the current
        branch name, time stamp and a commit SHA1 will be added to the package
        version.  If git-state is not clean a git-stash will be created and its
        SHA1 will be used instead of HEAD.

    -X, --no-fix-version
        Override --fix-version option.

    -n, --no-deps
        Do not update target dependencies

    -c, --git-change-log[=<args>]
        Include change log generated from Git history with 'git-change-log'
        command, forwarding any <args>.  This option is not intended for
        regular use - create a script file named after the .spec file but with
        '.changes.run' extension to instruct $ME to generate changelog with
        'git-change-log <args>' instead.

EOF
}

notice() {
    echo "NOTICE: $*" >&2
}

fatal() {
    echo "Fatal: $*" >&2
    exit 1
}

# readarray is a bash >= 4.0 feature
if ! type readarray &>/dev/null; then
    readarray() {
        if ! [[ $# -eq 2 && $1 == -t && $(declare -p "$2" 2>/dev/null) == "declare -a "* ]]; then
            fatal "Internal error: readarray: unimplemented case"
        fi

        local line=
        eval $2=\(\)
        while IFS= read -r line; do
            eval $2=\(\${$2[@]:+\"\${$2[@]}\"} \"\$line\"\)
        done
    }
fi

git_() (
    # Cannot use the '-C' option - it requires newer Git.
    # Cannot use '--git-dir' + '--work-tree' options - they break at least git-stash.
    if [[ $OPT_SRC_DIR ]]; then
        cd "$OPT_SRC_DIR" || return
    fi
    # At least git-stash requires an explicitly set user identity. Setting environment
    # variables compared to passing options with '-c' works also for subprocesses invoked via
    # `git-submodule foreach`
    if inside_build_engine; then
        export GIT_AUTHOR_NAME='mersdk' GIT_AUTHOR_EMAIL='mersdk@mersdk'
        export GIT_COMMITTER_NAME='mersdk' GIT_COMMITTER_EMAIL='mersdk@mersdk'
    fi

    git "$@"
)

try_to_make_spec() { # Tries to create a missing spec
    [[ -f "$1" ]] && return # It's not missing
    local yaml="${1%.spec}.yaml"
    [[ -f "$yaml" ]] || return # No yaml
    ANSI_COLORS_DISABLED=1 specify -n -N "$yaml" || fatal "unable to convert yaml to spec"
}

try_to_make_spec_from_yaml() {
    # Tries to create a missing spec from a given yaml
    try_to_make_spec "${1%.yaml}.spec"
}

sanitize_changelog() {
    sed 's/%/%%/g'
}

try_to_make_changelog() {
    local changes_file=${OPT_SPEC%.spec}.changes
    local changes_run_file=${OPT_SPEC%.spec}.changes.run

    if [[ $OPT_GIT_CHANGE_LOG ]]; then
        notice "Auto generating changelog from Git history ..."
        echo "%changelog"
        git-change-log $OPT_GIT_CHANGE_LOG_ARGS |sanitize_changelog
    elif [[ -f $changes_file ]]; then
        notice "Appending changelog entries to spec ..."
        echo "%changelog"
        cat $changes_file |sanitize_changelog
    elif [[ -f $changes_run_file ]]; then
        notice "Generating changelog entries with $changes_run_file ..."
        local runner=
        # In build VM the shared filesystem is noexec
        if ! [[ -x $changes_run_file ]]; then
            if [[ $(head -c 3 <$changes_run_file |cat -v) == '#!/' ]]; then
                runner=$(sed -n '1s/^#!//p' $changes_run_file)
            else
                fatal "Not executable: $changes_run_file"
            fi
        fi
        echo "%changelog"
        $runner $changes_run_file |sanitize_changelog
        [[ ${PIPESTATUS[0]} -eq 0 ]] || fatal "unable to generate changelog entries"
    fi
}

ensure_spec_newer_than_yaml() {
    local yaml="${OPT_SPEC%.spec}.yaml"
    if [[ -f "$yaml" ]] && [[ "$yaml" -nt "$OPT_SPEC" ]]; then # -nt is newer than
        ANSI_COLORS_DISABLED=1 specify -n -N "$yaml" || fatal "unable to convert yaml to spec"
    fi

    # it's ok also not to have a yaml
}

verify_target_dependencies() {
    [[ $OPT_NO_DEPS ]] && return

    local deps=()
    readarray -t deps < <(sb2 -t "$OPT_TARGET" rpmspec --query --buildrequires "$OPT_SPEC" |sed 's/\s*$//')
    if [[ $deps ]]; then
        if inside_build_engine; then
            local oldpkgs=$(sb2 -t "$OPT_TARGET" -m sdk-install rpm -qa)
        fi
        sb2 -t "$OPT_TARGET" -m sdk-install -R zypper --quiet --non-interactive in "${deps[@]}"
        if inside_build_engine; then
            local newpkgs=$(sb2 -t "$OPT_TARGET" -m sdk-install rpm -qa)
            if [[ $newpkgs != $oldpkgs ]]; then
                sdk-manage target sync "$OPT_TARGET"
            fi
        fi
    fi
}

get_spec_tag() {
    rpmspec --query --srpm --queryformat="$1" "$OPT_SPEC"
}

fix_package_version() {
    local spec_file=$1

    local version_in_spec=$(sed -n 's/^Version:[[:space:]]*//p' "$spec_file")

    if [[ $OPT_NO_FIX_VERSION ]]; then
        return
    elif [[ ! $OPT_FIX_VERSION ]]; then
        # When used inside a build engine VM, fixing version is enabled implicitly only if the
        # version in spec file is exactly "0" - this is because there is no UI in Qt Creator
        # that would allow to override this.
        if inside_build_engine && [[ $version_in_spec != 0 ]]; then
            return
        fi
    fi

    if ! inside_git_worktree; then
        if [[ $OPT_FIX_VERSION || $version_in_spec == 0 ]]; then
            notice "Not inside a Git working tree, will not fix package version."
        fi
        return
    fi

    local tag
    if [[ $OPT_FIX_VERSION_HINT ]]; then
        tag=$OPT_FIX_VERSION_HINT
    else
        if ! tag=$(git_ describe --tags --abbrev=0 2>/dev/null); then
            notice "No tags describe the HEAD, will not fix package version."
            return
        fi
    fi

    local version=$tag
    version=${version#*/}   # allow tags to have a prefix to allow vendor marking
    version=${version#v}    # some people like to prefix versions with a v

    local stash=
    if ! stash=$(git_ stash create); then
        fatal "Cannot save state of Git working tree: git-stash failed."
    fi
    local head=${stash:-$(git_ rev-parse HEAD)}

    local modified_submodules=
    modified_submodules=$(
        describe_if_modified()
        {
            local stash=
            stash=$(git stash create) || return
            local head=${stash:-$(git rev-parse HEAD)}
            if [[ $head != $sha1 ]]; then
                local short=$(git rev-list --max-count=1 --abbrev-commit "$head")
                echo -n "+$name.$short"
            fi
        }
        git_ submodule --quiet foreach --recursive \
            "$(declare -f describe_if_modified); describe_if_modified")
    if [[ $? -ne 0 ]]; then
        fatal "Cannot save state of Git submodules: git-stash failed for some."
    fi

    if [[ $(git_ rev-parse "$tag^{}") != "$head" || $modified_submodules ]]; then
        local branch=$(git_ rev-parse --abbrev-ref HEAD)
        local timestamp=$(TZ=UTC date --date=@$(git_ log --max-count=1 --pretty=%ct "$head") +%Y%m%d%H%M%S)
        local sha1sum=$(git_ rev-list --max-count=1 --abbrev-commit "$head")
        version=$version+$branch.$timestamp.$sha1sum$modified_submodules
    fi

    version=${version//[^+_[:alnum:]]/.} # replace characters not allowed in the version field

    echo "Setting version: ${version}"
    sed -i "s,^Version:.*,Version: ${version}," "$spec_file"
}

# Helper to read XML
read_dom () {
    local IFS=\>
    read -d \< ENTITY CONTENT
    local RET=$?
    TAG_NAME=${ENTITY%% *}
    ATTRIBUTES=${ENTITY#* }
    return $RET
}

# This slurps the XML and converts tags like <subnet> to $device_subnet
# Also sets device_name and device_type from the attributes
get_device() {
    local FOUND_DEVICE=
    local IN_DEVICE=
    local maintag=
    while read_dom; do
        case $TAG_NAME in
            device )
                maintag=$TAG_NAME
                eval local $ATTRIBUTES
                if [[ "$name" == "$1" ]] ; then
                    FOUND_DEVICE=1
                    IN_DEVICE=1
                    device_name="$name"
                    device_type="$type"
                else
                    IN_DEVICE=
                fi
                ;;
            engine )
                maintag=$TAG_NAME
                eval local $ATTRIBUTES
                ;;
            mac|index|subnet|ip|sshkeypath|sshport )
                # Don't process and store nested tags if we're in
                # device with wrong name
                if [[ "$maintag" == "device" ]] && [[ $IN_DEVICE != 1 ]]; then
                    continue
                fi
                eval ${maintag}_$TAG_NAME=\"$CONTENT\"
                ;;
        esac
    done
    # Set this up as it's useful
    if [[ "$device_subnet" ]]; then
        device_ip="$device_subnet".$device_index
    fi
    if [[ ! "$device_sshport" ]]; then
        device_sshport=22
    fi
    if [[ "$FOUND_DEVICE" == 1 ]]; then return 0; else return 1; fi
}

rsync_as() {
    local user="$1";shift
    local key=$(get_shared_dir)/${device_sshkeypath}/$user
    [[ -f "$key" ]] || fatal "No key for user $user on $device_name given in devices.xml (rsync $key)"
    RSYNC_RSH="ssh -F /etc/ssh/ssh_config.sdk -l $user -i \"$key\" -p $device_sshport" rsync "$@"
}

ssh_as() {
    local user="$1";shift
    local key=$(get_shared_dir)/${device_sshkeypath}/$user
    [[ -f "$key" ]] || fatal "No key for user $user on $device_name given in devices.xml ($key)"
    ssh -F /etc/ssh/ssh_config.sdk -i "$key" -l $user $device_ip -p $device_sshport "$(quote "$@")"
}

cd_to_spec_setup_dir() {
    # avoid spawning another process for | cut -s -f2 -d '/'
    local setup_dir=$(grep -Po '%setup.*-n[[:space:]]+[^[:space:]]+' "$OPT_SPEC")
    # if setup_dir has '/' return the part after it
    setup_dir=${setup_dir/#*\//}
    # if it did not have a '/' then we got the original match => erase it
    setup_dir=${setup_dir/#%setup*/}

    if [[ -n "$setup_dir" ]]; then
        # in case we got a spec %{tag} out of this, try to expand it
        setup_dir=$(get_spec_tag "$setup_dir")
        is_shadow_build && mkdir -p "$setup_dir"
        cd "$setup_dir"
    fi
}

# handle release tags with format "x" or "x.y", where x and y are
# numbers, leave others untouched
#  get tag
#  check if it has x.y
#  if it is x.y get y and check if y is number
#  if y is number => increment
#  if it only is x check if x is number
#  if x is number => increment
#  else leave untouched
increment_build_number() {
    [[ $OPT_INC_BUILD_NUMBER -eq 0 ]] && return

    local release=$(get_spec_tag "%{release}")
    local x=$(echo $release | cut -f 1 -d .)
    local y=$(echo $release | cut -s -f 2 -d .)
    local z=$(echo $release | cut -s -f 3- -d .)

    # more than one dot found => don't touch
    [[ -n "$z" ]] && return

    if [[ -n "$y" ]]; then
        if [[ $y =~ ^-?[0-9]+$ ]]; then
            let new_release=$y+1
            echo "Incrementing release: $x.$y -> $x.$new_release"
            sed -i "s/^Release:.*/Release: $x.$new_release/" "$OPT_SPEC"
            return
        else
            # non-numeric after dot => don't touch
            return
        fi
    fi

    if [[ -n "$x" ]]; then
        if [[ $x =~ ^-?[0-9]+$ ]]; then
            let new_release=$x+1
            echo "Incrementing release: $x -> $new_release"
            sed -i "s/^Release:.*/Release: $new_release/" "$OPT_SPEC"
            return
        fi
    fi
}

quote() {
    [[ $# -gt 0 ]] && printf "%q " "$@" |sed 's/ $//'
}

rpm_quote() {
    quote "$@" |sed 's/\\/&&/g'
}

init_wrappers_dir() {
    [[ -e $STATEDIR/wrappers ]] && return

    # The working directory inside build engine is noexec
    if inside_build_engine; then
        mkdir -p ~/.mb2
        local real=$(mktemp -d ~/.mb2/wrappers.XXXX) || return
        ln -s --no-target-dir "$real" "$STATEDIR/wrappers" || return
    else
        mkdir -p "$STATEDIR/wrappers" || return
    fi
}

remove_wrappers_dir() {
    if inside_build_engine; then
        rm -rf "$(readlink -f "$STATEDIR/wrappers")"
        rm -f "$STATEDIR/wrappers"
    else
        rm -rf "$STATEDIR/wrappers"
    fi
}

# 1. Allows to pass extra arguments to qmake
# 2. Enables shadow build by adding path prefix to the project file, or
# 2.1 passing project directory path if the project file was not passed
init_qmake_wrapper() (
    local wrapper=$1
    local extra_args=("${@:2}")

    main() {
        self=${0#$PWD/}
        command=${0##*/}

        path=${0%/*}
        PATH=${PATH/$path:/}

        real=$(which "$command")
        if [[ ! $real || $real == "$0" ]]; then
            echo "$self: Cannot find real $command" >&2
            exit 1
        fi

        if [[ $IS_SHADOW_BUILD ]]; then
            subdir=${PWD#$BUILD_DIR}
            src_dir=$SRC_DIR${subdir:+/$subdir}
            args=()
            pro_passed=
            for arg in "$@"; do
                if [[ $arg == *.pro && -f $src_dir/$arg ]]; then
                    args+=("$src_dir/$arg")
                    pro_passed=1
                else
                    args+=("$arg")
                fi
            done
            if [[ ! $pro_passed ]]; then
                args+=("$src_dir")
            fi
            set -- "${args[@]}"
        fi

        echo "$self: Executing real $command:" >&2

        set -x
        "$real" "$@"
    }

    init_wrappers_dir
    cat <<END >"$wrapper"
#!/bin/bash

IS_SHADOW_BUILD=$(is_shadow_build && echo 1)
BUILD_DIR=$(quote "$PWD")
SRC_DIR=$(quote "${OPT_SRC_DIR:-$PWD}")

$(declare -f main)

main "\$@" $(quote "${extra_args[@]}")
END
    chmod +x "$wrapper"
)

init_simple_wrapper() {
    local wrapper=$1
    local extra_args=("${@:2}")

    init_wrappers_dir
    {
        cat <<'END'
#!/bin/bash
self=${0#$PWD/}
command=${0##*/}
NBSP=$'\xC2\xA0'

path=${0%/*}
PATH=${PATH/$path:/}

real=$(which "$command")
if [[ ! $real || $real == "$0" ]]; then
    echo "$self: Cannot find real $command" >&2
    exit 1
fi

# NBSP used to prevent Qt Creator treating this as an error when issued for 'make'
echo "$self:${NBSP}Executing real $command:" >&2

set -x

"$real" "$@" \
END
        quote "${extra_args[@]}"
        echo
    } >"$wrapper"
    chmod +x "$wrapper"
}

init_noop_wrapper() {
    local wrapper=$1

    init_wrappers_dir
    cat <<'END' >"$wrapper"
#!/bin/bash
self=${0#$PWD/}
command=${0##*/}
echo "$self: Ignoring $command" >&2
END
    chmod +x "$wrapper"
}

run_installdeps() {
    # Refresh repos before installing dependencies
    sb2 -t "$target" -m sdk-install -R zypper --non-interactive ref
    verify_target_dependencies
}

run_apply() (
    rpm_dir="$(dirname "$OPT_SPEC")"
    cd_to_spec_setup_dir
    reverse="cat"
    if [ "$APPLY_REVERSE" -eq 1 ]; then
        reverse="tac"
    fi
    for p in $(sed -e '/^%patch/!d' -e 's/^%patch\([0-9]*\).*/\1/' "$OPT_SPEC" | $reverse); do
        op="$(grep "^%patch${p}" "$OPT_SPEC" | awk '{print $2}')"
        patch_file="$(grep "^Patch$p:" "$OPT_SPEC" | awk '{print $2}')"
        if [ "$APPLY_REVERSE" -eq 1 ]; then
            echo "Reversing $patch_file" >&2
            patch -R $op < "$rpm_dir/$patch_file" >&2
        else
            echo "Applying $patch_file" >&2
            patch $op < "$rpm_dir/$patch_file" >&2
        fi
    done
)

run_build() {
    # intended to provide mb build behaviour
    verify_target_dependencies

    increment_build_number;
    local tmp_spec="$OPT_SPEC.$$"
    if [[ $BUILD_NOPREP ]]; then
        sed -e '/^%patch/d' "$OPT_SPEC" > "$tmp_spec"
    else
        cp "$OPT_SPEC" "$tmp_spec"
    fi

    try_to_make_changelog >> "$tmp_spec"

    # get rid of potential windows linefeeds
    sed -i "s/\x0D$//g" "$tmp_spec"

    fix_package_version "$tmp_spec"

    local build_tgt=$(sb2 -t $OPT_TARGET gcc -dumpmachine)
    build_tgt=${build_tgt%-gnueabi}

    if is_shadow_build; then
        init_qmake_wrapper $STATEDIR/wrappers/qmake
    fi

    (
        cd_to_spec_setup_dir;
        [[ $OPT_CLEAN_OUTPUTDIR ]] && rm -f "$OPT_OUTPUTDIR/"*.rpm;
        sb2 -t $OPT_TARGET env PATH="$STATEDIR/wrappers:$PATH" rpmbuild \
            --build-in-place --target=$build_tgt \
            "${BUILD_DEBUG[@]}" \
            --define "_smp_mflags -j$(rpm_quote "$BUILD_JOBS")" \
            --define "_rpmdir $OPT_OUTPUTDIR" \
            --define "_sourcedir $(dirname $OPT_SPEC)" \
            --define "_rpmfilename %%{name}-%%{version}-%%{release}.%%{arch}.rpm" \
            --buildroot="$buildroot" \
            "${BUILD_NOPREP[@]}" \
            -bb \
            "$tmp_spec" \
            "$@"
    )
    local rc=$?
    rm -f "$tmp_spec"
    return $rc
}

run_prep() {
    verify_target_dependencies

    increment_build_number;
    local tmp_spec="$OPT_SPEC.$$"
    # TODO maybe add toggle here for disabling patch applying?
    cp "$OPT_SPEC" "$tmp_spec"

    # get rid of potential windows linefeeds
    sed -i "s/\x0D$//g" "$tmp_spec"

    fix_package_version "$tmp_spec"

    local build_tgt=$(sb2 -t $OPT_TARGET gcc -dumpmachine)
    build_tgt=${build_tgt%-gnueabi}
    (
        cd_to_spec_setup_dir;
        [[ $OPT_CLEAN_OUTPUTDIR ]] && rm -f "$OPT_OUTPUTDIR/"*.rpm;
        sb2 -t $OPT_TARGET rpmbuild --build-in-place --target=$build_tgt \
            "${BUILD_DEBUG[@]}" \
            --define "_smp_mflags -j$BUILD_JOBS" \
            --define "_rpmdir $OPT_OUTPUTDIR" \
            --define "_sourcedir $(dirname $OPT_SPEC)" \
            --define "_rpmfilename %%{name}-%%{version}-%%{release}.%%{arch}.rpm" \
            --buildroot="$buildroot" \
            -bp --short-circuit \
            "$tmp_spec"
    )
    local rc=$?
    rm -f "$tmp_spec"
    return $rc
}

run_qmake() {
    if [[ "$OPT_SPEC" ]]; then
        local build_tgt=$(sb2 -t $OPT_TARGET gcc -dumpmachine)
        build_tgt=${build_tgt%-gnueabi}

        local tmp_spec="$OPT_SPEC.$$"
        cp -a "$OPT_SPEC" "$tmp_spec"

        # get rid of potential windows linefeeds
        sed -i "s/\x0D$//g" "$tmp_spec"

        fix_package_version "$tmp_spec"

        # This is a good time to verify the target dependencies as per mb
        verify_target_dependencies

        init_qmake_wrapper $STATEDIR/wrappers/qmake "$@"
        init_noop_wrapper $STATEDIR/wrappers/make

        (
            cd_to_spec_setup_dir;
            sb2 -t $OPT_TARGET env PATH="$STATEDIR/wrappers:$PATH" rpmbuild \
                --build-in-place --target=$build_tgt \
                --define "noecho 1" \
                --define "_sourcedir $(dirname $OPT_SPEC)" \
                -bc --short-circuit \
                "$tmp_spec"
        )
        local rc=$?
        rm -f "$tmp_spec"
        return $rc
    else
        sb2 -t $OPT_TARGET qmake "$@" ${OPT_PRO_FILE_OR_DIR:+"$OPT_PRO_FILE_OR_DIR"}
    fi
}

run_make() {
    if [[ "$OPT_SPEC" ]]; then

        local tmp_spec="$OPT_SPEC.$$"
        cp -a "$OPT_SPEC" "$tmp_spec"

        # get rid of potential windows linefeeds
        sed -i "s/\x0D$//g" "$tmp_spec"

        fix_package_version "$tmp_spec"

        local build_tgt=$(sb2 -t $OPT_TARGET gcc -dumpmachine)
        build_tgt=${build_tgt%-gnueabi}

        init_noop_wrapper $STATEDIR/wrappers/qmake
        init_simple_wrapper $STATEDIR/wrappers/make "$@"

        (
            cd_to_spec_setup_dir;
            sb2 -t $OPT_TARGET env PATH="$STATEDIR/wrappers:$PATH" rpmbuild \
                --build-in-place --target=$build_tgt \
                --define "noecho 1" \
                --define "_sourcedir $(dirname $OPT_SPEC)" \
                -bc --short-circuit \
                "$tmp_spec"
        )
        local rc=$?
        rm -f "$tmp_spec"
        return $rc
    else
        sb2 -t $OPT_TARGET make "$@"
    fi
}

run_install() {
    local build_tgt=$(sb2 -t $OPT_TARGET gcc -dumpmachine)
    build_tgt=${build_tgt%-gnueabi}

    local tmp_spec="$OPT_SPEC.$$"
    cp -a "$OPT_SPEC" "$tmp_spec"

    # get rid of potential windows linefeeds
    sed -i "s/\x0D$//g" "$tmp_spec"

    fix_package_version "$tmp_spec"

    # Install to buildroot which should be rsync'ed to /opt/sdk/$package on device
    (
        cd_to_spec_setup_dir;
        sb2 -t $OPT_TARGET rpmbuild --build-in-place --target=$build_tgt \
            --define "noecho 1" \
            --define "_sourcedir $(dirname $OPT_SPEC)" \
            --define "_skip_install_processing 1" \
            --buildroot="$buildroot" \
            -bi --short-circuit --nocheck \
            "$tmp_spec"
    )
    local rc=$?
    rm -f "$tmp_spec"
    return $rc
}

run_rpm() {
    local build_tgt=$(sb2 -t $OPT_TARGET gcc -dumpmachine)
    build_tgt=${build_tgt%-gnueabi}

    local tmp_spec="$OPT_SPEC.$$"
    cp -a "$OPT_SPEC" "$tmp_spec"

    try_to_make_changelog >> "$tmp_spec"

    # get rid of potential windows linefeeds
    sed -i "s/\x0D$//g" "$tmp_spec"

    fix_package_version "$tmp_spec"

    (
        increment_build_number;
        cd_to_spec_setup_dir;
        [[ $OPT_CLEAN_OUTPUTDIR ]] && rm -f "$OPT_OUTPUTDIR/"*.rpm;
        sb2 -t $OPT_TARGET rpmbuild --build-in-place --target=$build_tgt \
            --define "noecho 1" \
            --define "_rpmdir $OPT_OUTPUTDIR" \
            --define "_sourcedir $(dirname $OPT_SPEC)" \
            --define "_rpmfilename %%{name}-%%{version}-%%{release}.%%{arch}.rpm" \
            --buildroot="$buildroot" \
            -bb --noprep --nobuildstage --noclean \
            "$tmp_spec"
    )
    local rc=$?
    rm -f "$tmp_spec"
    return $rc
}

run_deploy() {
    [[ "$device_type" ]] || fatal "deploy must have a valid --device"
    local fail_text="deploy must use one of --pkcon, --rsync , --sdk or --zypper"
    [[ -z ${1:-} ]] && fatal $fail_text

    local retcode=0

    while [[ $1 ]]; do
        case "$1" in
            "--sdk" | "--pkcon" )
                local method;
                if [[ "$1" == "--sdk" ]]; then
                    method="sdk-deploy-rpm"
                else
                    method="pkcon --plain --noninteractive install-local"
                fi
                shift
                run_rpm
                [[ $? -ne 0 ]] && return 1
                rpms=$(find $OPT_OUTPUTDIR -name '*.rpm' -a ! -name '*-debug*.rpm')
                rsync_as $deviceuser -av ${rpms} $device_ip:/home/$deviceuser/RPMS/
                [[ $? -ne 0 ]] && return 1
                device_rpms=$(sed "s,^$OPT_OUTPUTDIR/,RPMS/," <<<"$rpms")
                ssh_as $deviceuser $method ${device_rpms}
                retcode=$?
                ssh_as $deviceuser rm -f ${device_rpms}
                ;;
            "--zypper" ) shift
                run_rpm
                [[ $? -ne 0 ]] && return 1
                rpms=$(find $OPT_OUTPUTDIR -name '*.rpm' -a ! -name '*-debug*.rpm')
                rsync_as root -av ${rpms} $device_ip:/root/RPMS/
                [[ $? -ne 0 ]] && return 1
                device_rpms=$(sed "s,^$OPT_OUTPUTDIR/,RPMS/," <<<"$rpms")
                ssh_as root zypper --non-interactive --quiet in -f ${device_rpms}
                retcode=$?
                ssh_as root rm -f ${device_rpms}
                ;;
            "--rsync" ) shift
                run_install
                [[ $? -ne 0 ]] && return 1
                name=$(get_spec_tag "%{name}")
                rsync_as $deviceuser -av ${buildroot}/. $device_ip:/opt/sdk/$name
                retcode=$?
                ;;
            *)
                fatal $fail_text ;;
        esac
    done

    [[ $retcode -eq 0 ]] || { echo "Deploy failed"; return 1; }
}

get_shared_dir() {
    echo "$OPT_SHARED_DIR"
}

inside_build_engine() [[ -f /etc/mer-sdk-vbox ]]
inside_git_worktree() { git_ status &>/dev/null; }

# this is same as basename $0
ME=${0/#*\//}

# option variables
OPT_SPEC=
OPT_TARGET=
OPT_DEVICE=
OPT_OUTPUTDIR=$(readlink -f ./RPMS)
OPT_CLEAN_OUTPUTDIR=1
OPT_PKGDIR="./rpm"
OPT_PRO_FILE_OR_DIR=
OPT_SRC_DIR=
OPT_NEEDSPEC=
OPT_FIX_VERSION=
OPT_FIX_VERSION_HINT=
OPT_NO_FIX_VERSION=
OPT_GIT_CHANGE_LOG=
OPT_GIT_CHANGE_LOG_ARGS=
OPT_SHARED_DIR=/etc/mersdk/share
OPT_INC_BUILD_NUMBER=0
OPT_NO_DEPS=
deviceuser=nemo

STATEDIR=$PWD/.mb2

# Virtualbox environment will install in this hardcoded location
if inside_build_engine; then
    buildroot=/home/deploy/installroot
else
    buildroot="$PWD/installroot"
fi

################################################################################
if [[ $1 != --self-test ]]; then  ###  M A I N  EXECUTION BEGINS HERE  #########
################################################################################

# The project-dir-or-file command line option serves just one purpose: to locate the source tree
# when doing a shadow build.  Including the file name is optional and takes no effect. If multiple
# .pro files exist in the directory, the selection is done inside the .spec file, mentioning one on
# qmake command line.
#
# An exception applies if there is no .spec file. In this case the qmake and make commands behave as
# plain qmake/make invocations, just wrapped with sb2, and the project-dir-or-file option is
# forwarded to qmake without modifications.
#
# If this is called with an empty argument, the default settings is restored.
handle_pro_file_or_dir_option() {
    local pro_file_or_dir=$1

    mkdir -p "$STATEDIR"
    rm -f "$STATEDIR/src"

    if [[ ! $pro_file_or_dir ]]; then
        return
    fi

    local pro_dir=
    if [[ -d $pro_file_or_dir ]]; then
        pro_dir=$(readlink -f "$pro_file_or_dir")
    else
        pro_dir=$(dirname "$(readlink -f "$pro_file_or_dir")")
    fi

    local src_dir=
    local dir=$pro_dir
    while true; do
        if [[ -d $dir/rpm && $(find "$dir/rpm" -maxdepth 1 -name '*.spec' -o -name '*.yaml') ]]; then
            src_dir=$dir
            break
        fi
        # Skip any "rpm" ancestor in path to avoid misintepreting it as THE rpm directory
        while [[ $(basename "$dir") == rpm ]]; do
            dir=$(dirname "$dir")
        done
        dir=$(dirname "$dir")
        # For in-place builds do not search above the CWD, for shadow builds do not search above
        # common prefix
        if [[ $(readlink -f "$PWD") == "$dir"/* ]]; then
            break
        fi
    done

    # Silently fall back to the directory where the project file resides - some commands can be used
    # without spec file
    : ${src_dir:=$pro_dir}

    # Remember that for the plain qmake/make usage
    OPT_PRO_FILE_OR_DIR=$pro_file_or_dir

    # The project file/directory might be specified explicitly for non-shadow builds as well
    if [[ $src_dir != "$(readlink -f "$PWD")" ]]; then
        ln -sfn "$src_dir" "$STATEDIR/src"
    fi
}

maybe_restore_shadow_build() {
    if [[ -L $STATEDIR/src ]]; then
        OPT_SRC_DIR=$(readlink -f "$STATEDIR/src")
        OPT_PKGDIR=$OPT_SRC_DIR/rpm
    fi
}

is_shadow_build() [[ -e $STATEDIR/src ]]

pro_file_or_dir=

while [[ "$1" ]]; do
    # only set variables in this loop
    case "$1" in
        "-t" | "--target") shift
            OPT_TARGET="$1"; shift
            ;;
        "-f" | "--shared-folder") shift
            OPT_SHARED_DIR="$1"; shift
            ;;
        "-d" | "--device") shift
            OPT_DEVICE="$1"; shift
            ;;
        "-o" | "--outputdir") shift
            OPT_OUTPUTDIR="$1"; shift
            [[ -d "$OPT_OUTPUTDIR" ]] || fatal "'$OPT_OUTPUTDIR' is not a directory"
            OPT_CLEAN_OUTPUTDIR=
            ;;
        "-p" | "--projectdir")
            notice "The '$1' option is deprecated. Try '$ME --help' for more information."
            [[ -d "$2" ]] || fatal "'$2' is not a directory"
            pro_file_or_dir="$2"
            shift 2
            ;;
        "-s" | "--specfile" ) shift
            OPT_SPEC="$1"; shift
            ;;
        "-i" | "--increment" ) shift
            OPT_INC_BUILD_NUMBER=1
            ;;
        "-P" | "--pedantic" )
            notice "The '$1' option is deprecated and does nothing currently"
            shift
            ;;
        "-x" | "--fix-version" ) shift
            OPT_FIX_VERSION=1
            OPT_FIX_VERSION_HINT=
            OPT_NO_FIX_VERSION=
            ;;
        "-x="* | "--fix-version="* )
            OPT_FIX_VERSION=1
            OPT_FIX_VERSION_HINT=${1#*=}
            OPT_NO_FIX_VERSION=
            shift
            ;;
        "-X" | "--no-fix-version" ) shift
            OPT_FIX_VERSION=
            OPT_FIX_VERSION_HINT=
            OPT_NO_FIX_VERSION=1
            ;;
        "-n" | "--no-deps") shift
            OPT_NO_DEPS=1
            ;;
        "-c" | "--git-change-log" ) shift
            OPT_GIT_CHANGE_LOG=1
            ;;
        "-c="* | "--git-change-log="* )
            OPT_GIT_CHANGE_LOG=1
            OPT_GIT_CHANGE_LOG_ARGS="${1#*=}"
            shift
            ;;
        "-m" | "--submodule" )
            notice "The '$1' option is deprecated and does nothing currently"
            shift 2
            ;;
        install | rpm | deploy | build | installdeps | apply | prep )
            OPT_NEEDSPEC=1;
            break
            ;;
        qmake | make | run | ssh )
            break
            ;;
        --version )
            echo "$ME, version VERSION_FROM_SPEC"
            exit 0
            ;;
        --help )
            usage
            exit 0
            ;;
        *)
            short_usage quit
            ;;
    esac
done

if [[ -n "$OPT_SPEC" ]]; then
    try_to_make_spec "$OPT_SPEC"
    [[ -f "$OPT_SPEC" ]] || fatal "'$OPT_SPEC' doesn't exist (and could not be made from a yaml)"
fi

if [[ -n "$OPT_DEVICE" ]]; then
    [[ -f $(get_shared_dir)/devices.xml ]] || fatal "Unable to open $(get_shared_dir)/devices.xml"
    get_device "$OPT_DEVICE" < $(get_shared_dir)/devices.xml || fatal "'$OPT_DEVICE' not found in devices.xml"
fi

if [[ ! "$OPT_TARGET" ]]; then
    if [[ -f ~/.scratchbox2/config ]]; then
        . ~/.scratchbox2/config
        OPT_TARGET=$DEFAULT_TARGET
    fi
    [[ "$OPT_TARGET" ]] || fatal "You must specify an sb2 target or have a default configured"
fi

[[ -d ~/.scratchbox2/$OPT_TARGET ]] || fatal "$OPT_TARGET is an invalid sb2 target"

if [[ $OPT_FIX_VERSION_HINT && ! $(git_ tag --list "$OPT_FIX_VERSION_HINT") ]]; then
    fatal "'$OPT_FIX_VERSION_HINT' no such Git tag"
fi

case "$1" in
    make | install | installdeps | rpm | deploy | prep )
        cmd=run_$1
        shift
        ;;
    apply )
        cmd=run_$1; shift
        APPLY_REVERSE=0
        while [[ "$1" ]]; do
            case "$1" in
                -R) shift
                    APPLY_REVERSE=1 ;;
                *)
                    short_usage quit
                    ;;
            esac
        done
        ;;
    qmake )
        cmd=run_$1; shift
        while [[ "$1" ]]; do
            case "$1" in
                --) shift
                    break
                    ;;
                *)
                    if [[ -e $1 ]]; then
                        pro_file_or_dir="$1"
                        shift
                    fi
                    break
                    ;;
            esac
        done
        handle_pro_file_or_dir_option "$pro_file_or_dir"
        ;;
    build )
        cmd=run_$1; shift
        BUILD_DEBUG=(--define "debug_package %{nil}")
        BUILD_JOBS=
        BUILD_NOPREP=(--noprep)
        while [[ "$1" ]]; do
            case "$1" in
                -d|--enable-debug) shift
                    BUILD_DEBUG=() ;;
                -j*)
                    # support giving -j with and without space between
                    # it and the 'n'
                    if [[ ${#1} -gt 2 ]]; then
                        BUILD_JOBS=${1:2}; shift
                    else
                        [[ -z "$2" ]] && short_usage quit
                        BUILD_JOBS="$2"; shift 2;
                    fi
                    ;;
                -p|--doprep) shift
                    BUILD_NOPREP=()
                    ;;
                --) shift
                    break
                    ;;
                *)
                    if [[ -e $1 ]]; then
                        pro_file_or_dir="$1"
                        shift
                    fi
                    break
                    ;;
            esac
        done
        handle_pro_file_or_dir_option "$pro_file_or_dir"
        [[ $BUILD_JOBS ]] || BUILD_JOBS=$(getconf _NPROCESSORS_ONLN)
        ;;
    run | ssh )
        if [[ $1 == ssh ]]; then
            notice "The 'ssh' command is deprecated. Use 'run' instead."
        fi
        shift
        if [[ "$OPT_DEVICE" ]]; then
            cmd="ssh_as $deviceuser"
        else
            cmd=""
        fi
        ;;
    *)
        short_usage quit
        ;;
esac

maybe_restore_shadow_build

# spec rules are complex:
#  a .spec is required for some but not all operations
#  if -s is given then
#    if it does not exist then specify tries to make it
#    if it exists it will be used
#  if there is a rpm/*.spec then that is used
#  if there is a rpm/*.yaml then a spec is made and used

if [[ ! "$OPT_SPEC" ]]; then
    # set nullglob on so that the shell glob expansions will return
    # empty if files are not found
    shopt -s nullglob
    spec_files=("$OPT_PKGDIR"/*.spec)
    numspec=${#spec_files[@]}
    if [[ $numspec -gt 1 ]]; then
        [[ $OPT_NEEDSPEC ]] && fatal "Too many spec files - please use -s to identify which one to use"
        echo "Too many spec files - not using any. Use -s to identify a specific one"
        # OPT_SPEC is not set
    fi

    if [[ $numspec -eq 0 ]]; then
        # No spec, try to find a yaml
        yaml_files=("$OPT_PKGDIR"/*.yaml)
        numyaml=${#yaml_files[@]}
        if [[ $numyaml -eq 1 ]]; then
            theyaml=("$OPT_PKGDIR"/*.yaml)
            try_to_make_spec_from_yaml "${theyaml[0]}"
            spec_files=("$OPT_PKGDIR"/*.spec)
            numspec=${#spec_files[@]}
        else
            [[ $OPT_NEEDSPEC ]] && fatal "No spec file found in '$OPT_PKGDIR/' and couldn't make one from a yaml #1"
        fi
    fi

    if [[ $numspec -eq 1 ]]; then
        thespec=("$OPT_PKGDIR"/*.spec)
        OPT_SPEC="${thespec[0]}"
    else
        # this is because we did try_to_make_spec_from_yaml and failed
        [[ $OPT_NEEDSPEC ]] && fatal "No spec file found in '$OPT_PKGDIR/' and couldn't make one from a yaml #2"
    fi

    # unset nullglob so that any further globbing works normally
    shopt -u nullglob
fi

# Now if there is a spec given, make sure it is up-to-date
if [[ "$OPT_SPEC" ]]; then
    # turn 'OPT_SPEC' into an absolute path
    OPT_SPEC=$(readlink -f "$OPT_SPEC")
    ensure_spec_newer_than_yaml
fi

remove_wrappers_dir

$cmd "$@"

##############################################################################
exit; fi ###  S E L F - T E S T  EXECUTION BEGINS HERE #######################
##############################################################################

set -o nounset

SELF=$(readlink -f "$0")

: ${MB2_SELF_TEST_VERBOSE:=}
: ${MB2_SELF_TEST_TS:=}

temp=$(mktemp -d) || exit
trap "rm -rf '$temp'" EXIT
cd "$temp" || exit

mkdir stubs || exit
STUBS_DIR=$(readlink -f stubs)
export PATH="$STUBS_DIR:$PATH"

if ! which make >/dev/null; then
    fatal "Please install 'make' and try again"
fi

################################################################################
# Test utils

tc_num=0
tc_failed_num=0

set_up_ts() {
    local ts=$1
    TS_NAME=$2

    if [[ $MB2_SELF_TEST_TS && $TS_NAME != "$MB2_SELF_TEST_TS" ]]; then
        return
    fi

    ${ts}_ts_set_up "${@:3}"
    if [[ $? -ne 0 ]]; then
        fatal "Test suite set-up failed: $ts"
    fi
}

tear_down_ts() {
    local ts=$1

    if [[ $MB2_SELF_TEST_TS && $TS_NAME != "$MB2_SELF_TEST_TS" ]]; then
        return
    fi

    ${ts}_ts_tear_down
    if [[ $? -ne 0 ]]; then
        fatal "Test suite tear-down failed: $ts"
    fi
    TS_NAME=
}

KNOWN_ISSUES=()
KNOWN_ISSUE() {
    KNOWN_ISSUES=(${KNOWN_ISSUES[@]:+"${KNOWN_ISSUES[@]}"} "$1")
}

run_tc() {
    local tc=$1
    TC_NAME=$2
    local args=("${@:3}")

    if [[ $MB2_SELF_TEST_TS && ${TS_NAME:-} != "$MB2_SELF_TEST_TS" ]]; then
        KNOWN_ISSUES=()
        return
    fi

    let tc_num++
    echo "*** Executing test case: ${TS_NAME:+$TS_NAME - }$TC_NAME"

    local known_issue
    for known_issue in ${KNOWN_ISSUES[@]:+"${KNOWN_ISSUES[@]}"}; do
        echo "    Known issue: $known_issue"
    done
    KNOWN_ISSUES=()

    local stderr=
    { stderr=$(${tc}_tc ${args[@]:+"${args[@]}"} 3>&1 1>&2 2>&3 3>&-); } 2>&1
    local rc=$?

    if [[ $rc -ne 0 ]]; then
        let tc_failed_num++
    fi

    if [[ $rc -ne 0 || $MB2_SELF_TEST_VERBOSE ]]; then
        cat <<END
  ** Stderr     ** [[
$stderr
]]
END
    fi

    if [[ $(type -t ${tc}_tc_tear_down) == function ]]; then
        ${tc}_tc_tear_down
        if [[ $? -ne 0 ]]; then
            fatal "Test case tear-down failed: $tc"
        fi
    fi

    return $rc
}

arg_pass_stub_create() {
    while [[ ${1:-} ]]; do
        local stub=$STUBS_DIR/$1
        local results=$STUBS_DIR/$1.args

        touch "$results" || return
        cat >"$stub" <<END || return
#!/bin/bash
echo "stub invoked: \$0 \$(printf "%q " "\$@")" >&2
{ [[ \$# -ne 0 ]] && printf "%q\\n" "\$@"; } >"$results"
exit 0
END
        chmod +x "$stub" || return
        shift
    done
}

arg_pass_stub_remove() {
    while [[ ${1:-} ]]; do
        local stub=$STUBS_DIR/$1
        local results=$STUBS_DIR/$1.args
        rm -f "$stub" || return
        rm -f "$results" || return
        shift
    done
}

arg_pass_stub_results() {
    local results=$STUBS_DIR/$1.args
    [[ -e $results ]] && cat "$results"
}

arg_pass_stub_clear() {
    while [[ ${1:-} ]]; do
        local results=$STUBS_DIR/$1.args
        rm -f "$results" || return
        shift
    done
}

expect_args() {
    [[ $# -ne 0 ]] && printf "%q\n" "$@" || true
}

sb2_stub() {
    echo "stub invoked: $0 $(printf "%q " "$@")" >&2

    local args=("$@")
    bad_args() {
        echo "stub $0: unexpected arguments: $(printf "%q " "${args[@]}")" >&2
    }

    if ! [[ $1 == -t && $3 != -* ]]; then
        bad_args
        return 1
    fi

    shift 2

    env=(env)
    if [[ $1 == env ]]; then
        shift
        while [[ $1 == -* || $1 =~ ^[[:alnum:]_]+= ]]; do
            env+=("$1")
            shift
        done
    fi

    case $1 in
        gcc)
            case $2 in
                -dumpmachine)
                    echo "i486-meego-linux"
                    ;;
                *)
                    bad_args
                    return 1
                    ;;
            esac
            ;;
        rpmbuild)
            # rpmbuild writes some progress messages to stdout
            exec "${env[@]}" "$@" >&2
            ;;
        rpmspec)
            exec "${env[@]}" "$@"
            ;;
        *)
            bad_args
            return 1
            ;;
    esac
}

sb2_stub_create() {
    cat >"$STUBS_DIR/sb2" <<END || return
#!/bin/bash
$(declare -f sb2_stub)
sb2_stub "\$@"
END
    chmod +x "$STUBS_DIR/sb2" || return
}

sb2_stub_remove() {
    rm -f "$STUBS_DIR/sb2" || return
}

DEFAULT_TARGET=$(. ~/.scratchbox2/config; echo "$DEFAULT_TARGET")
DEFAULT_JOBS=$(getconf _NPROCESSORS_ONLN)

if inside_build_engine; then
    DEFAULT_DEVICE="Sailfish OS Emulator"
else
    echo "Note: Skipping test cases involving device connection - not inside a Sailfish OS build engine" >&2
    DEFAULT_DEVICE=
fi

################################################################################
# Test the rpm_quote function

rpm_quote_tc() {
    arg_pass_stub_create make || return

    # Create an minimal spec file
    mkdir rpm || return
    cat >rpm/test.spec <<END || return
Name: test
Version: 1.0
Release: 0
Summary: Test
License: BSD

# This would normally come from the environment
%{!?make:%define make make}

%description
Test

%build
%make "x  y"
END

    rpmbuild -bc --short-circuit --noprep --build-in-place --define "_sourcedir $(readlink -f rpm)" rpm/test.spec \
        --define "make make $(rpm_quote "a b" "c  d" e f)" >&2 || return
    local rc=0 expected= actual= diff=
    expected=$(expect_args "a b" "c  d" e f "x  y")
    actual=$(arg_pass_stub_results make) || return
    if ! diff=$(diff <(cat <<<"$expected") <(cat <<<"$actual")); then
        rc=1
        cat <<END
Test case failed: $TC_NAME
  ** Mismatch   ** [[
$diff
]]
  ** Expected   ** [[
$expected
]]
  ** Actual     ** [[
$actual
]]
END
    fi

    arg_pass_stub_remove make || return
    rm -f rpm/test.spec || return
    rmdir rpm || return

    return $rc
}

run_tc rpm_quote "Test RPM macro escaping"

################################################################################
# Test sb2 argument passing

sb2_arg_pass_ts_set_up() {
    arg_pass_stub_create sb2 || return

    # Create an empty spec file
    mkdir rpm || return
    : >rpm/test.spec || return
}

sb2_arg_pass_ts_tear_down() {
    arg_pass_stub_remove sb2 || return
    rm -f rpm/test.spec || return
    rmdir rpm || return
}

sb2_arg_pass_tc() {
    local expected=$1
    local args=("${@:2}")

    arg_pass_stub_clear sb2 || return
    "$SELF" "${args[@]}" || return
    local actual_raw= actual= diff=
    actual_raw=$(arg_pass_stub_results sb2) || return
    actual=$(sed -e 's,/tmp\.[^/]\+,/@TMPDIR@,' \
                 -e "s,/home/deploy,/tmp/@TMPDIR@," \
                 -e 's,/test\.spec\.[^/]\+,/@TEST_SPEC@,' <<<"$actual_raw")
    if ! diff=$(diff <(cat <<<"$expected") <(cat <<<"$actual")); then
        cat <<END
Test case failed: $TC_NAME
  ** Command    ** $ME $(quote "${args[@]}")
  ** Mismatch   ** [[
$diff
]]
  ** Expected   ** [[
$expected
]]
  ** Actual     ** [[
$actual
]]
  ** Actual RAW ** [[
$actual_raw
]]
END
        return 1
    fi
}

set_up_ts sb2_arg_pass "Passing arguments to sb2"

KNOWN_ISSUE "Does not disable debug by default (ignores --enable-debug)"
KNOWN_ISSUE "Passes -j without argument"
KNOWN_ISSUE "Silently ignores extra arguments"
run_tc sb2_arg_pass "prep" \
    "$(expect_args \
        -t "$DEFAULT_TARGET" rpmbuild --build-in-place --target= \
        --define '_smp_mflags -j' \
        --define '_rpmdir /tmp/@TMPDIR@/RPMS' \
        --define '_sourcedir /tmp/@TMPDIR@/rpm' \
        --define '_rpmfilename %%{name}-%%{version}-%%{release}.%%{arch}.rpm' \
        --buildroot=/tmp/@TMPDIR@/installroot \
        -bp --short-circuit \
        /tmp/@TMPDIR@/rpm/@TEST_SPEC@)" \
    prep "a b" "c  d" e f

run_tc sb2_arg_pass "build" \
    "$(expect_args \
        -t "$DEFAULT_TARGET" env PATH="/tmp/@TMPDIR@/.mb2/wrappers:$PATH" rpmbuild \
        --build-in-place --target= \
        --define 'debug_package %{nil}' \
        --define "_smp_mflags -j$(rpm_quote "bad  1")" \
        --define '_rpmdir /tmp/@TMPDIR@/RPMS' \
        --define '_sourcedir /tmp/@TMPDIR@/rpm' \
        --define '_rpmfilename %%{name}-%%{version}-%%{release}.%%{arch}.rpm' \
        --buildroot=/tmp/@TMPDIR@/installroot \
        -bb \
        /tmp/@TMPDIR@/rpm/@TEST_SPEC@ \
        "a b" "c  d" e f)" \
    build --doprep -j "bad  1" "a b" "c  d" e f

run_tc sb2_arg_pass "build with debug" \
    "$(expect_args \
        -t "$DEFAULT_TARGET" env PATH="/tmp/@TMPDIR@/.mb2/wrappers:$PATH" rpmbuild \
        --build-in-place --target= \
        --define "_smp_mflags -j$(rpm_quote "bad  1")" \
        --define '_rpmdir /tmp/@TMPDIR@/RPMS' \
        --define '_sourcedir /tmp/@TMPDIR@/rpm' \
        --define '_rpmfilename %%{name}-%%{version}-%%{release}.%%{arch}.rpm' \
        --buildroot=/tmp/@TMPDIR@/installroot \
        -bb \
        /tmp/@TMPDIR@/rpm/@TEST_SPEC@ \
        "a b" "c  d" e f)" \
    build --doprep --enable-debug -j "bad  1" "a b" "c  d" e f

run_tc sb2_arg_pass "qmake" \
    "$(expect_args \
        -t "$DEFAULT_TARGET" env PATH="/tmp/@TMPDIR@/.mb2/wrappers:$PATH" rpmbuild \
        --build-in-place --target= \
        --define 'noecho 1' \
        --define '_sourcedir /tmp/@TMPDIR@/rpm' \
        -bc --short-circuit \
        /tmp/@TMPDIR@/rpm/@TEST_SPEC@)" \
    qmake "a b" "c  d" e f

run_tc sb2_arg_pass "make" \
    "$(expect_args \
        -t "$DEFAULT_TARGET" env PATH="/tmp/@TMPDIR@/.mb2/wrappers:$PATH" rpmbuild \
        --build-in-place --target= \
        --define 'noecho 1' \
        --define '_sourcedir /tmp/@TMPDIR@/rpm' \
        -bc --short-circuit \
        /tmp/@TMPDIR@/rpm/@TEST_SPEC@)" \
    make "a b" "c  d" e f

KNOWN_ISSUE "Silently ignores extra arguments"
run_tc sb2_arg_pass "install" \
    "$(expect_args \
        -t "$DEFAULT_TARGET" rpmbuild --build-in-place --target= \
        --define 'noecho 1' \
        --define '_sourcedir /tmp/@TMPDIR@/rpm' \
        --define '_skip_install_processing 1' \
        --buildroot='/tmp/@TMPDIR@/installroot' \
        -bi --short-circuit --nocheck \
        /tmp/@TMPDIR@/rpm/@TEST_SPEC@)" \
    install "a b" "c  d" e f

KNOWN_ISSUE "Silently ignores extra arguments"
run_tc sb2_arg_pass "rpm" \
    "$(expect_args \
        -t "$DEFAULT_TARGET" rpmbuild --build-in-place --target= \
        --define 'noecho 1' \
        --define '_rpmdir /tmp/@TMPDIR@/RPMS' \
        --define '_sourcedir /tmp/@TMPDIR@/rpm' \
        --define '_rpmfilename %%{name}-%%{version}-%%{release}.%%{arch}.rpm' \
        --buildroot='/tmp/@TMPDIR@/installroot' \
        -bb --noprep --nobuildstage --noclean \
        /tmp/@TMPDIR@/rpm/@TEST_SPEC@)" \
    rpm "a b" "c  d" e f

tear_down_ts sb2_arg_pass

################################################################################
# Test arguments passing to commands invoked by rpmbuild

rpmbuild_arg_pass_ts_set_up() {
    RPMBUILD_STUBS=(qmake make)
    arg_pass_stub_create "${RPMBUILD_STUBS[@]}"

    sb2_stub_create || return

    # Create a minimal spec file
    mkdir rpm || return
    cat >rpm/test.spec <<END || return
Name:       test

# These would normally come from the environment
%{!?qmake:%define qmake qmake}
%{!?qmake5:%define qmake5 qmake}

# This is to not require meego-rpm-config installed for self-test execution
%global __os_install_post %{nil}

Summary:    Test
Version:    0.1
Release:    1
Group:      Qt/Qt
License:    LICENSE
URL:        http://example.org/
Source0:    %{name}-%{version}.tar.bz2

%description
Test

%prep
%setup -q -n %{name}-%{version}

%build
%qmake5
make %{?_smp_mflags}

%install
mkdir -p %{buildroot}

%files
%defattr(-,root,root,-)
END
}

rpmbuild_arg_pass_ts_tear_down() {
    arg_pass_stub_remove "${RPMBUILD_STUBS[@]}" || return
    sb2_stub_remove || return
    rm -f rpm/test.spec || return
    rmdir rpm || return
}

rpmbuild_arg_pass_tc() {
    local all_expected=("${@:1:${#RPMBUILD_STUBS[*]}}")
    local args=("${@:1+${#RPMBUILD_STUBS[*]}}")

    local rc=0

    arg_pass_stub_clear "${RPMBUILD_STUBS[@]}"
    "$SELF" "${args[@]}" || return
    local i=
    for ((i=0; i<${#RPMBUILD_STUBS[@]}; i++)); do
        local stub= expected= actual= diff=
        stub=${RPMBUILD_STUBS[i]}
        expected=${all_expected[i]}
        actual=$(arg_pass_stub_results "$stub")
        if ! diff=$(diff <(cat <<<"$expected") <(cat <<<"$actual")); then
            rc=1
            cat <<END
Test case failed: $TC_NAME/$i
  ** Command    ** $ME $(printf "%q " "${args[@]}")
  ** Failed for ** $stub
  ** Mismatch   ** [[
$diff
]]
  ** Expected   ** [[
$expected
]]
  ** Actual     ** [[
$actual
]]
END
        fi
    done

    return $rc
}

set_up_ts rpmbuild_arg_pass "Passing arguments to commands invoked by rpmbuild"

run_tc rpmbuild_arg_pass "build" \
    "$(expect_args )" \
    "$(expect_args -j"$DEFAULT_JOBS")" \
    build

run_tc rpmbuild_arg_pass "qmake" \
    "$(expect_args "a b" "c  d" e f)" \
    "$(expect_args )" \
    qmake "a b" "c  d" e f

if [[ $DEFAULT_JOBS -ne 1 ]]; then
    run_tc rpmbuild_arg_pass "make" \
        "$(expect_args )" \
        "$(expect_args -j"$DEFAULT_JOBS" "a b" "c  d" e f)" \
        make "a b" "c  d" e f
else
    run_tc rpmbuild_arg_pass "make" \
        "$(expect_args )" \
        "$(expect_args "a b" "c  d" e f)" \
        make "a b" "c  d" e f
fi

tear_down_ts rpmbuild_arg_pass

################################################################################
# Test arguments passing to commands invoked using run|ssh subcommand

ssh_arg_pass_ts_set_up() {
    :
}

ssh_arg_pass_ts_tear_down() {
    :
}

ssh_arg_pass_tc() {
    local expected=$1
    local args=("${@:2}")

    local actual= diff=
    actual=$("$SELF" "${args[@]}")
    if ! diff=$(diff <(cat <<<"$expected") <(cat <<<"$actual")); then
        cat <<END
Test case failed: $TC_NAME
  ** Command    ** $ME $(quote "${args[@]}")
  ** Mismatch   ** [[
$diff
]]
  ** Expected   ** [[
$expected
]]
  ** Actual     ** [[
$actual
]]
END
        return 1
    fi
}

set_up_ts ssh_arg_pass "Passing arguments using run|ssh subcommand"

run_tc ssh_arg_pass "local - just spaces" \
    "$(printf '%q ' 'a b' 'c  d' e f)" \
    run printf '%q ' 'a b' 'c  d' e f

run_tc ssh_arg_pass "local - spaces and newlines" \
    "$(printf '%q'$'\n' 'echo b' 'c  d' e f)" \
    run printf '%q'$'\n' 'echo b' 'c  d' e f

run_tc ssh_arg_pass "local - spaces and backslashes" \
    "$(printf '%q\n' 'a\ b' 'c  d' e f)" \
    run printf '%q\n' 'a\ b' 'c  d' e f

if [[ $DEFAULT_DEVICE ]]; then
    run_tc ssh_arg_pass "remote - just spaces" \
        "$(printf '%q ' 'a b' 'c  d' e f)" \
        --device "$DEFAULT_DEVICE" run printf '%q ' 'a b' 'c  d' e f

    run_tc ssh_arg_pass "remote - spaces and newlines" \
        "$(printf '%q'$'\n' 'echo b' 'c  d' e f)" \
        --device "$DEFAULT_DEVICE" run printf '%q'$'\n' 'echo b' 'c  d' e f

    run_tc ssh_arg_pass "remote - spaces and backslashes" \
        "$(printf '%q\n' 'a\ b' 'c  d' e f)" \
        --device "$DEFAULT_DEVICE" run printf '%q\n' 'a\ b' 'c  d' e f
fi

tear_down_ts ssh_arg_pass

################################################################################
# Test --fix-version behavior

fix_version_ts_set_up() {
    COMMITS_U=()
    COMMITS_D=()

    get_commit() {
        eval echo \${COMMITS_${1:0:1}[${1:1}]} |grep .
    }

    local i= commit= tag_name= tag_object=

    git init . --quiet || return
    git config user.email "john@doe.com" || return
    git config user.name "John Doe" || return

    git checkout -b upstream --quiet
    for ((i=0; i<=30; i++)); do
        printf "U%02d\n" "$i" > U
        git add U || return
        date="@$(TZ=UTC date --date="2000-01-01 00:00:00 UTC +$i days" +%s) +0000"
        GIT_AUTHOR_DATE=$date GIT_COMMITTER_DATE=$date \
            git commit --message "$(<U)" --quiet || return
        commit=$(git rev-list --max-count=1 --abbrev-commit HEAD) || return
        COMMITS_U=(${COMMITS_U[*]:-} $commit)
    done

    git checkout -b downstream "${COMMITS_U[10]}" --quiet || return
    for ((i=0; i<=20; i++)); do
        if [[ $i -eq 10 ]]; then
            git merge --no-commit "${COMMITS_U[20]}" --quiet 2>/dev/null || return
        fi
        printf "D%02d\n" "$i" > D
        git add D || return
        date="@$(TZ=UTC date --date="2000-01-01 00:00:00 UTC +$((i+10)) days +12 hours" +%s) +0000"
        GIT_AUTHOR_DATE=$date GIT_COMMITTER_DATE=$date \
            git commit --message "$(<D)" --quiet || return
        commit=$(git rev-list --max-count=1 --abbrev-commit HEAD) || return
        COMMITS_D=(${COMMITS_D[*]:-} $commit)
    done

    while [[ ${1:-} ]]; do
        case $1 in
            --tag)
                tag_name=$2
                tag_object=$(get_commit $3) || return
                git tag "$tag_name" "$tag_object" || return
                shift 2
                ;;
            --tag-a)
                tag_name=$2
                tag_object=$(get_commit $3) || return
                tag_annotation="$3"
                git tag -a -m "$tag_annotation" "$tag_name" "$tag_object" || return
                shift 2
                ;;
            *)
                return 1
                ;;
        esac
        shift
    done
}

fix_version_ts_tear_down() {
    unset COMMITS_U COMMITS_D
    unset -f get_commit
    rm -rf .git || return
    rm -f U D dirty || return
}

fix_version_tc() {
    local dirty=$1 head=$2 expected_raw=$3 hint=${4:-}

    head=$(get_commit "$head") || return

    git reset --hard --quiet || return
    git checkout -B downstream "$head" --quiet || return
    if [[ $dirty == dirty ]]; then
        echo dirty >> D
    fi

    local version_file=version
    local last_stash_file=last_stash

    echo "Version:" > $version_file

    (
        git() (
            echo "stub invoked: git" >&2
            if [[ $1 == stash && $2 == create ]]; then
                date="@$(TZ=UTC date --date="2000-12-31 18:00:00 UTC" +%s) +0000"
                GIT_AUTHOR_DATE=$date GIT_COMMITTER_DATE=$date \
                    command git stash create |tee $last_stash_file
            else
                command git "$@"
            fi
        )

        OPT_FIX_VERSION=1
        OPT_FIX_VERSION_HINT=$hint
        OPT_NO_FIX_VERSION=
        fix_package_version $version_file >&2
    ) || return

    local actual=$(sed 's/^Version: //' $version_file)

    local stash_sha1=
    if [[ -e $last_stash_file ]]; then
        stash_sha1=$(git rev-list --max-count=1 --abbrev-commit "$(<$last_stash_file)")
    fi

    local expected=$expected_raw i=
    for ((i=0; i<=30; i++)); do
        expected=${expected//@U$i@/${COMMITS_U[$i]}}
    done
    for ((i=0; i<=20; i++)); do
        expected=${expected//@D$i@/${COMMITS_D[$i]}}
    done
    expected=${expected//@STASH@/${stash_sha1:-<none>}}

    if [[ $actual != "$expected" ]]; then
        cat <<END
Test case failed: $TC_NAME
  ** Arguments    ** $(printf "%q " "$@")
  ** Expected     ** '$expected'
  ** Actual       ** '$actual'
  ** Expected RAW ** '$expected_raw'
  ** Git-status   ** [[
$(git status)
]]
  ** Git-log      ** [[
$(git log --graph --decorate --pretty=fuller --all ${stash_sha1:-})
]]
END
        return 1
    fi
}

# Works with Git history like this
#
# U00---...---U10---U11---...---U20---U21---...---U30 <-- upstream
#               \                 \
#                D00---D01---...---D10---D11---...---D20 <-- downstream
#
# Upstream commit dates are 2000-01-01 + <num> days 00:00 UTC, downstream commit dates are
# 2000-01-01 + <num+10> days 12:00 UTC, stashes are 2000-12-31 18:00 UTC.

set_up_ts fix_version "Test --fix-version behavior" \
    --tag v0.1 U5 \
    --tag v0.2 U10 \
    --tag v0.3 U15 \
    --tag v0.4 U20 \
    --tag v0.5 U25 \
    --tag mer/v0.2+git1 D5 \
    --tag mer/v0.4+git1 D11 \
    --tag-a mer/v0.4+git2 D15 \
    --tag mer/v0.4+git3 D20

run_tc fix_version "on tag, clean D5"               clean D5  0.2+git1
run_tc fix_version "ahead tag, clean D7"            clean D7  0.2+git1+downstream.2000''01''18''12''00''00.@D7@
run_tc fix_version "ahead tag, dirty D7"            dirty D7  0.2+git1+downstream.2000''12''31''18''00''00.@STASH@
run_tc fix_version "ahead upstream tag, clean D10"  clean D10 0.4+downstream.2000''01''21''12''00''00.@D10@
run_tc fix_version "on tag, clean D11"              clean D11 0.4+git1
run_tc fix_version "on tag, dirty D11"              dirty D11 0.4+git1+downstream.2000''12''31''18''00''00.@STASH@
run_tc fix_version "ahead tag, clean D12"           clean D12 0.4+git1+downstream.2000''01''23''12''00''00.@D12@
run_tc fix_version "ahead tag, dirty D12"           dirty D12 0.4+git1+downstream.2000''12''31''18''00''00.@STASH@
run_tc fix_version "on annotated, clean D15"        clean D15 0.4+git2
run_tc fix_version "ahead annotated, clean D16"     clean D16 0.4+git2+downstream.2000''01''27''12''00''00.@D16@
run_tc fix_version "ahead annotated, dirty D16"     dirty D16 0.4+git2+downstream.2000''12''31''18''00''00.@STASH@
run_tc fix_version "on tag, clean D15 + hint"       clean D15 0.4+git1+downstream.2000''01''26''12''00''00.@D15@    mer/v0.4+git1
run_tc fix_version "on tag, dirty D15 + hint"       dirty D15 0.4+git1+downstream.2000''12''31''18''00''00.@STASH@  mer/v0.4+git1
run_tc fix_version "ahead tag, clean D16 + hint"    clean D16 0.4+git1+downstream.2000''01''27''12''00''00.@D16@    mer/v0.4+git1
run_tc fix_version "ahead tag, dirty D16 + hint"    dirty D16 0.4+git1+downstream.2000''12''31''18''00''00.@STASH@  mer/v0.4+git1

tear_down_ts fix_version

################################################################################
# Test the readarray behavior - simplified version implemented as a shell
# function for compatibility with older BASH

readarray_tc() {
    local expected=('  abc *  def  ' '  g  h  i  ')
    local actual=()
    echo "Note: readarray is a $(type -t readarray)" >&2
    readarray -t actual < <(printf "%s\n" "${expected[@]}")
    if ! (
        [[ ${#expected[*]} -eq ${#actual[*]} ]] || exit
        for ((i=0; i<${#expected[*]}; i++)); do
            [[ ${actual[$i]} == "${expected[$i]}" ]] || exit
        done
        ); then
        cat <<END
Test case failed: $TC_NAME
  ** Expected   ** [[
$(declare -p expected)
]]
  ** Actual     ** [[
$(declare -p actual)
]]
END
        return 1
    fi
}

run_tc readarray "Test readarray behavior"

################################################################################
# Test build phases separation

rpmbuild_phases_ts_set_up() {
    RPMBUILD_STUBS=(my_setup qmake make my_install my_check)
    arg_pass_stub_create "${RPMBUILD_STUBS[@]}"

    sb2_stub_create || return

    # Create a minimal spec file
    mkdir rpm || return
    cat >rpm/test.spec <<END || return
Name:       test

# These would normally come from the environment
%{!?qmake:%define qmake qmake}
%{!?qmake5:%define qmake5 qmake}

# This is to not require meego-rpm-config installed for self-test execution
%global __os_install_post %{nil}

Summary:    Test
Version:    0.1
Release:    1
Group:      Qt/Qt
License:    LICENSE
URL:        http://example.org/
Source0:    %{name}-%{version}.tar.bz2

%description
Test

%prep
my_setup

%build
%qmake5
make %{?_smp_mflags}

%install
mkdir -p %{buildroot}
my_install

# Verifies that --noclean is used
touch %{buildroot}/foo

%check
my_check

%files
%defattr(-,root,root,-)
/foo
END
}

rpmbuild_phases_ts_tear_down() {
    arg_pass_stub_remove "${RPMBUILD_STUBS[@]}" || return
    sb2_stub_remove || return
    rm -f rpm/test.spec || return
    rmdir rpm || return
    rm -f RPMS/test-0.1-1.i486.rpm || return
    ! [[ -d RPMS ]] || rmdir RPMS || return
    rm -f "$buildroot/foo" || return
}

rpmbuild_phases_tc() {
    local expected=$1
    local args=("${@:2}")

    arg_pass_stub_clear "${RPMBUILD_STUBS[@]}" || return
    rm -f RPMS/test-0.1-1.i486.rpm || return

    "$SELF" "${args[@]}" || return

    local actual=
    if arg_pass_stub_results my_setup &>/dev/null; then
        actual="+prep"
    else
        actual="-prep"
    fi

    if arg_pass_stub_results qmake &>/dev/null; then
        actual="$actual +qmake"
    else
        actual="$actual -qmake"
    fi

    if arg_pass_stub_results make &>/dev/null; then
        actual="$actual +make"
    else
        actual="$actual -make"
    fi

    if arg_pass_stub_results my_install &>/dev/null; then
        actual="$actual +install"
    else
        actual="$actual -install"
    fi

    if arg_pass_stub_results my_check &>/dev/null; then
        actual="$actual +check"
    else
        actual="$actual -check"
    fi

    if [[ -e RPMS/test-0.1-1.i486.rpm ]]; then
        if rpm -q --requires -p RPMS/test-0.1-1.i486.rpm |grep -q '^rpmlib(ShortCircuited)'; then
            actual="$actual +rpm (short-circuited)"
        else
            actual="$actual +rpm"
        fi
    else
        actual="$actual -rpm"
    fi

    if [[ $actual != "$expected" ]]; then
        cat <<END
Test case failed: $TC_NAME
  ** Command    ** $ME $(printf "%q " "${args[@]}")
  ** Expected   ** $expected
  ** Actual     ** $actual
END
        return 1
    fi

    return 0
}

set_up_ts rpmbuild_phases "Separating build phases"

run_tc rpmbuild_phases "prep" \
    "+prep -qmake -make -install -check -rpm" prep
run_tc rpmbuild_phases "build" \
    "-prep +qmake +make +install +check +rpm" build
run_tc rpmbuild_phases "build --doprep" \
    "+prep +qmake +make +install +check +rpm" build --doprep
run_tc rpmbuild_phases "qmake" \
    "-prep +qmake -make -install -check -rpm" qmake
run_tc rpmbuild_phases "make" \
    "-prep -qmake +make -install -check -rpm" make
run_tc rpmbuild_phases "install" \
    "-prep -qmake -make +install -check -rpm" install
run_tc rpmbuild_phases "rpm" \
    "-prep -qmake -make +install +check +rpm" rpm

tear_down_ts rpmbuild_phases

################################################################################
# Test compatibility with various packaging options

# Accepts up to one argument - .pro file or a directory where to looks for a pro file. Defaults to
# current working directory. Creates Makefile that makes single file named after the TARGET name and
# installs it directly under the INSTALL_ROOT.
special_packaging_qmake_stub() {
    shopt -s nullglob
    if [[ $# -eq 0 ]]; then
        pro_files=(*.pro)
    elif [[ $# -eq 1 ]]; then
        if [[ $1 == *.pro ]]; then
            if [[ ! -e $1 ]]; then
                echo "stub qmake: file not found: $1" >&2
                return 1
            fi
            pro_files=($1)
        elif [[ -d $1 ]]; then
            pro_files=("$1"/*.pro)
        else
            echo "stub qmake: not a directory: $1" >&2
            return 1
        fi
    else
        echo "stub qmake: up to one argument expected" >&2
        return 1
    fi

    if [[ ${#pro_files[*]} -lt 1 ]]; then
        echo "stub qmake: no project file found" >&2
        return 1
    elif [[ ${#pro_files[*]} -gt 1 ]]; then
        echo "stub qmake: multiple project files found - select one" >&2
        return 1
    fi

    target=$(sed -n 's/^TARGET=//p' $pro_files)
    if [[ ! $target ]]; then
        echo "stub qmake: failed to parse project file '$pro_files'" >&2
        return 1
    fi

    cat >Makefile <<EOF
all:
	echo $target > $target

install:
	cp $target \$(INSTALL_ROOT)/$target
EOF
}

special_packaging_ts_set_up() {
    sb2_stub_create || return

    cat >"$STUBS_DIR/qmake" <<END || return
#!/bin/bash
$(declare -f special_packaging_qmake_stub)
special_packaging_qmake_stub "\$@"
END
    chmod +x "$STUBS_DIR/qmake" || return
}

special_packaging_ts_tear_down() {
    sb2_stub_remove || return
    rm -f "$STUBS_DIR/qmake" || return
}

# Accepts 6 arguments described inline
special_packaging_tc() {
    # SUBDIR: Put sources under subdirectory
    #   - N: No
    #   - Y: Yes, pass it to the %setup macro
    #   - NOSET: Yes, do not pass it to the %setup macro
    local maybe_subdir=$([[ $1 == Y || $1 == NOSET ]] && echo test)
    local maybe_setupdir=$([[ $1 == Y ]] && echo "/%{name}")

    # MULTI: Create multiple .spec and .pro files
    #   - Y/N
    local enable_multi=$([[ $2 == Y ]] && echo 1)

    # PATCH: Create .spec with patches
    #   - N: No
    #   - APPLY: Yes, use 'mb2 apply' to apply them
    #   - PREP: Yes, use 'mb2 prep' to apply them
    #   - DOPREP: Yes, use 'mb2 build --doprep' to apply them
    local enable_patch=$([[ $3 == APPLY || $3 == PREP || $3 == DOPREP ]] && echo "$3")

    # SHADOW BUILD: Do shadow build
    #   - Y/N
    local enable_shadow=$([[ $4 == Y ]] && echo 1)

    # PROJECT IN SPEC: Pass .pro file to qmake call in the .spec file
    #   - Y/N
    local maybe_project_in_spec=
    if [[ $5 == Y ]]; then
        if [[ ! $maybe_subdir || $maybe_setupdir ]]; then
            maybe_project_in_spec=test.pro
        else
            maybe_project_in_spec=$maybe_subdir/test.pro
        fi
    fi

    # PROJECT ON CMDLN: Pass .pro file or directory on command line
    #   - N: No
    #   - FILE: Yes
    #   - DIR: Yes, pass the path to the subdirectory containing the .pro file
    #   - OTHER: Yes, pass other .pro file than used in the .spec
    local project_on_cmdln=
    case $6 in
        FILE) project_on_cmdln=${maybe_subdir:+$maybe_subdir/}test.pro;;
        DIR) project_on_cmdln=$maybe_subdir;;
        OTHER) project_on_cmdln=${maybe_subdir:+$maybe_subdir/}other.pro;;
    esac

    local srcdir=test
    local builddir=test

    local spec_arg=()
    if [[ $enable_multi ]]; then
        if [[ $enable_shadow ]]; then
            spec_arg=(--specfile ../test/rpm/test.spec)
        else
            spec_arg=(--specfile rpm/test.spec)
        fi
    fi

    if [[ $enable_shadow ]]; then
        if [[ $project_on_cmdln ]]; then
            project_on_cmdln=/$project_on_cmdln
        fi
        project_on_cmdln=../test$project_on_cmdln
        builddir=test-build
    fi

    mkdir -p "$srcdir" || return
    mkdir -p "$builddir" || return

    mkdir "$srcdir/rpm" || return
    cat >"$srcdir/rpm/test.spec" <<END || return
Name:       test

# These would normally come from the environment
%{!?qmake:%define qmake qmake}
%{!?qmake5:%define qmake5 qmake}
%{!?qmake5_install:%define qmake5_install make install INSTALL_ROOT=%{buildroot}}

# This is to not require meego-rpm-config installed for self-test execution
%global __os_install_post %{nil}

# Make it noop
%define setup echo

Summary:    Test
Version:    0.1
Release:    1
Group:      Qt/Qt
License:    LICENSE
URL:        http://example.org/
Source0:    %{name}-%{version}.tar.bz2
${enable_patch:+Patch0:  test-fix.patch}

%description
Test

%prep
%setup -q -n %{name}-%{version}${maybe_setupdir}
${enable_patch:+%patch0 -p1}

%build
%qmake5 ${maybe_project_in_spec}
make %{?_smp_mflags}

%install
mkdir -p %{buildroot}
%qmake5_install

%files
%defattr(-,root,root,-)
/foo${enable_patch:+-patched}
END

    mkdir -p "$srcdir/$maybe_subdir" || return
    echo TARGET=foo > "$srcdir/$maybe_subdir/test.pro" || return

    if [[ $enable_multi ]]; then
        touch "$srcdir/rpm/other.spec" || return
        mkdir -p "$srcdir/$maybe_subdir" || return
        echo TARGET=bar > "$srcdir/$maybe_subdir/other.pro" || return
    fi

    if [[ $enable_patch ]]; then
        cat >"$srcdir/rpm/test-fix.patch" <<END || return
--- a/test.pro
+++ b/test.pro
@@ -1 +1 @@
-TARGET=foo
+TARGET=foo-patched
END
    fi

    find -ls >&2

    (
        maybe_doprep=
        case $enable_patch in
            APPLY) (
                cd "$srcdir" || return
                echo "--- Preparing sources" >&2
                set -x
                "$SELF" ${spec_arg[@]:+"${spec_arg[@]}"} apply || return
                ) || return;;
            PREP) (
                cd "$srcdir" || return
                echo "--- Preparing sources" >&2
                set -x
                "$SELF" ${spec_arg[@]:+"${spec_arg[@]}"} prep || return
                ) || return;;
            DOPREP)
                maybe_doprep=--doprep
                ;;
        esac

        (
            cd "$builddir" || return
            echo "--- Running build" >&2
            set -x
            "$SELF" ${spec_arg[@]:+"${spec_arg[@]}"} build ${maybe_doprep} ${project_on_cmdln:+"$project_on_cmdln"} || return
        ) || return

        rm -rf "$builddir"/{.mb2,RPMS,Makefile,foo} "$buildroot" || return

        (
            cd "$builddir" || return
            echo "--- Running qmake/make/rpm" >&2
            set -x
            "$SELF" ${spec_arg[@]:+"${spec_arg[@]}"} qmake ${project_on_cmdln:+"$project_on_cmdln"} || return
            "$SELF" ${spec_arg[@]:+"${spec_arg[@]}"} make || return
            "$SELF" ${spec_arg[@]:+"${spec_arg[@]}"} rpm || return
        ) || return
    )

    if [[ $? -ne 0 ]]; then
        cat <<END
Test case failed: $TC_NAME
END
        return 1
    fi

    return 0
}

special_packaging_tc_tear_down() {
    rm -rf "$buildroot" || return
    rm -rf ./test ./test-build || return
}

#   SUBDIR  MULTI  PATCH  SHADOW  PROJECT  PROJECT
#                         BUILD   IN SPEC  ON CMDLN

set_up_ts special_packaging "Compatibility / Flat package"
run_tc special_packaging "Basic" \
    N       N      N      N       N        N
run_tc special_packaging "Basic (shadow)" \
    N       N      N      Y       N        N
run_tc special_packaging "Pass .pro file in spec" \
    N       N      N      N       Y        N
run_tc special_packaging "Pass .pro file in spec (shadow)" \
    N       N      N      Y       Y        N
run_tc special_packaging "Pass .pro file on cmdline" \
    N       N      N      N       N        FILE
run_tc special_packaging "Pass .pro file in spec and on cmdline (shadow)" \
    N       N      N      Y       Y        FILE
tear_down_ts special_packaging

#   SUBDIR  MULTI  PATCH  SHADOW  PROJECT  PROJECT
#                         BUILD   IN SPEC  ON CMDLN

set_up_ts special_packaging "Compatibility / Flat package / Multiple configs"
run_tc special_packaging "Basic" \
    N       Y      N      N       Y        N
run_tc special_packaging "Basic (shadow)" \
    N       Y      N      Y       Y        N
run_tc special_packaging "Pass .pro file" \
    N       Y      N      N       Y        FILE
run_tc special_packaging "Pass .pro file (shadow)" \
    N       Y      N      Y       Y        FILE
run_tc special_packaging "Pass other .pro file" \
    N       Y      N      N       Y        OTHER
run_tc special_packaging "Pass other .pro file (shadow)" \
    N       Y      N      Y       Y        OTHER
tear_down_ts special_packaging

#   SUBDIR  MULTI  PATCH  SHADOW  PROJECT  PROJECT
#                         BUILD   IN SPEC  ON CMDLN

set_up_ts special_packaging "Compatibility / Flat package / With patches"
run_tc special_packaging "Use apply" \
    N       N      APPLY  N       N        N
run_tc special_packaging "Use apply (shadow)" \
    N       N      APPLY  Y       N        N
run_tc special_packaging "Use prep" \
    N       N      PREP   N       N        N
run_tc special_packaging "Use prep (shadow)" \
    N       N      PREP   Y       N        N
run_tc special_packaging "Use --doprep" \
    N       N      DOPREP N       N        N
tear_down_ts special_packaging

#   SUBDIR  MULTI  PATCH  SHADOW  PROJECT  PROJECT
#                         BUILD   IN SPEC  ON CMDLN

set_up_ts special_packaging "Compatibility / Subtree package"
run_tc special_packaging "Basic" \
    Y       N      N      N       N        N
run_tc special_packaging "Basic (shadow)" \
    Y       N      N      Y       N        N
run_tc special_packaging "Pass .pro file" \
    Y       N      N      N       N        FILE
run_tc special_packaging "Pass .pro file (shadow)" \
    Y       N      N      Y       N        FILE
run_tc special_packaging "Pass .pro dir" \
    Y       N      N      N       N        DIR
run_tc special_packaging "Pass .pro dir (shadow)" \
    Y       N      N      Y       N        DIR
tear_down_ts special_packaging

#   SUBDIR  MULTI  PATCH  SHADOW  PROJECT  PROJECT
#                         BUILD   IN SPEC  ON CMDLN

set_up_ts special_packaging "Compatibility / Subtree package / Without %setup subdir"
run_tc special_packaging "Basic" \
    NOSET   N      N      N       Y        N
run_tc special_packaging "Basic (shadow)" \
    NOSET   N      N      Y       Y        N
run_tc special_packaging "Pass .pro file" \
    NOSET   N      N      N       Y        FILE
run_tc special_packaging "Pass .pro file (shadow)" \
    NOSET   N      N      Y       Y        FILE
run_tc special_packaging "Pass .pro dir" \
    NOSET   N      N      N       Y        DIR
run_tc special_packaging "Pass .pro dir (shadow)" \
    NOSET   N      N      Y       Y        DIR
tear_down_ts special_packaging

#   SUBDIR  MULTI  PATCH  SHADOW  PROJECT  PROJECT
#                         BUILD   IN SPEC  ON CMDLN

set_up_ts special_packaging "Compatibility / Subtree package / Multiple configs"
run_tc special_packaging "Basic" \
    Y       Y      N      N       Y        N
run_tc special_packaging "Basic (shadow)" \
    Y       Y      N      Y       Y        N
run_tc special_packaging "Pass .pro file" \
    Y       Y      N      N       Y        FILE
run_tc special_packaging "Pass .pro file (shadow)" \
    Y       Y      N      Y       Y        FILE
run_tc special_packaging "Pass .pro dir" \
    Y       Y      N      N       Y        DIR
run_tc special_packaging "Pass .pro dir (shadow)" \
    Y       Y      N      Y       Y        DIR
run_tc special_packaging "Pass other .pro file" \
    Y       Y      N      N       Y        OTHER
run_tc special_packaging "Pass other .pro file (shadow)" \
    Y       Y      N      Y       Y        OTHER
tear_down_ts special_packaging

#   SUBDIR  MULTI  PATCH  SHADOW  PROJECT  PROJECT
#                         BUILD   IN SPEC  ON CMDLN

set_up_ts special_packaging "Compatibility - Subtree package / With patches"
run_tc special_packaging "Use apply" \
    Y       N      APPLY  N       N        N
run_tc special_packaging "Use apply (shadow)" \
    Y       N      APPLY  Y       N        N
run_tc special_packaging "Use prep" \
    Y       N      PREP   N       N        N
run_tc special_packaging "Use prep (shadow)" \
    Y       N      PREP   Y       N        N
run_tc special_packaging "Use doprep" \
    Y       N      DOPREP N       N        N
tear_down_ts special_packaging

################################################################################

if [[ $tc_failed_num -eq 0 ]]; then
    echo "*** All $tc_num tests passed"
else
    echo "*** $tc_failed_num out of $tc_num failed"
fi

# For Emacs:
# Local Variables:
# indent-tabs-mode:nil
# tab-width:4
# mode: sh
# End:
# For VIM:
# vim:set softtabstop=4 shiftwidth=4 tabstop=4 expandtab:
